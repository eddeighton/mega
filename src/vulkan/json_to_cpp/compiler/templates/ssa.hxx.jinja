
// C++ SSA Header


#ifndef SSA_GEN_25_JULY_2022
#define SSA_GEN_25_JULY_2022

#include "ssa.hpp"

//#include <vulkan/vulkan.hpp>
//#include <vulkan/vulkan_handles.hpp>
//#include <vulkan/vulkan_structs.hpp>
//#include <vulkan/vulkan_format_traits.hpp>

#include "/workspace/root/thirdparty/vulkansdk/1.3.204.0/x86_64/include/vulkan/vulkan.hpp"
#include "/workspace/root/thirdparty/vulkansdk/1.3.204.0/x86_64/include/vulkan/vulkan_handles.hpp"
#include "/workspace/root/thirdparty/vulkansdk/1.3.204.0/x86_64/include/vulkan/vulkan_structs.hpp"

namespace ssa
{

template < typename T >
struct structureChainTraits
{
    static_assert( false && typeid( T ).name(), "Invalid structure chain: " );
};

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
// chain struct traits
{% for chainTrait in chainTraits %}
template <>
struct structureChainTraits< Chain< {% for type in chainTrait.types %}{{type}}{% if not loop.is_last %}, {%endif%}{% endfor %} > >
{
    static constexpr uint32_t ID = {{ chainTrait.id }};
};
{% endfor %}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
// commands
{% for command in commands %}
{% if command.param_count > 0 %}
template
<
{% for param in command.params %}
    template< typename T{{param.index}} > class W{{param.index}}{% if not loop.is_last %}, {%endif%}

{% endfor %}
>
{% endif %}
inline {{ command.result_type }}
{{ command.name }}
(
{% for param in command.params %}
    const W{{param.index}}< {{ param.type }} >& {{ param.name }}{% if not loop.is_last %}, {%endif%}

{% endfor %}
)
{
    typename Command::Ptr pCommand = Allocator::get().make_command();
    pCommand->id = {{ command.typeid }};
{% for param in command.params %}
{% if param.optional %}
    pCommand->parameters.push_back( get_param_optional( {{ param.name }} ) );
{% else %}
    pCommand->parameters.push_back( get_param( {{ param.name }} ) );
{% endif %}
{% endfor %}
{% for result in command.results %}
    Lazy< {{ result.type }} > {{ result.name }}{ Allocator::get().make_value< {{ result.type }} >() };
{% endfor %}
{% for result in command.results %}
    pCommand->results.push_back( get_param( {{ result.name }} ) );
{% endfor %}
    return std::make_tuple( {{ command.main_result }}{ pCommand }{% for result in command.results %}, {{ result.name }}{% endfor %} );
}
{% endfor %}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
// non chain constructors
{% for nonChainCtor in nonChainCtors %}
{% if nonChainCtor.param_count > 0 %}
template
<
{% for param in nonChainCtor.params %}
    template< typename T{{param.index}} > class W{{param.index}}{% if not loop.is_last %}, {%endif%}

{% endfor %}
>
{% endif %}
inline Lazy< {{ nonChainCtor.type }} >
{{ nonChainCtor.name }}
(
{% for param in nonChainCtor.params %}
    const W{{param.index}}< {{ param.type }} >& {{ param.name }}{% if not loop.is_last %}, {%endif%}

{% endfor %}
)
{
    typename Value< {{ nonChainCtor.type }} >::Ptr pValue = Allocator::get().make_value< {{ nonChainCtor.type }} >();
    pValue->id = {{ nonChainCtor.typeid }};
{% for param in nonChainCtor.params %}
{% if param.optional %}
    pValue->parameters.push_back( get_param_optional( {{ param.name }} ) );
{% else %}
    pValue->parameters.push_back( get_param( {{ param.name }} ) );
{% endif %}
{% endfor %}
    return Lazy< {{ nonChainCtor.type }} >{ pValue };
}
{% endfor %}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
// chaining structure constructors
{% for chainCtor in chainCtors %}

// no chain tail overload
{% if chainCtor.param_count > 1 %}
template
<
{% for param in chainCtor.params %}
{% if not param.chain %}
    template< typename T{{param.index}} > class W{{param.index}}{% if not loop.is_last %}, {%endif%}

{% endif %}
{% endfor %}
>
{% endif %}
inline Lazy< typename make_chain< Chain< {{ chainCtor.type }} > >::Type >
{{ chainCtor.name }}
(
{% for param in chainCtor.params %}
{% if not param.chain %}
    const W{{param.index}}< {{ param.type }} >& {{ param.name }}{% if not loop.is_last %}, {%endif%}

{% endif %}
{% endfor %}
)
{
    using TChain = typename make_chain< Chain< {{ chainCtor.type }} > >::Type;
    typename TChain::Ptr pValue = Allocator::get().make_chain< TChain >();
    pValue->id = structureChainTraits< TChain >::ID;
{% for param in chainCtor.params %}
{% if not param.chain %}
{% if param.optional %}
    pValue->parameters.push_back( get_param_optional( {{ param.name }} ) );
{% else %}
    pValue->parameters.push_back( get_param( {{ param.name }} ) );
{% endif %}
{% endif %}
{% endfor %}
    return Lazy< TChain >{ pValue };
}

// chain tail overload
template
<
{% for param in chainCtor.params %}
    template< typename T{{param.index}} > class W{{param.index}}{% if param.chain %}, typename TChainTail{% endif%}{% if not loop.is_last %}, {%endif%}

{% endfor %}
>
inline Lazy< typename make_chain< Chain< {{ chainCtor.type }}, TChainTail > >::Type >
{{ chainCtor.name }}
(
{% for param in chainCtor.params %}
    const W{{param.index}}< {{ param.type }} >& {{ param.name }}{% if not loop.is_last %}, {%endif%}

{% endfor %}
)
{
    using TChain = typename make_chain< Chain< {{ chainCtor.type }}, TChainTail > >::Type;
    typename TChain::Ptr pValue = Allocator::get().make_chain< TChain >();
    pValue->id = structureChainTraits< TChain >::ID;
{% for param in chainCtor.params %}
{% if param.optional %}
    pValue->parameters.push_back( get_param_optional( {{ param.name }} ) );
{% else %}
    pValue->parameters.push_back( get_param( {{ param.name }} ) );
{% endif %}
{% endfor %}
    return Lazy< TChain >{ pValue };
}

{% endfor %}


}

#endif //SSA_GEN_25_JULY_2022


