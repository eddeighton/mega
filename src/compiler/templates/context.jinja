struct [[clang::eg_type( {{ typeid }} )]]{{ name }}
{
    enum : mega::TypeID
    {
        ID = {{ typeid }}
    };
    mega::reference data;
    inline {{ name }}()
    {
        data.instance = 0;
        data.type = 0;
        data.address = mega::INVALID_ADDRESS;
    };
    inline {{ name }}( const mega::reference& reference )
        :   data( reference )
    {
    }
    inline operator ::mega::ReferenceState() const
    {
        return ::mega::Null;
    }
    inline bool operator==( ::mega::ReferenceState cmp ) const
    {
        return false;
    }
    inline bool operator!=( ::mega::ReferenceState cmp ) const
    {
        return false;
    }
{% if has_operation %}
    {{ operation_return_type }} operator()( {{ operation_parameters }} ) const;
{% endif %}
    template< typename TypePath, typename Operation, typename... Args >
    inline typename mega::result_type< {{ name }}, TypePath, Operation >::Type invoke( Args... args ) const
    {
        using ResultType = typename mega::result_type< {{ name }}, TypePath, Operation >::Type;
        if constexpr ( std::is_same< ResultType, void >::value )
        {
            invoke_impl_void< {{ name }}, TypePath, Operation, Args... >( *this, args... );
        }
        if constexpr ( !std::is_same< ResultType, void >::value )
        {
            return invoke_impl< ResultType, {{ name }}, TypePath, Operation, Args... >( *this, args... );
        }
    }
{% for trait_struct in trait_structs %}
    struct [[clang::eg_type( {{ trait_struct.typeid }} )]]{{ trait_struct.name }};
{% endfor %}
    {{ nested }}
};
