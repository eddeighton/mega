struct [[clang::eg_type( {{ typeid }} )]]{{ name }} : public mega::reference
{
    enum : mega::TypeID::ValueType { ID = {{ typeid }} };
    inline {{ name }}() = default;
    inline {{ name }}( mega::reference reference ) : mega::reference( reference ) {}
    template< typename T >
    inline bool operator==( const T& cmp ) const
    {
        return mega::reference::operator==( cmp );
    }
    template< typename T >
    inline bool operator!=( const T& cmp ) const
    {
        return !this->operator==( cmp );
    }
    inline operator const void*() const
    {
        return valid() ? this : nullptr;
    }
{% if has_operation %}
    {{ operation_return_type }} operator()( {{ operation_parameters }} ) const;
{% endif %}
    template< typename TypePath, typename Operation, typename... Args >
    inline typename mega::result_type< {{ name }}, TypePath, Operation >::Type invoke( Args... args ) const
    {
        using ResultType = typename mega::result_type< {{ name }}, TypePath, Operation >::Type;
        if constexpr ( std::is_same< ResultType, void >::value )
            invoke_impl_void< {{ name }}, TypePath, Operation, Args... >( *this, args... );
        if constexpr ( !std::is_same< ResultType, void >::value )
            return invoke_impl< ResultType, {{ name }}, TypePath, Operation, Args... >( *this, args... );
    }
{% for trait_struct in trait_structs %}
    struct [[clang::eg_type( {{ trait_struct.typeid }} )]]{{ trait_struct.name }};
{% endfor %}
    {{ nested }}
};
