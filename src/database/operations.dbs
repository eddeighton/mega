//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.


namespace Operations
{
    
    object InterfaceVariant -> OperationsStage::Operations
    {
        opt< ref< Interface::IContext > > context;
        opt< ref< Interface::DimensionTrait > > dimension;
    }

    object ConcreteVariant -> OperationsStage::Operations
    {
        opt< ref< Concrete::Context > > context;
        opt< ref< Concrete::Dimensions::User > > dimension;
    }

    object Element -> OperationsStage::Operations
    {
        ref< InterfaceVariant > interface;
        ref< ConcreteVariant > concrete;
    }

    object ElementVector -> OperationsStage::Operations
    {
        array< ref< Element > > elements;
    }

    object Context -> OperationsStage::Operations
    {
        array< ref< ElementVector > > vectors;
    }

    object TypePath -> OperationsStage::Operations
    {
        array< ref< ElementVector > > vectors;
    }

    object NameRoot -> OperationsStage::Operations
    {
        array< ref< Name > > children;
    }

    object Name : NameRoot -> OperationsStage::Operations
    {
        ref< Element > element;
        value< bool > is_member;
        value< bool > is_reference;
    }

    object NameResolution -> OperationsStage::Operations
    {
        ref< NameRoot > root_name;
    }

    object Invocation -> OperationsStage::Operations
    {
        value< mega::InvocationID > id;
        ref< Context > context;
        ref< TypePath > type_path;
        value< mega::OperationID > operation;
        value< std::string > name;
        value< std::string > context_str;
        value< std::string > type_path_str;

        late< value< mega::ExplicitOperationID > > explicit_operation;
        late< value< std::string > > return_type_str;
        late< value< std::string > > runtime_return_type_str;
        late< value< std::string > > runtime_parameter_type_str;

        late< ref< NameResolution > > name_resolution;

        late< ref< Invocations::Instructions::Root > > root_instruction;

        array< ref< Invocations::Variables::Variable > > variables;

        late< array< ref< Interface::IContext > > > parameter_contexts;
        late< array< ref< Interface::IContext > > > return_type_contexts;
        late< array< ref< Interface::DimensionTrait > > > return_type_dimensions;
        late< value< bool > > homogeneous;
        late< value< bool > > singular;
        late< value< bool > > is_function_call;
        
        late< array< value< mega::SourceLocation > > > file_offsets;
    }

    object Invocations -> OperationsStage::Operations
    {
        map< value< mega::InvocationID >, ref< Invocation > > invocations;
    }
}
