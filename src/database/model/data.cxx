//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.

// this made no diff on windows
// #ifdef _WIN32
// #pragma runtime_checks( "", off )
// #pragma optimize( "2", on )
// #define VERIFY_RTE_MSG
// #endif


#include "database/model/data.hxx"

#include "nlohmann/json.hpp"

namespace nlohmann {
    template <typename T>
    struct adl_serializer< std::optional<T> > 
    {
        static void to_json(json& j, const std::optional<T>& opt) 
        {
            if (!opt.has_value()) 
            {
                j = nullptr;
            } 
            else 
            {
                j = opt.value();
            }
        }
        static void from_json(const json& j, std::optional<T>& opt) 
        {
            if (j.is_null()) 
            {
                opt = std::optional<T>();
            } 
            else 
            {
                opt = j.get<T>();
            }
        }
    };
}

namespace data
{

namespace Components
{
    // struct Components_Component : public mega::io::Object
    Components_Component::Components_Component( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Components::Components_Component >( loader, this ) )    {
    }
    Components_Component::Components_Component( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::ComponentType& type, const std::string& name, const mega::io::ComponentFilePath& file_path, const boost::filesystem::path& src_dir, const boost::filesystem::path& build_dir, const std::vector< std::string >& cpp_flags, const std::vector< std::string >& cpp_defines, const std::vector< boost::filesystem::path >& include_directories, const std::vector< mega::io::megaFilePath >& dependencies, const std::vector< mega::io::megaFilePath >& mega_source_files, const std::vector< mega::io::cppFilePath >& cpp_source_files)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Components::Components_Component >( loader, this ) )          , type( type )
          , name( name )
          , file_path( file_path )
          , src_dir( src_dir )
          , build_dir( build_dir )
          , cpp_flags( cpp_flags )
          , cpp_defines( cpp_defines )
          , include_directories( include_directories )
          , dependencies( dependencies )
          , mega_source_files( mega_source_files )
          , cpp_source_files( cpp_source_files )
    {
    }
    bool Components_Component::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Components::Components_Component > >{ data::Ptr< data::Components::Components_Component >( loader, const_cast< Components_Component* >( this ) ) };
    }
    void Components_Component::set_inheritance_pointer()
    {
    }
    void Components_Component::load( mega::io::Loader& loader )
    {
        loader.load( type );
        loader.load( name );
        loader.load( file_path );
        loader.load( src_dir );
        loader.load( build_dir );
        loader.load( cpp_flags );
        loader.load( cpp_defines );
        loader.load( include_directories );
        loader.load( dependencies );
        loader.load( mega_source_files );
        loader.load( cpp_source_files );
    }
    void Components_Component::store( mega::io::Storer& storer ) const
    {
        storer.store( type );
        storer.store( name );
        storer.store( file_path );
        storer.store( src_dir );
        storer.store( build_dir );
        storer.store( cpp_flags );
        storer.store( cpp_defines );
        storer.store( include_directories );
        storer.store( dependencies );
        storer.store( mega_source_files );
        storer.store( cpp_source_files );
    }
    void Components_Component::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Components_Component" },
                { "filetype" , "Components" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "type", type } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "name", name } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "file_path", file_path } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "src_dir", src_dir } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "build_dir", build_dir } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_flags", cpp_flags } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_defines", cpp_defines } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "include_directories", include_directories } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dependencies", dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "mega_source_files", mega_source_files } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_source_files", cpp_source_files } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace AST
{
    // struct Parser_Identifier : public mega::io::Object
    Parser_Identifier::Parser_Identifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Identifier >( loader, this ) )    {
    }
    Parser_Identifier::Parser_Identifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Identifier >( loader, this ) )          , str( str )
    {
    }
    bool Parser_Identifier::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Identifier > >{ data::Ptr< data::AST::Parser_Identifier >( loader, const_cast< Parser_Identifier* >( this ) ) };
    }
    void Parser_Identifier::set_inheritance_pointer()
    {
    }
    void Parser_Identifier::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_Identifier::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_Identifier::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Identifier" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ScopedIdentifier : public mega::io::Object
    Parser_ScopedIdentifier::Parser_ScopedIdentifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ScopedIdentifier >( loader, this ) )    {
    }
    Parser_ScopedIdentifier::Parser_ScopedIdentifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_Identifier > >& ids, const std::string& source_file, const mega::U64& line_number)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ScopedIdentifier >( loader, this ) )          , ids( ids )
          , source_file( source_file )
          , line_number( line_number )
    {
    }
    bool Parser_ScopedIdentifier::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >{ data::Ptr< data::AST::Parser_ScopedIdentifier >( loader, const_cast< Parser_ScopedIdentifier* >( this ) ) };
    }
    void Parser_ScopedIdentifier::set_inheritance_pointer()
    {
    }
    void Parser_ScopedIdentifier::load( mega::io::Loader& loader )
    {
        loader.load( ids );
        loader.load( source_file );
        loader.load( line_number );
    }
    void Parser_ScopedIdentifier::store( mega::io::Storer& storer ) const
    {
        storer.store( ids );
        storer.store( source_file );
        storer.store( line_number );
    }
    void Parser_ScopedIdentifier::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ScopedIdentifier" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "ids", ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "line_number", line_number } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ArgumentList : public mega::io::Object
    Parser_ArgumentList::Parser_ArgumentList( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ArgumentList >( loader, this ) )    {
    }
    Parser_ArgumentList::Parser_ArgumentList( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ArgumentList >( loader, this ) )          , str( str )
    {
    }
    bool Parser_ArgumentList::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >{ data::Ptr< data::AST::Parser_ArgumentList >( loader, const_cast< Parser_ArgumentList* >( this ) ) };
    }
    void Parser_ArgumentList::set_inheritance_pointer()
    {
    }
    void Parser_ArgumentList::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_ArgumentList::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_ArgumentList::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ArgumentList" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ReturnType : public mega::io::Object
    Parser_ReturnType::Parser_ReturnType( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ReturnType >( loader, this ) )    {
    }
    Parser_ReturnType::Parser_ReturnType( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ReturnType >( loader, this ) )          , str( str )
    {
    }
    bool Parser_ReturnType::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >{ data::Ptr< data::AST::Parser_ReturnType >( loader, const_cast< Parser_ReturnType* >( this ) ) };
    }
    void Parser_ReturnType::set_inheritance_pointer()
    {
    }
    void Parser_ReturnType::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_ReturnType::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_ReturnType::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ReturnType" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Inheritance : public mega::io::Object
    Parser_Inheritance::Parser_Inheritance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Inheritance >( loader, this ) )    {
    }
    Parser_Inheritance::Parser_Inheritance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< std::string >& strings)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Inheritance >( loader, this ) )          , strings( strings )
    {
    }
    bool Parser_Inheritance::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >{ data::Ptr< data::AST::Parser_Inheritance >( loader, const_cast< Parser_Inheritance* >( this ) ) };
    }
    void Parser_Inheritance::set_inheritance_pointer()
    {
    }
    void Parser_Inheritance::load( mega::io::Loader& loader )
    {
        loader.load( strings );
    }
    void Parser_Inheritance::store( mega::io::Storer& storer ) const
    {
        storer.store( strings );
    }
    void Parser_Inheritance::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Inheritance" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "strings", strings } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Size : public mega::io::Object
    Parser_Size::Parser_Size( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Size >( loader, this ) )    {
    }
    Parser_Size::Parser_Size( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Size >( loader, this ) )          , str( str )
    {
    }
    bool Parser_Size::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >{ data::Ptr< data::AST::Parser_Size >( loader, const_cast< Parser_Size* >( this ) ) };
    }
    void Parser_Size::set_inheritance_pointer()
    {
    }
    void Parser_Size::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_Size::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_Size::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Size" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_LinkInterface : public mega::io::Object
    Parser_LinkInterface::Parser_LinkInterface( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterface >( loader, this ) )    {
    }
    Parser_LinkInterface::Parser_LinkInterface( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::CardinalityRange& cardinality, const mega::DerivationDirection& derivation, const mega::Ownership& ownership)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterface >( loader, this ) )          , cardinality( cardinality )
          , derivation( derivation )
          , ownership( ownership )
    {
    }
    bool Parser_LinkInterface::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >{ data::Ptr< data::AST::Parser_LinkInterface >( loader, const_cast< Parser_LinkInterface* >( this ) ) };
    }
    void Parser_LinkInterface::set_inheritance_pointer()
    {
    }
    void Parser_LinkInterface::load( mega::io::Loader& loader )
    {
        loader.load( cardinality );
        loader.load( derivation );
        loader.load( ownership );
    }
    void Parser_LinkInterface::store( mega::io::Storer& storer ) const
    {
        storer.store( cardinality );
        storer.store( derivation );
        storer.store( ownership );
    }
    void Parser_LinkInterface::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_LinkInterface" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "cardinality", cardinality } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "derivation", derivation } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "ownership", ownership } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Dimension : public mega::io::Object
    Parser_Dimension::Parser_Dimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dimension >( loader, this ) )          , id( loader )
    {
    }
    Parser_Dimension::Parser_Dimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const bool& isConst, const data::Ptr< data::AST::Parser_Identifier >& id, const std::string& type)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dimension >( loader, this ) )          , isConst( isConst )
          , id( id )
          , type( type )
    {
    }
    bool Parser_Dimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >{ data::Ptr< data::AST::Parser_Dimension >( loader, const_cast< Parser_Dimension* >( this ) ) };
    }
    void Parser_Dimension::set_inheritance_pointer()
    {
    }
    void Parser_Dimension::load( mega::io::Loader& loader )
    {
        loader.load( isConst );
        loader.load( id );
        loader.load( type );
    }
    void Parser_Dimension::store( mega::io::Storer& storer ) const
    {
        storer.store( isConst );
        storer.store( id );
        storer.store( type );
    }
    void Parser_Dimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Dimension" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "isConst", isConst } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type", type } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Include : public mega::io::Object
    Parser_Include::Parser_Include( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Include >( loader, this ) )    {
    }
    bool Parser_Include::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_Include >( loader, const_cast< Parser_Include* >( this ) ) };
    }
    void Parser_Include::set_inheritance_pointer()
    {
    }
    void Parser_Include::load( mega::io::Loader& loader )
    {
    }
    void Parser_Include::store( mega::io::Storer& storer ) const
    {
    }
    void Parser_Include::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Include" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_SystemInclude : public mega::io::Object
    Parser_SystemInclude::Parser_SystemInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SystemInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
    {
    }
    Parser_SystemInclude::Parser_SystemInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SystemInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , str( str )
    {
    }
    bool Parser_SystemInclude::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_SystemInclude >( loader, const_cast< Parser_SystemInclude* >( this ) ) };
    }
    void Parser_SystemInclude::set_inheritance_pointer()
    {
        p_AST_Parser_Include->m_inheritance = data::Ptr< data::AST::Parser_SystemInclude >( p_AST_Parser_Include, this );
    }
    void Parser_SystemInclude::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Include );
        loader.load( str );
    }
    void Parser_SystemInclude::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Include );
        storer.store( str );
    }
    void Parser_SystemInclude::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_SystemInclude" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_MegaInclude : public mega::io::Object
    Parser_MegaInclude::Parser_MegaInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , root( loader )
    {
    }
    Parser_MegaInclude::Parser_MegaInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& megaSourceFilePath)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , megaSourceFilePath( megaSourceFilePath )
    {
    }
    bool Parser_MegaInclude::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_MegaInclude >( loader, const_cast< Parser_MegaInclude* >( this ) ) };
    }
    void Parser_MegaInclude::set_inheritance_pointer()
    {
        p_AST_Parser_Include->m_inheritance = data::Ptr< data::AST::Parser_MegaInclude >( p_AST_Parser_Include, this );
    }
    void Parser_MegaInclude::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Include );
        loader.load( megaSourceFilePath );
        loader.load( root );
    }
    void Parser_MegaInclude::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Include );
        storer.store( megaSourceFilePath );
        VERIFY_RTE_MSG( root.has_value(), "AST::Parser_MegaInclude.root has NOT been set" );
        storer.store( root );
    }
    void Parser_MegaInclude::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MegaInclude" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "megaSourceFilePath", megaSourceFilePath } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "root", root.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_MegaIncludeInline : public mega::io::Object
    Parser_MegaIncludeInline::Parser_MegaIncludeInline( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaIncludeInline >( loader, this ) )          , p_AST_Parser_MegaInclude( loader )
    {
    }
    bool Parser_MegaIncludeInline::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_MegaIncludeInline >( loader, const_cast< Parser_MegaIncludeInline* >( this ) ) };
    }
    void Parser_MegaIncludeInline::set_inheritance_pointer()
    {
        p_AST_Parser_MegaInclude->m_inheritance = data::Ptr< data::AST::Parser_MegaIncludeInline >( p_AST_Parser_MegaInclude, this );
    }
    void Parser_MegaIncludeInline::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_MegaInclude );
    }
    void Parser_MegaIncludeInline::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_MegaInclude );
    }
    void Parser_MegaIncludeInline::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MegaIncludeInline" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_MegaIncludeNested : public mega::io::Object
    Parser_MegaIncludeNested::Parser_MegaIncludeNested( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaIncludeNested >( loader, this ) )          , p_AST_Parser_MegaInclude( loader )
          , id( loader )
    {
    }
    Parser_MegaIncludeNested::Parser_MegaIncludeNested( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ScopedIdentifier >& id)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaIncludeNested >( loader, this ) )          , p_AST_Parser_MegaInclude( loader )
          , id( id )
    {
    }
    bool Parser_MegaIncludeNested::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_MegaIncludeNested >( loader, const_cast< Parser_MegaIncludeNested* >( this ) ) };
    }
    void Parser_MegaIncludeNested::set_inheritance_pointer()
    {
        p_AST_Parser_MegaInclude->m_inheritance = data::Ptr< data::AST::Parser_MegaIncludeNested >( p_AST_Parser_MegaInclude, this );
    }
    void Parser_MegaIncludeNested::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_MegaInclude );
        loader.load( id );
    }
    void Parser_MegaIncludeNested::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_MegaInclude );
        storer.store( id );
    }
    void Parser_MegaIncludeNested::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MegaIncludeNested" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_CPPInclude : public mega::io::Object
    Parser_CPPInclude::Parser_CPPInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_CPPInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
    {
    }
    Parser_CPPInclude::Parser_CPPInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& cppSourceFilePath)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_CPPInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , cppSourceFilePath( cppSourceFilePath )
    {
    }
    bool Parser_CPPInclude::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_CPPInclude >( loader, const_cast< Parser_CPPInclude* >( this ) ) };
    }
    void Parser_CPPInclude::set_inheritance_pointer()
    {
        p_AST_Parser_Include->m_inheritance = data::Ptr< data::AST::Parser_CPPInclude >( p_AST_Parser_Include, this );
    }
    void Parser_CPPInclude::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Include );
        loader.load( cppSourceFilePath );
    }
    void Parser_CPPInclude::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Include );
        storer.store( cppSourceFilePath );
    }
    void Parser_CPPInclude::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_CPPInclude" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "cppSourceFilePath", cppSourceFilePath } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Dependency : public mega::io::Object
    Parser_Dependency::Parser_Dependency( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dependency >( loader, this ) )    {
    }
    Parser_Dependency::Parser_Dependency( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dependency >( loader, this ) )          , str( str )
    {
    }
    bool Parser_Dependency::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Dependency > >{ data::Ptr< data::AST::Parser_Dependency >( loader, const_cast< Parser_Dependency* >( this ) ) };
    }
    void Parser_Dependency::set_inheritance_pointer()
    {
    }
    void Parser_Dependency::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_Dependency::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_Dependency::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Dependency" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ContextDef : public mega::io::Object
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ContextDef >( loader, this ) )          , p_Body_Parser_ContextDef( loader )
          , id( loader )
    {
    }
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ScopedIdentifier >& id, const std::vector< data::Ptr< data::AST::Parser_ContextDef > >& children, const std::vector< data::Ptr< data::AST::Parser_Dimension > >& dimensions, const std::vector< data::Ptr< data::AST::Parser_Include > >& includes, const std::vector< data::Ptr< data::AST::Parser_Dependency > >& dependencies)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ContextDef >( loader, this ) )          , p_Body_Parser_ContextDef( loader )
          , id( id )
          , children( children )
          , dimensions( dimensions )
          , includes( includes )
          , dependencies( dependencies )
    {
    }
    bool Parser_ContextDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_ContextDef >( loader, const_cast< Parser_ContextDef* >( this ) ) };
    }
    void Parser_ContextDef::set_inheritance_pointer()
    {
    }
    void Parser_ContextDef::load( mega::io::Loader& loader )
    {
        loader.load( p_Body_Parser_ContextDef );
        loader.load( id );
        loader.load( children );
        loader.load( dimensions );
        loader.load( includes );
        loader.load( dependencies );
    }
    void Parser_ContextDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Body_Parser_ContextDef );
        storer.store( id );
        storer.store( children );
        storer.store( dimensions );
        storer.store( includes );
        storer.store( dependencies );
    }
    void Parser_ContextDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ContextDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "includes", includes } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dependencies", dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_NamespaceDef : public mega::io::Object
    Parser_NamespaceDef::Parser_NamespaceDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_NamespaceDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
    {
    }
    bool Parser_NamespaceDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_NamespaceDef >( loader, const_cast< Parser_NamespaceDef* >( this ) ) };
    }
    void Parser_NamespaceDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_NamespaceDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_NamespaceDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
    }
    void Parser_NamespaceDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
    }
    void Parser_NamespaceDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_NamespaceDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_AbstractDef : public mega::io::Object
    Parser_AbstractDef::Parser_AbstractDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_AbstractDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( loader )
    {
    }
    Parser_AbstractDef::Parser_AbstractDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_AbstractDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( inheritance )
    {
    }
    bool Parser_AbstractDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_AbstractDef >( loader, const_cast< Parser_AbstractDef* >( this ) ) };
    }
    void Parser_AbstractDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_AbstractDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_AbstractDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( inheritance );
    }
    void Parser_AbstractDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( inheritance );
    }
    void Parser_AbstractDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_AbstractDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ActionDef : public mega::io::Object
    Parser_ActionDef::Parser_ActionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ActionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( loader )
          , inheritance( loader )
    {
    }
    Parser_ActionDef::Parser_ActionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Size >& size, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ActionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( size )
          , inheritance( inheritance )
    {
    }
    bool Parser_ActionDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_ActionDef >( loader, const_cast< Parser_ActionDef* >( this ) ) };
    }
    void Parser_ActionDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_ActionDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_ActionDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( size );
        loader.load( inheritance );
    }
    void Parser_ActionDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( size );
        storer.store( inheritance );
    }
    void Parser_ActionDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ActionDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_EventDef : public mega::io::Object
    Parser_EventDef::Parser_EventDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_EventDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( loader )
          , inheritance( loader )
    {
    }
    Parser_EventDef::Parser_EventDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Size >& size, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_EventDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( size )
          , inheritance( inheritance )
    {
    }
    bool Parser_EventDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_EventDef >( loader, const_cast< Parser_EventDef* >( this ) ) };
    }
    void Parser_EventDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_EventDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_EventDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( size );
        loader.load( inheritance );
    }
    void Parser_EventDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( size );
        storer.store( inheritance );
    }
    void Parser_EventDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_EventDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_FunctionDef : public mega::io::Object
    Parser_FunctionDef::Parser_FunctionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_FunctionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , argumentList( loader )
          , returnType( loader )
    {
    }
    Parser_FunctionDef::Parser_FunctionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ArgumentList >& argumentList, const data::Ptr< data::AST::Parser_ReturnType >& returnType)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_FunctionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , argumentList( argumentList )
          , returnType( returnType )
    {
    }
    bool Parser_FunctionDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_FunctionDef >( loader, const_cast< Parser_FunctionDef* >( this ) ) };
    }
    void Parser_FunctionDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_FunctionDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_FunctionDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( argumentList );
        loader.load( returnType );
    }
    void Parser_FunctionDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( argumentList );
        storer.store( returnType );
    }
    void Parser_FunctionDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_FunctionDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "argumentList", argumentList } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "returnType", returnType } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ObjectDef : public mega::io::Object
    Parser_ObjectDef::Parser_ObjectDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ObjectDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( loader )
    {
    }
    Parser_ObjectDef::Parser_ObjectDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ObjectDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( inheritance )
    {
    }
    bool Parser_ObjectDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_ObjectDef >( loader, const_cast< Parser_ObjectDef* >( this ) ) };
    }
    void Parser_ObjectDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_ObjectDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_ObjectDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( inheritance );
    }
    void Parser_ObjectDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( inheritance );
    }
    void Parser_ObjectDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ObjectDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_LinkDef : public mega::io::Object
    Parser_LinkDef::Parser_LinkDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , target( loader )
    {
    }
    Parser_LinkDef::Parser_LinkDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Inheritance >& target)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , target( target )
    {
    }
    bool Parser_LinkDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_LinkDef >( loader, const_cast< Parser_LinkDef* >( this ) ) };
    }
    void Parser_LinkDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_LinkDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_LinkDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( target );
    }
    void Parser_LinkDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( target );
    }
    void Parser_LinkDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_LinkDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "target", target } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_LinkInterfaceDef : public mega::io::Object
    Parser_LinkInterfaceDef::Parser_LinkInterfaceDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterfaceDef >( loader, this ) )          , p_AST_Parser_LinkDef( loader )
          , link_interface( loader )
    {
    }
    Parser_LinkInterfaceDef::Parser_LinkInterfaceDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_LinkInterface >& link_interface)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterfaceDef >( loader, this ) )          , p_AST_Parser_LinkDef( loader )
          , link_interface( link_interface )
    {
    }
    bool Parser_LinkInterfaceDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_LinkInterfaceDef >( loader, const_cast< Parser_LinkInterfaceDef* >( this ) ) };
    }
    void Parser_LinkInterfaceDef::set_inheritance_pointer()
    {
        p_AST_Parser_LinkDef->m_inheritance = data::Ptr< data::AST::Parser_LinkInterfaceDef >( p_AST_Parser_LinkDef, this );
    }
    void Parser_LinkInterfaceDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_LinkDef );
        loader.load( link_interface );
    }
    void Parser_LinkInterfaceDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_LinkDef );
        storer.store( link_interface );
    }
    void Parser_LinkInterfaceDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_LinkInterfaceDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_interface", link_interface } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_BufferDef : public mega::io::Object
    Parser_BufferDef::Parser_BufferDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_BufferDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
    {
    }
    bool Parser_BufferDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_BufferDef >( loader, const_cast< Parser_BufferDef* >( this ) ) };
    }
    void Parser_BufferDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_BufferDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_BufferDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
    }
    void Parser_BufferDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
    }
    void Parser_BufferDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_BufferDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_MetaDef : public mega::io::Object
    Parser_MetaDef::Parser_MetaDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MetaDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
    {
    }
    bool Parser_MetaDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_MetaDef >( loader, const_cast< Parser_MetaDef* >( this ) ) };
    }
    void Parser_MetaDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_MetaDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_MetaDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
    }
    void Parser_MetaDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
    }
    void Parser_MetaDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MetaDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_SourceRoot : public mega::io::Object
    Parser_SourceRoot::Parser_SourceRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SourceRoot >( loader, this ) )          , component( loader )
          , ast( loader )
    {
    }
    Parser_SourceRoot::Parser_SourceRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& sourceFile, const data::Ptr< data::Components::Components_Component >& component, const data::Ptr< data::AST::Parser_ContextDef >& ast)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SourceRoot >( loader, this ) )          , sourceFile( sourceFile )
          , component( component )
          , ast( ast )
    {
    }
    bool Parser_SourceRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >{ data::Ptr< data::AST::Parser_SourceRoot >( loader, const_cast< Parser_SourceRoot* >( this ) ) };
    }
    void Parser_SourceRoot::set_inheritance_pointer()
    {
    }
    void Parser_SourceRoot::load( mega::io::Loader& loader )
    {
        loader.load( sourceFile );
        loader.load( component );
        loader.load( ast );
    }
    void Parser_SourceRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( sourceFile );
        storer.store( component );
        storer.store( ast );
    }
    void Parser_SourceRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_SourceRoot" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "sourceFile", sourceFile } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "component", component } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "ast", ast } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_IncludeRoot : public mega::io::Object
    Parser_IncludeRoot::Parser_IncludeRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_IncludeRoot >( loader, this ) )          , p_AST_Parser_SourceRoot( loader )
    {
    }
    bool Parser_IncludeRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >{ data::Ptr< data::AST::Parser_IncludeRoot >( loader, const_cast< Parser_IncludeRoot* >( this ) ) };
    }
    void Parser_IncludeRoot::set_inheritance_pointer()
    {
        p_AST_Parser_SourceRoot->m_inheritance = data::Ptr< data::AST::Parser_IncludeRoot >( p_AST_Parser_SourceRoot, this );
    }
    void Parser_IncludeRoot::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_SourceRoot );
    }
    void Parser_IncludeRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_SourceRoot );
    }
    void Parser_IncludeRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_IncludeRoot" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_ObjectSourceRoot : public mega::io::Object
    Parser_ObjectSourceRoot::Parser_ObjectSourceRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ObjectSourceRoot >( loader, this ) )          , p_AST_Parser_SourceRoot( loader )
    {
    }
    bool Parser_ObjectSourceRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >{ data::Ptr< data::AST::Parser_ObjectSourceRoot >( loader, const_cast< Parser_ObjectSourceRoot* >( this ) ) };
    }
    void Parser_ObjectSourceRoot::set_inheritance_pointer()
    {
        p_AST_Parser_SourceRoot->m_inheritance = data::Ptr< data::AST::Parser_ObjectSourceRoot >( p_AST_Parser_SourceRoot, this );
    }
    void Parser_ObjectSourceRoot::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_SourceRoot );
    }
    void Parser_ObjectSourceRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_SourceRoot );
    }
    void Parser_ObjectSourceRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ObjectSourceRoot" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
}
namespace Body
{
    // struct Parser_ContextDef : public mega::io::Object
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )    {
    }
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& body)
        :   mega::io::Object( objectInfo )          , body( body )
    {
    }
    bool Parser_ContextDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Parser_ContextDef::set_inheritance_pointer()
    {
    }
    void Parser_ContextDef::load( mega::io::Loader& loader )
    {
        loader.load( body );
    }
    void Parser_ContextDef::store( mega::io::Storer& storer ) const
    {
        storer.store( body );
    }
    void Parser_ContextDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ContextDef" },
                { "filetype" , "Body" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "body", body } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Tree
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_DimensionTrait >( loader, this ) )          , p_AST_Parser_Dimension( loader )
          , p_PerSourceSymbols_Interface_DimensionTrait( loader )
          , p_PerSourceDerivations_Interface_DimensionTrait( loader )
          , p_Clang_Interface_DimensionTrait( loader )
          , parent( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_IContext >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_DimensionTrait >( loader, this ) )          , p_AST_Parser_Dimension( loader )
          , p_PerSourceSymbols_Interface_DimensionTrait( loader )
          , p_PerSourceDerivations_Interface_DimensionTrait( loader )
          , p_Clang_Interface_DimensionTrait( loader )
          , parent( parent )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >{ data::Ptr< data::Tree::Interface_DimensionTrait >( loader, const_cast< Interface_DimensionTrait* >( this ) ) };
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_AST_Parser_Dimension->m_inheritance = data::Ptr< data::Tree::Interface_DimensionTrait >( p_AST_Parser_Dimension, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Dimension );
        loader.load( parent );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Dimension );
        storer.store( parent );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_InheritanceTrait : public mega::io::Object
    Interface_InheritanceTrait::Interface_InheritanceTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_InheritanceTrait >( loader, this ) )          , p_AST_Parser_Inheritance( loader )
          , p_Clang_Interface_InheritanceTrait( loader )
    {
    }
    bool Interface_InheritanceTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >{ data::Ptr< data::Tree::Interface_InheritanceTrait >( loader, const_cast< Interface_InheritanceTrait* >( this ) ) };
    }
    void Interface_InheritanceTrait::set_inheritance_pointer()
    {
        p_AST_Parser_Inheritance->m_inheritance = data::Ptr< data::Tree::Interface_InheritanceTrait >( p_AST_Parser_Inheritance, this );
    }
    void Interface_InheritanceTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Inheritance );
    }
    void Interface_InheritanceTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Inheritance );
    }
    void Interface_InheritanceTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_InheritanceTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_LinkTrait : public mega::io::Object
    Interface_LinkTrait::Interface_LinkTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_LinkTrait >( loader, this ) )          , p_AST_Parser_LinkInterface( loader )
    {
    }
    bool Interface_LinkTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >{ data::Ptr< data::Tree::Interface_LinkTrait >( loader, const_cast< Interface_LinkTrait* >( this ) ) };
    }
    void Interface_LinkTrait::set_inheritance_pointer()
    {
        p_AST_Parser_LinkInterface->m_inheritance = data::Ptr< data::Tree::Interface_LinkTrait >( p_AST_Parser_LinkInterface, this );
    }
    void Interface_LinkTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_LinkInterface );
    }
    void Interface_LinkTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_LinkInterface );
    }
    void Interface_LinkTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_LinkTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_ReturnTypeTrait : public mega::io::Object
    Interface_ReturnTypeTrait::Interface_ReturnTypeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ReturnTypeTrait >( loader, this ) )          , p_AST_Parser_ReturnType( loader )
          , p_Clang_Interface_ReturnTypeTrait( loader )
    {
    }
    bool Interface_ReturnTypeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >{ data::Ptr< data::Tree::Interface_ReturnTypeTrait >( loader, const_cast< Interface_ReturnTypeTrait* >( this ) ) };
    }
    void Interface_ReturnTypeTrait::set_inheritance_pointer()
    {
        p_AST_Parser_ReturnType->m_inheritance = data::Ptr< data::Tree::Interface_ReturnTypeTrait >( p_AST_Parser_ReturnType, this );
    }
    void Interface_ReturnTypeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ReturnType );
    }
    void Interface_ReturnTypeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ReturnType );
    }
    void Interface_ReturnTypeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ReturnTypeTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_ArgumentListTrait : public mega::io::Object
    Interface_ArgumentListTrait::Interface_ArgumentListTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ArgumentListTrait >( loader, this ) )          , p_AST_Parser_ArgumentList( loader )
          , p_Clang_Interface_ArgumentListTrait( loader )
    {
    }
    bool Interface_ArgumentListTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >{ data::Ptr< data::Tree::Interface_ArgumentListTrait >( loader, const_cast< Interface_ArgumentListTrait* >( this ) ) };
    }
    void Interface_ArgumentListTrait::set_inheritance_pointer()
    {
        p_AST_Parser_ArgumentList->m_inheritance = data::Ptr< data::Tree::Interface_ArgumentListTrait >( p_AST_Parser_ArgumentList, this );
    }
    void Interface_ArgumentListTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ArgumentList );
    }
    void Interface_ArgumentListTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ArgumentList );
    }
    void Interface_ArgumentListTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ArgumentListTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_SizeTrait : public mega::io::Object
    Interface_SizeTrait::Interface_SizeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_SizeTrait >( loader, this ) )          , p_AST_Parser_Size( loader )
          , p_Clang_Interface_SizeTrait( loader )
    {
    }
    bool Interface_SizeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >{ data::Ptr< data::Tree::Interface_SizeTrait >( loader, const_cast< Interface_SizeTrait* >( this ) ) };
    }
    void Interface_SizeTrait::set_inheritance_pointer()
    {
        p_AST_Parser_Size->m_inheritance = data::Ptr< data::Tree::Interface_SizeTrait >( p_AST_Parser_Size, this );
    }
    void Interface_SizeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Size );
    }
    void Interface_SizeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Size );
    }
    void Interface_SizeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_SizeTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_ContextGroup : public mega::io::Object
    Interface_ContextGroup::Interface_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ContextGroup >( loader, this ) )    {
    }
    Interface_ContextGroup::Interface_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ContextGroup >( loader, this ) )          , children( children )
    {
    }
    bool Interface_ContextGroup::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_ContextGroup >( loader, const_cast< Interface_ContextGroup* >( this ) ) };
    }
    void Interface_ContextGroup::set_inheritance_pointer()
    {
    }
    void Interface_ContextGroup::load( mega::io::Loader& loader )
    {
        loader.load( children );
    }
    void Interface_ContextGroup::store( mega::io::Storer& storer ) const
    {
        storer.store( children );
    }
    void Interface_ContextGroup::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ContextGroup" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Root : public mega::io::Object
    Interface_Root::Interface_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Root >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , root( loader )
    {
    }
    Interface_Root::Interface_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ObjectSourceRoot >& root)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Root >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , root( root )
    {
    }
    bool Interface_Root::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Root >( loader, const_cast< Interface_Root* >( this ) ) };
    }
    void Interface_Root::set_inheritance_pointer()
    {
        p_Tree_Interface_ContextGroup->m_inheritance = data::Ptr< data::Tree::Interface_Root >( p_Tree_Interface_ContextGroup, this );
    }
    void Interface_Root::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ContextGroup );
        loader.load( root );
    }
    void Interface_Root::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ContextGroup );
        storer.store( root );
    }
    void Interface_Root::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Root" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "root", root } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_IContext : public mega::io::Object
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_IContext >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , p_PerSourceSymbols_Interface_IContext( loader )
          , p_PerSourceDerivations_Interface_IContext( loader )
          , parent( loader )
          , component( loader )
    {
    }
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& identifier, const data::Ptr< data::Tree::Interface_ContextGroup >& parent, const data::Ptr< data::Components::Components_Component >& component)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_IContext >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , p_PerSourceSymbols_Interface_IContext( loader )
          , p_PerSourceDerivations_Interface_IContext( loader )
          , identifier( identifier )
          , parent( parent )
          , component( component )
    {
    }
    bool Interface_IContext::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_IContext >( loader, const_cast< Interface_IContext* >( this ) ) };
    }
    void Interface_IContext::set_inheritance_pointer()
    {
        p_Tree_Interface_ContextGroup->m_inheritance = data::Ptr< data::Tree::Interface_IContext >( p_Tree_Interface_ContextGroup, this );
    }
    void Interface_IContext::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ContextGroup );
        loader.load( identifier );
        loader.load( parent );
        loader.load( component );
    }
    void Interface_IContext::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ContextGroup );
        storer.store( identifier );
        storer.store( parent );
        storer.store( component );
    }
    void Interface_IContext::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_IContext" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "identifier", identifier } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "component", component } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Namespace : public mega::io::Object
    Interface_Namespace::Interface_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Namespace >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Namespace::Interface_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const bool& is_global, const std::vector< data::Ptr< data::AST::Parser_ContextDef > >& namespace_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Namespace >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , is_global( is_global )
          , namespace_defs( namespace_defs )
    {
    }
    bool Interface_Namespace::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Namespace >( loader, const_cast< Interface_Namespace* >( this ) ) };
    }
    void Interface_Namespace::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Namespace >( p_Tree_Interface_IContext, this );
    }
    void Interface_Namespace::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( is_global );
        loader.load( namespace_defs );
        loader.load( dimension_traits );
    }
    void Interface_Namespace::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( is_global );
        storer.store( namespace_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Namespace.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
    }
    void Interface_Namespace::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Namespace" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_global", is_global } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "namespace_defs", namespace_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Abstract : public mega::io::Object
    Interface_Abstract::Interface_Abstract( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Abstract >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Abstract::Interface_Abstract( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& abstract_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Abstract >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , abstract_defs( abstract_defs )
    {
    }
    bool Interface_Abstract::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Abstract >( loader, const_cast< Interface_Abstract* >( this ) ) };
    }
    void Interface_Abstract::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Abstract >( p_Tree_Interface_IContext, this );
    }
    void Interface_Abstract::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( abstract_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
    }
    void Interface_Abstract::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( abstract_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Abstract.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Abstract.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
    }
    void Interface_Abstract::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Abstract" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "abstract_defs", abstract_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Action : public mega::io::Object
    Interface_Action::Interface_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Action >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Action::Interface_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_ActionDef > >& action_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Action >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , action_defs( action_defs )
    {
    }
    bool Interface_Action::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Action >( loader, const_cast< Interface_Action* >( this ) ) };
    }
    void Interface_Action::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Action >( p_Tree_Interface_IContext, this );
    }
    void Interface_Action::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( action_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
        loader.load( size_trait );
    }
    void Interface_Action::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( action_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Action.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Action.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
        VERIFY_RTE_MSG( size_trait.has_value(), "Tree::Interface_Action.size_trait has NOT been set" );
        storer.store( size_trait );
    }
    void Interface_Action::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Action" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "action_defs", action_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size_trait", size_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Event : public mega::io::Object
    Interface_Event::Interface_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Event >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Event::Interface_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_EventDef > >& event_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Event >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , event_defs( event_defs )
    {
    }
    bool Interface_Event::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Event >( loader, const_cast< Interface_Event* >( this ) ) };
    }
    void Interface_Event::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Event >( p_Tree_Interface_IContext, this );
    }
    void Interface_Event::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( event_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
        loader.load( size_trait );
    }
    void Interface_Event::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( event_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Event.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Event.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
        VERIFY_RTE_MSG( size_trait.has_value(), "Tree::Interface_Event.size_trait has NOT been set" );
        storer.store( size_trait );
    }
    void Interface_Event::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Event" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "event_defs", event_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size_trait", size_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Function : public mega::io::Object
    Interface_Function::Interface_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Function >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , return_type_trait( loader )
          , arguments_trait( loader )
    {
    }
    Interface_Function::Interface_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& function_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Function >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , function_defs( function_defs )
    {
    }
    bool Interface_Function::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Function >( loader, const_cast< Interface_Function* >( this ) ) };
    }
    void Interface_Function::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Function >( p_Tree_Interface_IContext, this );
    }
    void Interface_Function::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( function_defs );
        loader.load( return_type_trait );
        loader.load( arguments_trait );
    }
    void Interface_Function::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( function_defs );
        VERIFY_RTE_MSG( return_type_trait.has_value(), "Tree::Interface_Function.return_type_trait has NOT been set" );
        storer.store( return_type_trait );
        VERIFY_RTE_MSG( arguments_trait.has_value(), "Tree::Interface_Function.arguments_trait has NOT been set" );
        storer.store( arguments_trait );
    }
    void Interface_Function::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Function" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "function_defs", function_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_type_trait", return_type_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "arguments_trait", arguments_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Object : public mega::io::Object
    Interface_Object::Interface_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Object >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Object::Interface_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& object_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Object >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , object_defs( object_defs )
    {
    }
    bool Interface_Object::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Object >( loader, const_cast< Interface_Object* >( this ) ) };
    }
    void Interface_Object::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Object >( p_Tree_Interface_IContext, this );
    }
    void Interface_Object::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( object_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
    }
    void Interface_Object::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( object_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Object.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Object.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
    }
    void Interface_Object::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Object" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "object_defs", object_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Link : public mega::io::Object
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Link >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , p_PerSourceModel_Interface_Link( loader )
          , link_target( loader )
    {
    }
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_LinkDef > >& link_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Link >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , p_PerSourceModel_Interface_Link( loader )
          , link_defs( link_defs )
    {
    }
    bool Interface_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Link >( loader, const_cast< Interface_Link* >( this ) ) };
    }
    void Interface_Link::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Link >( p_Tree_Interface_IContext, this );
    }
    void Interface_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( link_defs );
        loader.load( link_target );
    }
    void Interface_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( link_defs );
        VERIFY_RTE_MSG( link_target.has_value(), "Tree::Interface_Link.link_target has NOT been set" );
        storer.store( link_target );
    }
    void Interface_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Link" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_defs", link_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_target", link_target.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_LinkInterface : public mega::io::Object
    Interface_LinkInterface::Interface_LinkInterface( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_LinkInterface >( loader, this ) )          , p_Tree_Interface_Link( loader )
          , link_trait( loader )
    {
    }
    bool Interface_LinkInterface::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_LinkInterface >( loader, const_cast< Interface_LinkInterface* >( this ) ) };
    }
    void Interface_LinkInterface::set_inheritance_pointer()
    {
        p_Tree_Interface_Link->m_inheritance = data::Ptr< data::Tree::Interface_LinkInterface >( p_Tree_Interface_Link, this );
    }
    void Interface_LinkInterface::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_Link );
        loader.load( link_trait );
    }
    void Interface_LinkInterface::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_Link );
        VERIFY_RTE_MSG( link_trait.has_value(), "Tree::Interface_LinkInterface.link_trait has NOT been set" );
        storer.store( link_trait );
    }
    void Interface_LinkInterface::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_LinkInterface" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_trait", link_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Buffer : public mega::io::Object
    Interface_Buffer::Interface_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Buffer >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Buffer::Interface_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_BufferDef > >& buffer_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Buffer >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , buffer_defs( buffer_defs )
    {
    }
    bool Interface_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Buffer >( loader, const_cast< Interface_Buffer* >( this ) ) };
    }
    void Interface_Buffer::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Buffer >( p_Tree_Interface_IContext, this );
    }
    void Interface_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( buffer_defs );
        loader.load( dimension_traits );
    }
    void Interface_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( buffer_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Buffer.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
    }
    void Interface_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Buffer" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "buffer_defs", buffer_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace DPGraph
{
    // struct Dependencies_Glob : public mega::io::Object
    Dependencies_Glob::Dependencies_Glob( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Glob >( loader, this ) )    {
    }
    Dependencies_Glob::Dependencies_Glob( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& location, const std::string& glob)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Glob >( loader, this ) )          , location( location )
          , glob( glob )
    {
    }
    bool Dependencies_Glob::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >{ data::Ptr< data::DPGraph::Dependencies_Glob >( loader, const_cast< Dependencies_Glob* >( this ) ) };
    }
    void Dependencies_Glob::set_inheritance_pointer()
    {
    }
    void Dependencies_Glob::load( mega::io::Loader& loader )
    {
        loader.load( location );
        loader.load( glob );
    }
    void Dependencies_Glob::store( mega::io::Storer& storer ) const
    {
        storer.store( location );
        storer.store( glob );
    }
    void Dependencies_Glob::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_Glob" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "location", location } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "glob", glob } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Dependencies_SourceFileDependencies : public mega::io::Object
    Dependencies_SourceFileDependencies::Dependencies_SourceFileDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >( loader, this ) )    {
    }
    Dependencies_SourceFileDependencies::Dependencies_SourceFileDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::io::megaFilePath& source_file, const mega::U64& hash_code, const std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& globs, const std::vector< boost::filesystem::path >& resolution)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >( loader, this ) )          , source_file( source_file )
          , hash_code( hash_code )
          , globs( globs )
          , resolution( resolution )
    {
    }
    bool Dependencies_SourceFileDependencies::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >{ data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >( loader, const_cast< Dependencies_SourceFileDependencies* >( this ) ) };
    }
    void Dependencies_SourceFileDependencies::set_inheritance_pointer()
    {
    }
    void Dependencies_SourceFileDependencies::load( mega::io::Loader& loader )
    {
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( globs );
        loader.load( resolution );
    }
    void Dependencies_SourceFileDependencies::store( mega::io::Storer& storer ) const
    {
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( globs );
        storer.store( resolution );
    }
    void Dependencies_SourceFileDependencies::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_SourceFileDependencies" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "globs", globs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "resolution", resolution } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Dependencies_TransitiveDependencies : public mega::io::Object
    Dependencies_TransitiveDependencies::Dependencies_TransitiveDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >( loader, this ) )    {
    }
    Dependencies_TransitiveDependencies::Dependencies_TransitiveDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< mega::io::megaFilePath >& mega_source_files)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >( loader, this ) )          , mega_source_files( mega_source_files )
    {
    }
    bool Dependencies_TransitiveDependencies::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >{ data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >( loader, const_cast< Dependencies_TransitiveDependencies* >( this ) ) };
    }
    void Dependencies_TransitiveDependencies::set_inheritance_pointer()
    {
    }
    void Dependencies_TransitiveDependencies::load( mega::io::Loader& loader )
    {
        loader.load( mega_source_files );
    }
    void Dependencies_TransitiveDependencies::store( mega::io::Storer& storer ) const
    {
        storer.store( mega_source_files );
    }
    void Dependencies_TransitiveDependencies::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_TransitiveDependencies" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "mega_source_files", mega_source_files } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Dependencies_Analysis : public mega::io::Object
    Dependencies_Analysis::Dependencies_Analysis( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Analysis >( loader, this ) )    {
    }
    Dependencies_Analysis::Dependencies_Analysis( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& objects, const std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& mega_dependencies, const std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& cpp_dependencies)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Analysis >( loader, this ) )          , objects( objects )
          , mega_dependencies( mega_dependencies )
          , cpp_dependencies( cpp_dependencies )
    {
    }
    bool Dependencies_Analysis::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >{ data::Ptr< data::DPGraph::Dependencies_Analysis >( loader, const_cast< Dependencies_Analysis* >( this ) ) };
    }
    void Dependencies_Analysis::set_inheritance_pointer()
    {
    }
    void Dependencies_Analysis::load( mega::io::Loader& loader )
    {
        loader.load( objects );
        loader.load( mega_dependencies );
        loader.load( cpp_dependencies );
    }
    void Dependencies_Analysis::store( mega::io::Storer& storer ) const
    {
        storer.store( objects );
        storer.store( mega_dependencies );
        storer.store( cpp_dependencies );
    }
    void Dependencies_Analysis::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_Analysis" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "objects", objects } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "mega_dependencies", mega_dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_dependencies", cpp_dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace SymbolTable
{
    // struct Symbols_SymbolTypeID : public mega::io::Object
    Symbols_SymbolTypeID::Symbols_SymbolTypeID( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >( loader, this ) )    {
    }
    Symbols_SymbolTypeID::Symbols_SymbolTypeID( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& symbol, const mega::TypeID& id, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& contexts, const std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >( loader, this ) )          , symbol( symbol )
          , id( id )
          , contexts( contexts )
          , dimensions( dimensions )
    {
    }
    bool Symbols_SymbolTypeID::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >{ data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >( loader, const_cast< Symbols_SymbolTypeID* >( this ) ) };
    }
    void Symbols_SymbolTypeID::set_inheritance_pointer()
    {
    }
    void Symbols_SymbolTypeID::load( mega::io::Loader& loader )
    {
        loader.load( symbol );
        loader.load( id );
        loader.load( contexts );
        loader.load( dimensions );
    }
    void Symbols_SymbolTypeID::store( mega::io::Storer& storer ) const
    {
        storer.store( symbol );
        storer.store( id );
        storer.store( contexts );
        storer.store( dimensions );
    }
    void Symbols_SymbolTypeID::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolTypeID" },
                { "filetype" , "SymbolTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol", symbol } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "contexts", contexts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_InterfaceTypeID : public mega::io::Object
    Symbols_InterfaceTypeID::Symbols_InterfaceTypeID( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >( loader, this ) )    {
    }
    Symbols_InterfaceTypeID::Symbols_InterfaceTypeID( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::TypeIDSequence& symbol_ids, const mega::TypeID& id, const std::optional< data::Ptr< data::Tree::Interface_IContext > >& context, const std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >( loader, this ) )          , symbol_ids( symbol_ids )
          , id( id )
          , context( context )
          , dimension( dimension )
    {
    }
    bool Symbols_InterfaceTypeID::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >{ data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >( loader, const_cast< Symbols_InterfaceTypeID* >( this ) ) };
    }
    void Symbols_InterfaceTypeID::set_inheritance_pointer()
    {
    }
    void Symbols_InterfaceTypeID::load( mega::io::Loader& loader )
    {
        loader.load( symbol_ids );
        loader.load( id );
        loader.load( context );
        loader.load( dimension );
    }
    void Symbols_InterfaceTypeID::store( mega::io::Storer& storer ) const
    {
        storer.store( symbol_ids );
        storer.store( id );
        storer.store( context );
        storer.store( dimension );
    }
    void Symbols_InterfaceTypeID::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_InterfaceTypeID" },
                { "filetype" , "SymbolTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_ids", symbol_ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_SymbolTable : public mega::io::Object
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolTable >( loader, this ) )          , p_ConcreteTable_Symbols_SymbolTable( loader )
    {
    }
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& symbol_names, const std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& symbol_type_ids, const std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& interface_type_id_sequences, const std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& interface_type_ids)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolTable >( loader, this ) )          , p_ConcreteTable_Symbols_SymbolTable( loader )
          , symbol_names( symbol_names )
          , symbol_type_ids( symbol_type_ids )
          , interface_type_id_sequences( interface_type_id_sequences )
          , interface_type_ids( interface_type_ids )
    {
    }
    bool Symbols_SymbolTable::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >{ data::Ptr< data::SymbolTable::Symbols_SymbolTable >( loader, const_cast< Symbols_SymbolTable* >( this ) ) };
    }
    void Symbols_SymbolTable::set_inheritance_pointer()
    {
    }
    void Symbols_SymbolTable::load( mega::io::Loader& loader )
    {
        loader.load( symbol_names );
        loader.load( symbol_type_ids );
        loader.load( interface_type_id_sequences );
        loader.load( interface_type_ids );
    }
    void Symbols_SymbolTable::store( mega::io::Storer& storer ) const
    {
        storer.store( symbol_names );
        storer.store( symbol_type_ids );
        storer.store( interface_type_id_sequences );
        storer.store( interface_type_ids );
    }
    void Symbols_SymbolTable::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolTable" },
                { "filetype" , "SymbolTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_names", symbol_names } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_type_ids", symbol_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_type_id_sequences", interface_type_id_sequences } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_type_ids", interface_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceSymbols
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_DimensionTrait > p_Tree_Interface_DimensionTrait, const mega::TypeID& symbol_id, const mega::TypeID& interface_id)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( p_Tree_Interface_DimensionTrait )
          , symbol_id( symbol_id )
          , interface_id( interface_id )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_DimensionTrait->p_PerSourceSymbols_Interface_DimensionTrait = data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait >( p_Tree_Interface_DimensionTrait, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_DimensionTrait );
        loader.load( symbol_id );
        loader.load( interface_id );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_DimensionTrait );
        storer.store( symbol_id );
        storer.store( interface_id );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "PerSourceSymbols" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_id", symbol_id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_id", interface_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_IContext : public mega::io::Object
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_IContext > p_Tree_Interface_IContext, const mega::TypeID& symbol_id, const mega::TypeID& interface_id)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( p_Tree_Interface_IContext )
          , symbol_id( symbol_id )
          , interface_id( interface_id )
    {
    }
    bool Interface_IContext::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_IContext::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->p_PerSourceSymbols_Interface_IContext = data::Ptr< data::PerSourceSymbols::Interface_IContext >( p_Tree_Interface_IContext, this );
    }
    void Interface_IContext::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( symbol_id );
        loader.load( interface_id );
    }
    void Interface_IContext::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( symbol_id );
        storer.store( interface_id );
    }
    void Interface_IContext::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_IContext" },
                { "filetype" , "PerSourceSymbols" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_id", symbol_id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_id", interface_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Clang
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_DimensionTrait > p_Tree_Interface_DimensionTrait, const std::string& canonical_type, const mega::U64& size, const mega::U64& alignment, const bool& simple, const std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& symbols)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( p_Tree_Interface_DimensionTrait )
          , canonical_type( canonical_type )
          , size( size )
          , alignment( alignment )
          , simple( simple )
          , symbols( symbols )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_DimensionTrait->p_Clang_Interface_DimensionTrait = data::Ptr< data::Clang::Interface_DimensionTrait >( p_Tree_Interface_DimensionTrait, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_DimensionTrait );
        loader.load( canonical_type );
        loader.load( size );
        loader.load( alignment );
        loader.load( simple );
        loader.load( symbols );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_DimensionTrait );
        storer.store( canonical_type );
        storer.store( size );
        storer.store( alignment );
        storer.store( simple );
        storer.store( symbols );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "canonical_type", canonical_type } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "alignment", alignment } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "simple", simple } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbols", symbols } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_InheritanceTrait : public mega::io::Object
    Interface_InheritanceTrait::Interface_InheritanceTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_InheritanceTrait( loader )
    {
    }
    Interface_InheritanceTrait::Interface_InheritanceTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_InheritanceTrait > p_Tree_Interface_InheritanceTrait, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& contexts)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_InheritanceTrait( p_Tree_Interface_InheritanceTrait )
          , contexts( contexts )
    {
    }
    bool Interface_InheritanceTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_InheritanceTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_InheritanceTrait->p_Clang_Interface_InheritanceTrait = data::Ptr< data::Clang::Interface_InheritanceTrait >( p_Tree_Interface_InheritanceTrait, this );
    }
    void Interface_InheritanceTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_InheritanceTrait );
        loader.load( contexts );
    }
    void Interface_InheritanceTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_InheritanceTrait );
        storer.store( contexts );
    }
    void Interface_InheritanceTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_InheritanceTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "contexts", contexts } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_ReturnTypeTrait : public mega::io::Object
    Interface_ReturnTypeTrait::Interface_ReturnTypeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ReturnTypeTrait( loader )
    {
    }
    Interface_ReturnTypeTrait::Interface_ReturnTypeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_ReturnTypeTrait > p_Tree_Interface_ReturnTypeTrait, const std::string& canonical_type)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ReturnTypeTrait( p_Tree_Interface_ReturnTypeTrait )
          , canonical_type( canonical_type )
    {
    }
    bool Interface_ReturnTypeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_ReturnTypeTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_ReturnTypeTrait->p_Clang_Interface_ReturnTypeTrait = data::Ptr< data::Clang::Interface_ReturnTypeTrait >( p_Tree_Interface_ReturnTypeTrait, this );
    }
    void Interface_ReturnTypeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ReturnTypeTrait );
        loader.load( canonical_type );
    }
    void Interface_ReturnTypeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ReturnTypeTrait );
        storer.store( canonical_type );
    }
    void Interface_ReturnTypeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ReturnTypeTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "canonical_type", canonical_type } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_ArgumentListTrait : public mega::io::Object
    Interface_ArgumentListTrait::Interface_ArgumentListTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ArgumentListTrait( loader )
    {
    }
    Interface_ArgumentListTrait::Interface_ArgumentListTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_ArgumentListTrait > p_Tree_Interface_ArgumentListTrait, const std::vector< std::string >& canonical_types)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ArgumentListTrait( p_Tree_Interface_ArgumentListTrait )
          , canonical_types( canonical_types )
    {
    }
    bool Interface_ArgumentListTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_ArgumentListTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_ArgumentListTrait->p_Clang_Interface_ArgumentListTrait = data::Ptr< data::Clang::Interface_ArgumentListTrait >( p_Tree_Interface_ArgumentListTrait, this );
    }
    void Interface_ArgumentListTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ArgumentListTrait );
        loader.load( canonical_types );
    }
    void Interface_ArgumentListTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ArgumentListTrait );
        storer.store( canonical_types );
    }
    void Interface_ArgumentListTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ArgumentListTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "canonical_types", canonical_types } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_SizeTrait : public mega::io::Object
    Interface_SizeTrait::Interface_SizeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_SizeTrait( loader )
    {
    }
    Interface_SizeTrait::Interface_SizeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_SizeTrait > p_Tree_Interface_SizeTrait, const mega::U64& size)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_SizeTrait( p_Tree_Interface_SizeTrait )
          , size( size )
    {
    }
    bool Interface_SizeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_SizeTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_SizeTrait->p_Clang_Interface_SizeTrait = data::Ptr< data::Clang::Interface_SizeTrait >( p_Tree_Interface_SizeTrait, this );
    }
    void Interface_SizeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_SizeTrait );
        loader.load( size );
    }
    void Interface_SizeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_SizeTrait );
        storer.store( size );
    }
    void Interface_SizeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_SizeTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Concrete
{
    // struct Concrete_Dimensions_User : public mega::io::Object
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Dimensions_User >( loader, this ) )          , p_PerSourceConcreteTable_Concrete_Dimensions_User( loader )
          , p_MemoryLayout_Concrete_Dimensions_User( loader )
          , parent( loader )
          , interface_dimension( loader )
    {
    }
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& parent, const data::Ptr< data::Tree::Interface_DimensionTrait >& interface_dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Dimensions_User >( loader, this ) )          , p_PerSourceConcreteTable_Concrete_Dimensions_User( loader )
          , p_MemoryLayout_Concrete_Dimensions_User( loader )
          , parent( parent )
          , interface_dimension( interface_dimension )
    {
    }
    bool Concrete_Dimensions_User::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >{ data::Ptr< data::Concrete::Concrete_Dimensions_User >( loader, const_cast< Concrete_Dimensions_User* >( this ) ) };
    }
    void Concrete_Dimensions_User::set_inheritance_pointer()
    {
    }
    void Concrete_Dimensions_User::load( mega::io::Loader& loader )
    {
        loader.load( parent );
        loader.load( interface_dimension );
    }
    void Concrete_Dimensions_User::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
        storer.store( interface_dimension );
    }
    void Concrete_Dimensions_User::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_User" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_dimension", interface_dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_ContextGroup : public mega::io::Object
    Concrete_ContextGroup::Concrete_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_ContextGroup >( loader, this ) )    {
    }
    Concrete_ContextGroup::Concrete_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Concrete::Concrete_Context > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_ContextGroup >( loader, this ) )          , children( children )
    {
    }
    bool Concrete_ContextGroup::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_ContextGroup >( loader, const_cast< Concrete_ContextGroup* >( this ) ) };
    }
    void Concrete_ContextGroup::set_inheritance_pointer()
    {
    }
    void Concrete_ContextGroup::load( mega::io::Loader& loader )
    {
        loader.load( children );
    }
    void Concrete_ContextGroup::store( mega::io::Storer& storer ) const
    {
        storer.store( children );
    }
    void Concrete_ContextGroup::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_ContextGroup" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Context : public mega::io::Object
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Context >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , p_PerSourceConcreteTable_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Context( loader )
          , component( loader )
          , parent( loader )
          , interface( loader )
    {
    }
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Components::Components_Component >& component, const data::Ptr< data::Concrete::Concrete_ContextGroup >& parent, const data::Ptr< data::Tree::Interface_IContext >& interface, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Context >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , p_PerSourceConcreteTable_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Context( loader )
          , component( component )
          , parent( parent )
          , interface( interface )
          , inheritance( inheritance )
    {
    }
    bool Concrete_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Context >( loader, const_cast< Concrete_Context* >( this ) ) };
    }
    void Concrete_Context::set_inheritance_pointer()
    {
        p_Concrete_Concrete_ContextGroup->m_inheritance = data::Ptr< data::Concrete::Concrete_Context >( p_Concrete_Concrete_ContextGroup, this );
    }
    void Concrete_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_ContextGroup );
        loader.load( component );
        loader.load( parent );
        loader.load( interface );
        loader.load( inheritance );
    }
    void Concrete_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_ContextGroup );
        storer.store( component );
        storer.store( parent );
        storer.store( interface );
        storer.store( inheritance );
    }
    void Concrete_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Context" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "component", component } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface", interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Namespace : public mega::io::Object
    Concrete_Namespace::Concrete_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Namespace >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_namespace( loader )
    {
    }
    Concrete_Namespace::Concrete_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Namespace >& interface_namespace, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Namespace >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_namespace( interface_namespace )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Namespace::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Namespace >( loader, const_cast< Concrete_Namespace* >( this ) ) };
    }
    void Concrete_Namespace::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Namespace >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Namespace::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_namespace );
        loader.load( dimensions );
    }
    void Concrete_Namespace::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_namespace );
        storer.store( dimensions );
    }
    void Concrete_Namespace::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Namespace" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_namespace", interface_namespace } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Action : public mega::io::Object
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Action >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Action( loader )
          , interface_action( loader )
    {
    }
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Action >& interface_action, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Action >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Action( loader )
          , interface_action( interface_action )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Action::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Action >( loader, const_cast< Concrete_Action* >( this ) ) };
    }
    void Concrete_Action::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Action >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Action::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_action );
        loader.load( dimensions );
    }
    void Concrete_Action::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_action );
        storer.store( dimensions );
    }
    void Concrete_Action::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Action" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_action", interface_action } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Event : public mega::io::Object
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Event >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Event( loader )
          , interface_event( loader )
    {
    }
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Event >& interface_event, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Event >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Event( loader )
          , interface_event( interface_event )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Event::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Event >( loader, const_cast< Concrete_Event* >( this ) ) };
    }
    void Concrete_Event::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Event >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Event::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_event );
        loader.load( dimensions );
    }
    void Concrete_Event::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_event );
        storer.store( dimensions );
    }
    void Concrete_Event::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Event" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_event", interface_event } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Function : public mega::io::Object
    Concrete_Function::Concrete_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Function >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_function( loader )
    {
    }
    Concrete_Function::Concrete_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Function >& interface_function)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Function >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_function( interface_function )
    {
    }
    bool Concrete_Function::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Function >( loader, const_cast< Concrete_Function* >( this ) ) };
    }
    void Concrete_Function::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Function >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Function::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_function );
    }
    void Concrete_Function::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_function );
    }
    void Concrete_Function::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Function" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_function", interface_function } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Object : public mega::io::Object
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Object >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Object( loader )
          , interface_object( loader )
    {
    }
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Object >& interface_object, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Object >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Object( loader )
          , interface_object( interface_object )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Object::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Object >( loader, const_cast< Concrete_Object* >( this ) ) };
    }
    void Concrete_Object::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Object >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Object::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_object );
        loader.load( dimensions );
    }
    void Concrete_Object::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_object );
        storer.store( dimensions );
    }
    void Concrete_Object::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Object" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_object", interface_object } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Link : public mega::io::Object
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Link >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Link( loader )
          , link( loader )
    {
    }
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Link >& link)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Link >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Link( loader )
          , link( link )
    {
    }
    bool Concrete_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Link >( loader, const_cast< Concrete_Link* >( this ) ) };
    }
    void Concrete_Link::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Link >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( link );
    }
    void Concrete_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( link );
    }
    void Concrete_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Link" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link", link } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Buffer : public mega::io::Object
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Buffer >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Buffer( loader )
          , interface_buffer( loader )
    {
    }
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Buffer >& interface_buffer, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Buffer >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Buffer( loader )
          , interface_buffer( interface_buffer )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Buffer >( loader, const_cast< Concrete_Buffer* >( this ) ) };
    }
    void Concrete_Buffer::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Buffer >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_buffer );
        loader.load( dimensions );
    }
    void Concrete_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_buffer );
        storer.store( dimensions );
    }
    void Concrete_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Buffer" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_buffer", interface_buffer } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Root : public mega::io::Object
    Concrete_Root::Concrete_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Root >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , interface_root( loader )
    {
    }
    Concrete_Root::Concrete_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Root >& interface_root)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Root >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , interface_root( interface_root )
    {
    }
    bool Concrete_Root::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Root >( loader, const_cast< Concrete_Root* >( this ) ) };
    }
    void Concrete_Root::set_inheritance_pointer()
    {
        p_Concrete_Concrete_ContextGroup->m_inheritance = data::Ptr< data::Concrete::Concrete_Root >( p_Concrete_Concrete_ContextGroup, this );
    }
    void Concrete_Root::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_ContextGroup );
        loader.load( interface_root );
    }
    void Concrete_Root::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_ContextGroup );
        storer.store( interface_root );
    }
    void Concrete_Root::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Root" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_root", interface_root } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Derivations
{
    // struct Derivation_ObjectMapping : public mega::io::Object
    Derivation_ObjectMapping::Derivation_ObjectMapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_ObjectMapping >( loader, this ) )    {
    }
    Derivation_ObjectMapping::Derivation_ObjectMapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::io::megaFilePath& source_file, const mega::U64& hash_code, const std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& inheritance_contexts, const std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& inheritance_dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_ObjectMapping >( loader, this ) )          , source_file( source_file )
          , hash_code( hash_code )
          , inheritance_contexts( inheritance_contexts )
          , inheritance_dimensions( inheritance_dimensions )
    {
    }
    bool Derivation_ObjectMapping::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >{ data::Ptr< data::Derivations::Derivation_ObjectMapping >( loader, const_cast< Derivation_ObjectMapping* >( this ) ) };
    }
    void Derivation_ObjectMapping::set_inheritance_pointer()
    {
    }
    void Derivation_ObjectMapping::load( mega::io::Loader& loader )
    {
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( inheritance_contexts );
        loader.load( inheritance_dimensions );
    }
    void Derivation_ObjectMapping::store( mega::io::Storer& storer ) const
    {
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( inheritance_contexts );
        storer.store( inheritance_dimensions );
    }
    void Derivation_ObjectMapping::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Derivation_ObjectMapping" },
                { "filetype" , "Derivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_contexts", inheritance_contexts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_dimensions", inheritance_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Derivation_Mapping : public mega::io::Object
    Derivation_Mapping::Derivation_Mapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_Mapping >( loader, this ) )    {
    }
    Derivation_Mapping::Derivation_Mapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& mappings, const std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& inheritance_contexts, const std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& inheritance_dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_Mapping >( loader, this ) )          , mappings( mappings )
          , inheritance_contexts( inheritance_contexts )
          , inheritance_dimensions( inheritance_dimensions )
    {
    }
    bool Derivation_Mapping::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >{ data::Ptr< data::Derivations::Derivation_Mapping >( loader, const_cast< Derivation_Mapping* >( this ) ) };
    }
    void Derivation_Mapping::set_inheritance_pointer()
    {
    }
    void Derivation_Mapping::load( mega::io::Loader& loader )
    {
        loader.load( mappings );
        loader.load( inheritance_contexts );
        loader.load( inheritance_dimensions );
    }
    void Derivation_Mapping::store( mega::io::Storer& storer ) const
    {
        storer.store( mappings );
        storer.store( inheritance_contexts );
        storer.store( inheritance_dimensions );
    }
    void Derivation_Mapping::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Derivation_Mapping" },
                { "filetype" , "Derivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "mappings", mappings } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_contexts", inheritance_contexts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_dimensions", inheritance_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceDerivations
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_DimensionTrait > p_Tree_Interface_DimensionTrait, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& concrete)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( p_Tree_Interface_DimensionTrait )
          , concrete( concrete )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_DimensionTrait->p_PerSourceDerivations_Interface_DimensionTrait = data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait >( p_Tree_Interface_DimensionTrait, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_DimensionTrait );
        loader.load( concrete );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_DimensionTrait );
        storer.store( concrete );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "PerSourceDerivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_IContext : public mega::io::Object
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_IContext > p_Tree_Interface_IContext, const std::vector< data::Ptr< data::Concrete::Concrete_Context > >& concrete)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( p_Tree_Interface_IContext )
          , concrete( concrete )
    {
    }
    bool Interface_IContext::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_IContext::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->p_PerSourceDerivations_Interface_IContext = data::Ptr< data::PerSourceDerivations::Interface_IContext >( p_Tree_Interface_IContext, this );
    }
    void Interface_IContext::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( concrete );
    }
    void Interface_IContext::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( concrete );
    }
    void Interface_IContext::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_IContext" },
                { "filetype" , "PerSourceDerivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Model
{
    // struct HyperGraph_Relation : public mega::io::Object
    HyperGraph_Relation::HyperGraph_Relation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relation >( loader, this ) )          , source( loader )
          , target( loader )
          , source_interface( loader )
          , target_interface( loader )
    {
    }
    HyperGraph_Relation::HyperGraph_Relation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Link >& source, const data::Ptr< data::Tree::Interface_Link >& target, const data::Ptr< data::Tree::Interface_LinkInterface >& source_interface, const data::Ptr< data::Tree::Interface_LinkInterface >& target_interface)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relation >( loader, this ) )          , source( source )
          , target( target )
          , source_interface( source_interface )
          , target_interface( target_interface )
    {
    }
    bool HyperGraph_Relation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Model::HyperGraph_Relation > >{ data::Ptr< data::Model::HyperGraph_Relation >( loader, const_cast< HyperGraph_Relation* >( this ) ) };
    }
    void HyperGraph_Relation::set_inheritance_pointer()
    {
    }
    void HyperGraph_Relation::load( mega::io::Loader& loader )
    {
        loader.load( source );
        loader.load( target );
        loader.load( source_interface );
        loader.load( target_interface );
    }
    void HyperGraph_Relation::store( mega::io::Storer& storer ) const
    {
        storer.store( source );
        storer.store( target );
        storer.store( source_interface );
        storer.store( target_interface );
    }
    void HyperGraph_Relation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "HyperGraph_Relation" },
                { "filetype" , "Model" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source", source } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "target", target } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_interface", source_interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "target_interface", target_interface } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct HyperGraph_Relations : public mega::io::Object
    HyperGraph_Relations::HyperGraph_Relations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relations >( loader, this ) )    {
    }
    HyperGraph_Relations::HyperGraph_Relations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::io::megaFilePath& source_file, const mega::U64& hash_code, const std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& relations)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relations >( loader, this ) )          , source_file( source_file )
          , hash_code( hash_code )
          , relations( relations )
    {
    }
    bool HyperGraph_Relations::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Model::HyperGraph_Relations > >{ data::Ptr< data::Model::HyperGraph_Relations >( loader, const_cast< HyperGraph_Relations* >( this ) ) };
    }
    void HyperGraph_Relations::set_inheritance_pointer()
    {
    }
    void HyperGraph_Relations::load( mega::io::Loader& loader )
    {
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( relations );
    }
    void HyperGraph_Relations::store( mega::io::Storer& storer ) const
    {
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( relations );
    }
    void HyperGraph_Relations::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "HyperGraph_Relations" },
                { "filetype" , "Model" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "relations", relations } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct HyperGraph_Graph : public mega::io::Object
    HyperGraph_Graph::HyperGraph_Graph( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Graph >( loader, this ) )    {
    }
    HyperGraph_Graph::HyperGraph_Graph( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& relations)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Graph >( loader, this ) )          , relations( relations )
    {
    }
    bool HyperGraph_Graph::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Model::HyperGraph_Graph > >{ data::Ptr< data::Model::HyperGraph_Graph >( loader, const_cast< HyperGraph_Graph* >( this ) ) };
    }
    void HyperGraph_Graph::set_inheritance_pointer()
    {
    }
    void HyperGraph_Graph::load( mega::io::Loader& loader )
    {
        loader.load( relations );
    }
    void HyperGraph_Graph::store( mega::io::Storer& storer ) const
    {
        storer.store( relations );
    }
    void HyperGraph_Graph::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "HyperGraph_Graph" },
                { "filetype" , "Model" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "relations", relations } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceModel
{
    // struct Interface_Link : public mega::io::Object
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_Link( loader )
          , relation( loader )
    {
    }
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_Link > p_Tree_Interface_Link, const data::Ptr< data::Model::HyperGraph_Relation >& relation)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_Link( p_Tree_Interface_Link )
          , relation( relation )
    {
    }
    bool Interface_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_Link::set_inheritance_pointer()
    {
        p_Tree_Interface_Link->p_PerSourceModel_Interface_Link = data::Ptr< data::PerSourceModel::Interface_Link >( p_Tree_Interface_Link, this );
    }
    void Interface_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_Link );
        loader.load( relation );
    }
    void Interface_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_Link );
        storer.store( relation );
    }
    void Interface_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Link" },
                { "filetype" , "PerSourceModel" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "relation", relation } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace MemoryLayout
{
    // struct Concrete_Dimensions_User : public mega::io::Object
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Dimensions_User( loader )
          , part( loader )
    {
    }
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Dimensions_User > p_Concrete_Concrete_Dimensions_User, const mega::U64& offset, const data::Ptr< data::MemoryLayout::MemoryLayout_Part >& part)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Dimensions_User( p_Concrete_Concrete_Dimensions_User )
          , offset( offset )
          , part( part )
    {
    }
    bool Concrete_Dimensions_User::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Dimensions_User::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Dimensions_User->p_MemoryLayout_Concrete_Dimensions_User = data::Ptr< data::MemoryLayout::Concrete_Dimensions_User >( p_Concrete_Concrete_Dimensions_User, this );
    }
    void Concrete_Dimensions_User::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Dimensions_User );
        loader.load( offset );
        loader.load( part );
    }
    void Concrete_Dimensions_User::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Dimensions_User );
        storer.store( offset );
        storer.store( part );
    }
    void Concrete_Dimensions_User::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_User" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "offset", offset } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "part", part } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_LinkReference : public mega::io::Object
    Concrete_Dimensions_LinkReference::Concrete_Dimensions_LinkReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >( loader, this ) )          , p_PerSourceConcreteTable_Concrete_Dimensions_LinkReference( loader )
          , parent( loader )
          , link( loader )
          , part( loader )
    {
    }
    Concrete_Dimensions_LinkReference::Concrete_Dimensions_LinkReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& parent, const data::Ptr< data::Concrete::Concrete_Link >& link)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >( loader, this ) )          , p_PerSourceConcreteTable_Concrete_Dimensions_LinkReference( loader )
          , parent( parent )
          , link( link )
    {
    }
    bool Concrete_Dimensions_LinkReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >( loader, const_cast< Concrete_Dimensions_LinkReference* >( this ) ) };
    }
    void Concrete_Dimensions_LinkReference::set_inheritance_pointer()
    {
    }
    void Concrete_Dimensions_LinkReference::load( mega::io::Loader& loader )
    {
        loader.load( parent );
        loader.load( link );
        loader.load( part );
        loader.load( offset );
    }
    void Concrete_Dimensions_LinkReference::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
        storer.store( link );
        VERIFY_RTE_MSG( part.has_value(), "MemoryLayout::Concrete_Dimensions_LinkReference.part has NOT been set" );
        storer.store( part );
        VERIFY_RTE_MSG( offset.has_value(), "MemoryLayout::Concrete_Dimensions_LinkReference.offset has NOT been set" );
        storer.store( offset );
    }
    void Concrete_Dimensions_LinkReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkReference" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link", link } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "part", part.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "offset", offset.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_LinkSingle : public mega::io::Object
    Concrete_Dimensions_LinkSingle::Concrete_Dimensions_LinkSingle( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_LinkReference( loader )
    {
    }
    bool Concrete_Dimensions_LinkSingle::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >( loader, const_cast< Concrete_Dimensions_LinkSingle* >( this ) ) };
    }
    void Concrete_Dimensions_LinkSingle::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_LinkReference->m_inheritance = data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >( p_MemoryLayout_Concrete_Dimensions_LinkReference, this );
    }
    void Concrete_Dimensions_LinkSingle::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkSingle::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkSingle::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkSingle" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Concrete_Dimensions_LinkMany : public mega::io::Object
    Concrete_Dimensions_LinkMany::Concrete_Dimensions_LinkMany( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_LinkReference( loader )
    {
    }
    bool Concrete_Dimensions_LinkMany::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >( loader, const_cast< Concrete_Dimensions_LinkMany* >( this ) ) };
    }
    void Concrete_Dimensions_LinkMany::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_LinkReference->m_inheritance = data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >( p_MemoryLayout_Concrete_Dimensions_LinkReference, this );
    }
    void Concrete_Dimensions_LinkMany::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkMany::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkMany::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkMany" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Concrete_Dimensions_Allocation : public mega::io::Object
    Concrete_Dimensions_Allocation::Concrete_Dimensions_Allocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >( loader, this ) )          , p_PerSourceConcreteTable_Concrete_Dimensions_Allocation( loader )
          , parent( loader )
          , part( loader )
    {
    }
    Concrete_Dimensions_Allocation::Concrete_Dimensions_Allocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >( loader, this ) )          , p_PerSourceConcreteTable_Concrete_Dimensions_Allocation( loader )
          , parent( parent )
    {
    }
    bool Concrete_Dimensions_Allocation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >( loader, const_cast< Concrete_Dimensions_Allocation* >( this ) ) };
    }
    void Concrete_Dimensions_Allocation::set_inheritance_pointer()
    {
    }
    void Concrete_Dimensions_Allocation::load( mega::io::Loader& loader )
    {
        loader.load( parent );
        loader.load( part );
        loader.load( offset );
    }
    void Concrete_Dimensions_Allocation::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
        VERIFY_RTE_MSG( part.has_value(), "MemoryLayout::Concrete_Dimensions_Allocation.part has NOT been set" );
        storer.store( part );
        VERIFY_RTE_MSG( offset.has_value(), "MemoryLayout::Concrete_Dimensions_Allocation.offset has NOT been set" );
        storer.store( offset );
    }
    void Concrete_Dimensions_Allocation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_Allocation" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "part", part.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "offset", offset.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_Allocator : public mega::io::Object
    Concrete_Dimensions_Allocator::Concrete_Dimensions_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_Allocation( loader )
          , allocator( loader )
    {
    }
    Concrete_Dimensions_Allocator::Concrete_Dimensions_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::MemoryLayout::Allocators_Allocator >& allocator)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_Allocation( loader )
          , allocator( allocator )
    {
    }
    bool Concrete_Dimensions_Allocator::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( loader, const_cast< Concrete_Dimensions_Allocator* >( this ) ) };
    }
    void Concrete_Dimensions_Allocator::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_Allocation->m_inheritance = data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( p_MemoryLayout_Concrete_Dimensions_Allocation, this );
    }
    void Concrete_Dimensions_Allocator::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_Allocation );
        loader.load( allocator );
    }
    void Concrete_Dimensions_Allocator::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_Allocation );
        storer.store( allocator );
    }
    void Concrete_Dimensions_Allocator::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_Allocator" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocator", allocator } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Context : public mega::io::Object
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( loader )
          , allocator( loader )
    {
    }
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Context > p_Concrete_Concrete_Context, const data::Ptr< data::MemoryLayout::Allocators_Allocator >& allocator, const std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& allocation_dimensions)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( p_Concrete_Concrete_Context )
          , allocator( allocator )
          , allocation_dimensions( allocation_dimensions )
    {
    }
    bool Concrete_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Context::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->p_MemoryLayout_Concrete_Context = data::Ptr< data::MemoryLayout::Concrete_Context >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( allocator );
        loader.load( allocation_dimensions );
    }
    void Concrete_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( allocator );
        storer.store( allocation_dimensions );
    }
    void Concrete_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Context" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocator", allocator } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocation_dimensions", allocation_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Action : public mega::io::Object
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Action( loader )
    {
    }
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Action > p_Concrete_Concrete_Action, const mega::U64& local_size, const mega::U64& total_size)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Action( p_Concrete_Concrete_Action )
          , local_size( local_size )
          , total_size( total_size )
    {
    }
    bool Concrete_Action::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Action::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Action->p_MemoryLayout_Concrete_Action = data::Ptr< data::MemoryLayout::Concrete_Action >( p_Concrete_Concrete_Action, this );
    }
    void Concrete_Action::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Action );
        loader.load( local_size );
        loader.load( total_size );
    }
    void Concrete_Action::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Action );
        storer.store( local_size );
        storer.store( total_size );
    }
    void Concrete_Action::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Action" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "local_size", local_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Event : public mega::io::Object
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Event( loader )
    {
    }
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Event > p_Concrete_Concrete_Event, const mega::U64& local_size, const mega::U64& total_size)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Event( p_Concrete_Concrete_Event )
          , local_size( local_size )
          , total_size( total_size )
    {
    }
    bool Concrete_Event::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Event::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Event->p_MemoryLayout_Concrete_Event = data::Ptr< data::MemoryLayout::Concrete_Event >( p_Concrete_Concrete_Event, this );
    }
    void Concrete_Event::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Event );
        loader.load( local_size );
        loader.load( total_size );
    }
    void Concrete_Event::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Event );
        storer.store( local_size );
        storer.store( total_size );
    }
    void Concrete_Event::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Event" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "local_size", local_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Object : public mega::io::Object
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Object( loader )
    {
    }
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Object > p_Concrete_Concrete_Object, const std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& buffers)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Object( p_Concrete_Concrete_Object )
          , buffers( buffers )
    {
    }
    bool Concrete_Object::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Object::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Object->p_MemoryLayout_Concrete_Object = data::Ptr< data::MemoryLayout::Concrete_Object >( p_Concrete_Concrete_Object, this );
    }
    void Concrete_Object::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Object );
        loader.load( buffers );
    }
    void Concrete_Object::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Object );
        storer.store( buffers );
    }
    void Concrete_Object::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Object" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "buffers", buffers } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Link : public mega::io::Object
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Link( loader )
          , link_reference( loader )
    {
    }
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Link > p_Concrete_Concrete_Link, const mega::U64& total_size, const data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& link_reference)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Link( p_Concrete_Concrete_Link )
          , total_size( total_size )
          , link_reference( link_reference )
    {
    }
    bool Concrete_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Link::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Link->p_MemoryLayout_Concrete_Link = data::Ptr< data::MemoryLayout::Concrete_Link >( p_Concrete_Concrete_Link, this );
    }
    void Concrete_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Link );
        loader.load( total_size );
        loader.load( link_reference );
    }
    void Concrete_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Link );
        storer.store( total_size );
        storer.store( link_reference );
    }
    void Concrete_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Link" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_reference", link_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Buffer : public mega::io::Object
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Buffer( loader )
    {
    }
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Buffer > p_Concrete_Concrete_Buffer, const mega::U64& total_size)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Buffer( p_Concrete_Concrete_Buffer )
          , total_size( total_size )
    {
    }
    bool Concrete_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Buffer::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Buffer->p_MemoryLayout_Concrete_Buffer = data::Ptr< data::MemoryLayout::Concrete_Buffer >( p_Concrete_Concrete_Buffer, this );
    }
    void Concrete_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Buffer );
        loader.load( total_size );
    }
    void Concrete_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Buffer );
        storer.store( total_size );
    }
    void Concrete_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Buffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Allocators_Allocator : public mega::io::Object
    Allocators_Allocator::Allocators_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Allocator >( loader, this ) )          , allocated_context( loader )
    {
    }
    Allocators_Allocator::Allocators_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Concrete::Concrete_Context > >& parent_context, const data::Ptr< data::Concrete::Concrete_Context >& allocated_context)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Allocator >( loader, this ) )          , parent_context( parent_context )
          , allocated_context( allocated_context )
    {
    }
    bool Allocators_Allocator::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Allocator >( loader, const_cast< Allocators_Allocator* >( this ) ) };
    }
    void Allocators_Allocator::set_inheritance_pointer()
    {
    }
    void Allocators_Allocator::load( mega::io::Loader& loader )
    {
        loader.load( parent_context );
        loader.load( allocated_context );
        loader.load( dimension );
    }
    void Allocators_Allocator::store( mega::io::Storer& storer ) const
    {
        storer.store( parent_context );
        storer.store( allocated_context );
        VERIFY_RTE_MSG( dimension.has_value(), "MemoryLayout::Allocators_Allocator.dimension has NOT been set" );
        storer.store( dimension );
    }
    void Allocators_Allocator::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Allocator" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent_context", parent_context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocated_context", allocated_context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Allocators_Nothing : public mega::io::Object
    Allocators_Nothing::Allocators_Nothing( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Nothing >( loader, this ) )          , p_MemoryLayout_Allocators_Allocator( loader )
    {
    }
    bool Allocators_Nothing::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Nothing >( loader, const_cast< Allocators_Nothing* >( this ) ) };
    }
    void Allocators_Nothing::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Allocator->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Nothing >( p_MemoryLayout_Allocators_Allocator, this );
    }
    void Allocators_Nothing::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Nothing::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Nothing::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Nothing" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Singleton : public mega::io::Object
    Allocators_Singleton::Allocators_Singleton( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Singleton >( loader, this ) )          , p_MemoryLayout_Allocators_Allocator( loader )
    {
    }
    bool Allocators_Singleton::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Singleton >( loader, const_cast< Allocators_Singleton* >( this ) ) };
    }
    void Allocators_Singleton::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Allocator->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Singleton >( p_MemoryLayout_Allocators_Allocator, this );
    }
    void Allocators_Singleton::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Singleton::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Singleton::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Singleton" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Range : public mega::io::Object
    Allocators_Range::Allocators_Range( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Range >( loader, this ) )          , p_MemoryLayout_Allocators_Allocator( loader )
    {
    }
    bool Allocators_Range::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Range >( loader, const_cast< Allocators_Range* >( this ) ) };
    }
    void Allocators_Range::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Allocator->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Range >( p_MemoryLayout_Allocators_Allocator, this );
    }
    void Allocators_Range::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Range::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Range::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Range" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Range32 : public mega::io::Object
    Allocators_Range32::Allocators_Range32( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Range32 >( loader, this ) )          , p_MemoryLayout_Allocators_Range( loader )
    {
    }
    bool Allocators_Range32::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Range32 >( loader, const_cast< Allocators_Range32* >( this ) ) };
    }
    void Allocators_Range32::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Range->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Range32 >( p_MemoryLayout_Allocators_Range, this );
    }
    void Allocators_Range32::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range32::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range32::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Range32" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Range64 : public mega::io::Object
    Allocators_Range64::Allocators_Range64( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Range64 >( loader, this ) )          , p_MemoryLayout_Allocators_Range( loader )
    {
    }
    bool Allocators_Range64::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Range64 >( loader, const_cast< Allocators_Range64* >( this ) ) };
    }
    void Allocators_Range64::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Range->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Range64 >( p_MemoryLayout_Allocators_Range, this );
    }
    void Allocators_Range64::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range64::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range64::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Range64" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_RangeAny : public mega::io::Object
    Allocators_RangeAny::Allocators_RangeAny( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_RangeAny >( loader, this ) )          , p_MemoryLayout_Allocators_Range( loader )
    {
    }
    bool Allocators_RangeAny::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_RangeAny >( loader, const_cast< Allocators_RangeAny* >( this ) ) };
    }
    void Allocators_RangeAny::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Range->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_RangeAny >( p_MemoryLayout_Allocators_Range, this );
    }
    void Allocators_RangeAny::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_RangeAny::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_RangeAny::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_RangeAny" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct MemoryLayout_Part : public mega::io::Object
    MemoryLayout_Part::MemoryLayout_Part( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Part >( loader, this ) )          , context( loader )
          , buffer( loader )
    {
    }
    MemoryLayout_Part::MemoryLayout_Part( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::U64& total_domain_size, const data::Ptr< data::Concrete::Concrete_Context >& context, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& user_dimensions, const std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& link_dimensions, const std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& allocation_dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Part >( loader, this ) )          , total_domain_size( total_domain_size )
          , context( context )
          , user_dimensions( user_dimensions )
          , link_dimensions( link_dimensions )
          , allocation_dimensions( allocation_dimensions )
    {
    }
    bool MemoryLayout_Part::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >{ data::Ptr< data::MemoryLayout::MemoryLayout_Part >( loader, const_cast< MemoryLayout_Part* >( this ) ) };
    }
    void MemoryLayout_Part::set_inheritance_pointer()
    {
    }
    void MemoryLayout_Part::load( mega::io::Loader& loader )
    {
        loader.load( total_domain_size );
        loader.load( context );
        loader.load( user_dimensions );
        loader.load( link_dimensions );
        loader.load( allocation_dimensions );
        loader.load( size );
        loader.load( alignment );
        loader.load( offset );
        loader.load( buffer );
    }
    void MemoryLayout_Part::store( mega::io::Storer& storer ) const
    {
        storer.store( total_domain_size );
        storer.store( context );
        storer.store( user_dimensions );
        storer.store( link_dimensions );
        storer.store( allocation_dimensions );
        VERIFY_RTE_MSG( size.has_value(), "MemoryLayout::MemoryLayout_Part.size has NOT been set" );
        storer.store( size );
        VERIFY_RTE_MSG( alignment.has_value(), "MemoryLayout::MemoryLayout_Part.alignment has NOT been set" );
        storer.store( alignment );
        VERIFY_RTE_MSG( offset.has_value(), "MemoryLayout::MemoryLayout_Part.offset has NOT been set" );
        storer.store( offset );
        VERIFY_RTE_MSG( buffer.has_value(), "MemoryLayout::MemoryLayout_Part.buffer has NOT been set" );
        storer.store( buffer );
    }
    void MemoryLayout_Part::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_Part" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_domain_size", total_domain_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "user_dimensions", user_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_dimensions", link_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocation_dimensions", allocation_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "alignment", alignment.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "offset", offset.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "buffer", buffer.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct MemoryLayout_Buffer : public mega::io::Object
    MemoryLayout_Buffer::MemoryLayout_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >( loader, this ) )    {
    }
    MemoryLayout_Buffer::MemoryLayout_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& parts, const mega::U64& size, const mega::U64& alignment)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >( loader, this ) )          , parts( parts )
          , size( size )
          , alignment( alignment )
    {
    }
    bool MemoryLayout_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >( loader, const_cast< MemoryLayout_Buffer* >( this ) ) };
    }
    void MemoryLayout_Buffer::set_inheritance_pointer()
    {
    }
    void MemoryLayout_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( parts );
        loader.load( size );
        loader.load( alignment );
    }
    void MemoryLayout_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( parts );
        storer.store( size );
        storer.store( alignment );
    }
    void MemoryLayout_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_Buffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parts", parts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "alignment", alignment } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct MemoryLayout_NonSimpleBuffer : public mega::io::Object
    MemoryLayout_NonSimpleBuffer::MemoryLayout_NonSimpleBuffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >( loader, this ) )          , p_MemoryLayout_MemoryLayout_Buffer( loader )
    {
    }
    bool MemoryLayout_NonSimpleBuffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >( loader, const_cast< MemoryLayout_NonSimpleBuffer* >( this ) ) };
    }
    void MemoryLayout_NonSimpleBuffer::set_inheritance_pointer()
    {
        p_MemoryLayout_MemoryLayout_Buffer->m_inheritance = data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >( p_MemoryLayout_MemoryLayout_Buffer, this );
    }
    void MemoryLayout_NonSimpleBuffer::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_NonSimpleBuffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_NonSimpleBuffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_NonSimpleBuffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct MemoryLayout_SimpleBuffer : public mega::io::Object
    MemoryLayout_SimpleBuffer::MemoryLayout_SimpleBuffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >( loader, this ) )          , p_MemoryLayout_MemoryLayout_Buffer( loader )
    {
    }
    bool MemoryLayout_SimpleBuffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >( loader, const_cast< MemoryLayout_SimpleBuffer* >( this ) ) };
    }
    void MemoryLayout_SimpleBuffer::set_inheritance_pointer()
    {
        p_MemoryLayout_MemoryLayout_Buffer->m_inheritance = data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >( p_MemoryLayout_MemoryLayout_Buffer, this );
    }
    void MemoryLayout_SimpleBuffer::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_SimpleBuffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_SimpleBuffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_SimpleBuffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct MemoryLayout_GPUBuffer : public mega::io::Object
    MemoryLayout_GPUBuffer::MemoryLayout_GPUBuffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >( loader, this ) )          , p_MemoryLayout_MemoryLayout_Buffer( loader )
    {
    }
    bool MemoryLayout_GPUBuffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >( loader, const_cast< MemoryLayout_GPUBuffer* >( this ) ) };
    }
    void MemoryLayout_GPUBuffer::set_inheritance_pointer()
    {
        p_MemoryLayout_MemoryLayout_Buffer->m_inheritance = data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >( p_MemoryLayout_MemoryLayout_Buffer, this );
    }
    void MemoryLayout_GPUBuffer::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_GPUBuffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_GPUBuffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_GPUBuffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
}
namespace ConcreteTable
{
    // struct Symbols_ConcreteTypeID : public mega::io::Object
    Symbols_ConcreteTypeID::Symbols_ConcreteTypeID( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >( loader, this ) )    {
    }
    Symbols_ConcreteTypeID::Symbols_ConcreteTypeID( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::TypeID& id, const std::optional< data::Ptr< data::Concrete::Concrete_Context > >& context, const std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dim_user, const std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& dim_link, const std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& dim_allocation)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >( loader, this ) )          , id( id )
          , context( context )
          , dim_user( dim_user )
          , dim_link( dim_link )
          , dim_allocation( dim_allocation )
    {
    }
    bool Symbols_ConcreteTypeID::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >{ data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >( loader, const_cast< Symbols_ConcreteTypeID* >( this ) ) };
    }
    void Symbols_ConcreteTypeID::set_inheritance_pointer()
    {
    }
    void Symbols_ConcreteTypeID::load( mega::io::Loader& loader )
    {
        loader.load( id );
        loader.load( context );
        loader.load( dim_user );
        loader.load( dim_link );
        loader.load( dim_allocation );
    }
    void Symbols_ConcreteTypeID::store( mega::io::Storer& storer ) const
    {
        storer.store( id );
        storer.store( context );
        storer.store( dim_user );
        storer.store( dim_link );
        storer.store( dim_allocation );
    }
    void Symbols_ConcreteTypeID::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_ConcreteTypeID" },
                { "filetype" , "ConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dim_user", dim_user } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dim_link", dim_link } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dim_allocation", dim_allocation } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_SymbolTable : public mega::io::Object
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_SymbolTable_Symbols_SymbolTable( loader )
    {
    }
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< SymbolTable::Symbols_SymbolTable > p_SymbolTable_Symbols_SymbolTable, const std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& concrete_type_id_sequences, const std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& concrete_type_id_seq_alloc, const std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& concrete_type_id_set_link, const std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& concrete_type_ids)
        :   mega::io::Object( objectInfo )          , p_SymbolTable_Symbols_SymbolTable( p_SymbolTable_Symbols_SymbolTable )
          , concrete_type_id_sequences( concrete_type_id_sequences )
          , concrete_type_id_seq_alloc( concrete_type_id_seq_alloc )
          , concrete_type_id_set_link( concrete_type_id_set_link )
          , concrete_type_ids( concrete_type_ids )
    {
    }
    bool Symbols_SymbolTable::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Symbols_SymbolTable::set_inheritance_pointer()
    {
        p_SymbolTable_Symbols_SymbolTable->p_ConcreteTable_Symbols_SymbolTable = data::Ptr< data::ConcreteTable::Symbols_SymbolTable >( p_SymbolTable_Symbols_SymbolTable, this );
    }
    void Symbols_SymbolTable::load( mega::io::Loader& loader )
    {
        loader.load( p_SymbolTable_Symbols_SymbolTable );
        loader.load( concrete_type_id_sequences );
        loader.load( concrete_type_id_seq_alloc );
        loader.load( concrete_type_id_set_link );
        loader.load( concrete_type_ids );
    }
    void Symbols_SymbolTable::store( mega::io::Storer& storer ) const
    {
        storer.store( p_SymbolTable_Symbols_SymbolTable );
        storer.store( concrete_type_id_sequences );
        storer.store( concrete_type_id_seq_alloc );
        storer.store( concrete_type_id_set_link );
        storer.store( concrete_type_ids );
    }
    void Symbols_SymbolTable::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolTable" },
                { "filetype" , "ConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_type_id_sequences", concrete_type_id_sequences } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_type_id_seq_alloc", concrete_type_id_seq_alloc } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_type_id_set_link", concrete_type_id_set_link } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_type_ids", concrete_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceConcreteTable
{
    // struct Concrete_Dimensions_User : public mega::io::Object
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Dimensions_User( loader )
    {
    }
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Dimensions_User > p_Concrete_Concrete_Dimensions_User, const mega::TypeID& concrete_id)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Dimensions_User( p_Concrete_Concrete_Dimensions_User )
          , concrete_id( concrete_id )
    {
    }
    bool Concrete_Dimensions_User::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Dimensions_User::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Dimensions_User->p_PerSourceConcreteTable_Concrete_Dimensions_User = data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_User >( p_Concrete_Concrete_Dimensions_User, this );
    }
    void Concrete_Dimensions_User::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Dimensions_User );
        loader.load( concrete_id );
    }
    void Concrete_Dimensions_User::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Dimensions_User );
        storer.store( concrete_id );
    }
    void Concrete_Dimensions_User::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_User" },
                { "filetype" , "PerSourceConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_id", concrete_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_LinkReference : public mega::io::Object
    Concrete_Dimensions_LinkReference::Concrete_Dimensions_LinkReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_MemoryLayout_Concrete_Dimensions_LinkReference( loader )
    {
    }
    Concrete_Dimensions_LinkReference::Concrete_Dimensions_LinkReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< MemoryLayout::Concrete_Dimensions_LinkReference > p_MemoryLayout_Concrete_Dimensions_LinkReference, const mega::TypeID& concrete_id)
        :   mega::io::Object( objectInfo )          , p_MemoryLayout_Concrete_Dimensions_LinkReference( p_MemoryLayout_Concrete_Dimensions_LinkReference )
          , concrete_id( concrete_id )
    {
    }
    bool Concrete_Dimensions_LinkReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Dimensions_LinkReference::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_LinkReference->p_PerSourceConcreteTable_Concrete_Dimensions_LinkReference = data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( p_MemoryLayout_Concrete_Dimensions_LinkReference, this );
    }
    void Concrete_Dimensions_LinkReference::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_LinkReference );
        loader.load( concrete_id );
    }
    void Concrete_Dimensions_LinkReference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_LinkReference );
        storer.store( concrete_id );
    }
    void Concrete_Dimensions_LinkReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkReference" },
                { "filetype" , "PerSourceConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_id", concrete_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_Allocation : public mega::io::Object
    Concrete_Dimensions_Allocation::Concrete_Dimensions_Allocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_MemoryLayout_Concrete_Dimensions_Allocation( loader )
    {
    }
    Concrete_Dimensions_Allocation::Concrete_Dimensions_Allocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< MemoryLayout::Concrete_Dimensions_Allocation > p_MemoryLayout_Concrete_Dimensions_Allocation, const mega::TypeID& concrete_id)
        :   mega::io::Object( objectInfo )          , p_MemoryLayout_Concrete_Dimensions_Allocation( p_MemoryLayout_Concrete_Dimensions_Allocation )
          , concrete_id( concrete_id )
    {
    }
    bool Concrete_Dimensions_Allocation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Dimensions_Allocation::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_Allocation->p_PerSourceConcreteTable_Concrete_Dimensions_Allocation = data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation >( p_MemoryLayout_Concrete_Dimensions_Allocation, this );
    }
    void Concrete_Dimensions_Allocation::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_Allocation );
        loader.load( concrete_id );
    }
    void Concrete_Dimensions_Allocation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_Allocation );
        storer.store( concrete_id );
    }
    void Concrete_Dimensions_Allocation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_Allocation" },
                { "filetype" , "PerSourceConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_id", concrete_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Context : public mega::io::Object
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( loader )
    {
    }
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Context > p_Concrete_Concrete_Context, const mega::TypeID& concrete_id)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( p_Concrete_Concrete_Context )
          , concrete_id( concrete_id )
    {
    }
    bool Concrete_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Context::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->p_PerSourceConcreteTable_Concrete_Context = data::Ptr< data::PerSourceConcreteTable::Concrete_Context >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( concrete_id );
    }
    void Concrete_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( concrete_id );
    }
    void Concrete_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Context" },
                { "filetype" , "PerSourceConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_id", concrete_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Operations
{
    // struct Invocations_Variables_Variable : public mega::io::Object
    Invocations_Variables_Variable::Invocations_Variables_Variable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Variable >( loader, this ) )    {
    }
    Invocations_Variables_Variable::Invocations_Variables_Variable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Variable >( loader, this ) )          , parent( parent )
    {
    }
    bool Invocations_Variables_Variable::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Variable >( loader, const_cast< Invocations_Variables_Variable* >( this ) ) };
    }
    void Invocations_Variables_Variable::set_inheritance_pointer()
    {
    }
    void Invocations_Variables_Variable::load( mega::io::Loader& loader )
    {
        loader.load( parent );
    }
    void Invocations_Variables_Variable::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
    }
    void Invocations_Variables_Variable::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Variable" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Variables_Instance : public mega::io::Object
    Invocations_Variables_Instance::Invocations_Variables_Instance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Instance >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
          , concrete( loader )
    {
    }
    Invocations_Variables_Instance::Invocations_Variables_Instance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& concrete)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Instance >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
          , concrete( concrete )
    {
    }
    bool Invocations_Variables_Instance::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Instance >( loader, const_cast< Invocations_Variables_Instance* >( this ) ) };
    }
    void Invocations_Variables_Instance::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Variable->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Instance >( p_Operations_Invocations_Variables_Variable, this );
    }
    void Invocations_Variables_Instance::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Variable );
        loader.load( concrete );
    }
    void Invocations_Variables_Instance::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Variable );
        storer.store( concrete );
    }
    void Invocations_Variables_Instance::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Instance" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Variables_Reference : public mega::io::Object
    Invocations_Variables_Reference::Invocations_Variables_Reference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Reference >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
    {
    }
    Invocations_Variables_Reference::Invocations_Variables_Reference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Concrete::Concrete_Context > >& types)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Reference >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
          , types( types )
    {
    }
    bool Invocations_Variables_Reference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Reference >( loader, const_cast< Invocations_Variables_Reference* >( this ) ) };
    }
    void Invocations_Variables_Reference::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Variable->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Reference >( p_Operations_Invocations_Variables_Variable, this );
    }
    void Invocations_Variables_Reference::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Variable );
        loader.load( types );
    }
    void Invocations_Variables_Reference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Variable );
        storer.store( types );
    }
    void Invocations_Variables_Reference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Reference" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "types", types } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Variables_Dimension : public mega::io::Object
    Invocations_Variables_Dimension::Invocations_Variables_Dimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Dimension >( loader, this ) )          , p_Operations_Invocations_Variables_Reference( loader )
    {
    }
    bool Invocations_Variables_Dimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Dimension >( loader, const_cast< Invocations_Variables_Dimension* >( this ) ) };
    }
    void Invocations_Variables_Dimension::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Reference->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Dimension >( p_Operations_Invocations_Variables_Reference, this );
    }
    void Invocations_Variables_Dimension::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Dimension::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Dimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Dimension" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Variables_Context : public mega::io::Object
    Invocations_Variables_Context::Invocations_Variables_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Context >( loader, this ) )          , p_Operations_Invocations_Variables_Reference( loader )
    {
    }
    bool Invocations_Variables_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Context >( loader, const_cast< Invocations_Variables_Context* >( this ) ) };
    }
    void Invocations_Variables_Context::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Reference->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Context >( p_Operations_Invocations_Variables_Reference, this );
    }
    void Invocations_Variables_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Context" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_Instruction : public mega::io::Object
    Invocations_Instructions_Instruction::Invocations_Instructions_Instruction( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Instruction >( loader, this ) )    {
    }
    bool Invocations_Instructions_Instruction::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Instruction >( loader, const_cast< Invocations_Instructions_Instruction* >( this ) ) };
    }
    void Invocations_Instructions_Instruction::set_inheritance_pointer()
    {
    }
    void Invocations_Instructions_Instruction::load( mega::io::Loader& loader )
    {
    }
    void Invocations_Instructions_Instruction::store( mega::io::Storer& storer ) const
    {
    }
    void Invocations_Instructions_Instruction::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Instruction" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_InstructionGroup : public mega::io::Object
    Invocations_Instructions_InstructionGroup::Invocations_Instructions_InstructionGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
    {
    }
    Invocations_Instructions_InstructionGroup::Invocations_Instructions_InstructionGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
          , children( children )
    {
    }
    bool Invocations_Instructions_InstructionGroup::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( loader, const_cast< Invocations_Instructions_InstructionGroup* >( this ) ) };
    }
    void Invocations_Instructions_InstructionGroup::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_Instruction->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( p_Operations_Invocations_Instructions_Instruction, this );
    }
    void Invocations_Instructions_InstructionGroup::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_Instruction );
        loader.load( children );
    }
    void Invocations_Instructions_InstructionGroup::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_Instruction );
        storer.store( children );
    }
    void Invocations_Instructions_InstructionGroup::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_InstructionGroup" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_Root : public mega::io::Object
    Invocations_Instructions_Root::Invocations_Instructions_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Root >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , context( loader )
    {
    }
    Invocations_Instructions_Root::Invocations_Instructions_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Context >& context)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Root >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , context( context )
    {
    }
    bool Invocations_Instructions_Root::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Root >( loader, const_cast< Invocations_Instructions_Root* >( this ) ) };
    }
    void Invocations_Instructions_Root::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Root >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Root::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( context );
    }
    void Invocations_Instructions_Root::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( context );
    }
    void Invocations_Instructions_Root::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Root" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_ParentDerivation : public mega::io::Object
    Invocations_Instructions_ParentDerivation::Invocations_Instructions_ParentDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_ParentDerivation::Invocations_Instructions_ParentDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& from, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( from )
          , to( to )
    {
    }
    bool Invocations_Instructions_ParentDerivation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( loader, const_cast< Invocations_Instructions_ParentDerivation* >( this ) ) };
    }
    void Invocations_Instructions_ParentDerivation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_ParentDerivation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from );
        loader.load( to );
    }
    void Invocations_Instructions_ParentDerivation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from );
        storer.store( to );
    }
    void Invocations_Instructions_ParentDerivation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_ParentDerivation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from", from } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_ChildDerivation : public mega::io::Object
    Invocations_Instructions_ChildDerivation::Invocations_Instructions_ChildDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_ChildDerivation::Invocations_Instructions_ChildDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& from, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( from )
          , to( to )
    {
    }
    bool Invocations_Instructions_ChildDerivation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( loader, const_cast< Invocations_Instructions_ChildDerivation* >( this ) ) };
    }
    void Invocations_Instructions_ChildDerivation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_ChildDerivation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from );
        loader.load( to );
    }
    void Invocations_Instructions_ChildDerivation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from );
        storer.store( to );
    }
    void Invocations_Instructions_ChildDerivation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_ChildDerivation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from", from } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_EnumDerivation : public mega::io::Object
    Invocations_Instructions_EnumDerivation::Invocations_Instructions_EnumDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_EnumDerivation::Invocations_Instructions_EnumDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& from, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( from )
          , to( to )
    {
    }
    bool Invocations_Instructions_EnumDerivation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( loader, const_cast< Invocations_Instructions_EnumDerivation* >( this ) ) };
    }
    void Invocations_Instructions_EnumDerivation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_EnumDerivation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from );
        loader.load( to );
    }
    void Invocations_Instructions_EnumDerivation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from );
        storer.store( to );
    }
    void Invocations_Instructions_EnumDerivation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_EnumDerivation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from", from } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_Enumeration : public mega::io::Object
    Invocations_Instructions_Enumeration::Invocations_Instructions_Enumeration( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( loader )
    {
    }
    Invocations_Instructions_Enumeration::Invocations_Instructions_Enumeration( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( instance )
    {
    }
    bool Invocations_Instructions_Enumeration::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( loader, const_cast< Invocations_Instructions_Enumeration* >( this ) ) };
    }
    void Invocations_Instructions_Enumeration::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Enumeration::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( instance );
    }
    void Invocations_Instructions_Enumeration::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( instance );
    }
    void Invocations_Instructions_Enumeration::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Enumeration" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_DimensionReferenceRead : public mega::io::Object
    Invocations_Instructions_DimensionReferenceRead::Invocations_Instructions_DimensionReferenceRead( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( loader )
          , dimension_reference( loader )
          , concrete( loader )
    {
    }
    Invocations_Instructions_DimensionReferenceRead::Invocations_Instructions_DimensionReferenceRead( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance, const data::Ptr< data::Operations::Invocations_Variables_Dimension >& dimension_reference, const data::Ptr< data::Concrete::Concrete_Dimensions_User >& concrete)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( instance )
          , dimension_reference( dimension_reference )
          , concrete( concrete )
    {
    }
    bool Invocations_Instructions_DimensionReferenceRead::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( loader, const_cast< Invocations_Instructions_DimensionReferenceRead* >( this ) ) };
    }
    void Invocations_Instructions_DimensionReferenceRead::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_DimensionReferenceRead::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( instance );
        loader.load( dimension_reference );
        loader.load( concrete );
    }
    void Invocations_Instructions_DimensionReferenceRead::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( instance );
        storer.store( dimension_reference );
        storer.store( concrete );
    }
    void Invocations_Instructions_DimensionReferenceRead::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_DimensionReferenceRead" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_reference", dimension_reference } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_MonoReference : public mega::io::Object
    Invocations_Instructions_MonoReference::Invocations_Instructions_MonoReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( loader )
          , instance( loader )
    {
    }
    Invocations_Instructions_MonoReference::Invocations_Instructions_MonoReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Reference >& reference, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( reference )
          , instance( instance )
    {
    }
    bool Invocations_Instructions_MonoReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( loader, const_cast< Invocations_Instructions_MonoReference* >( this ) ) };
    }
    void Invocations_Instructions_MonoReference::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_MonoReference::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( reference );
        loader.load( instance );
    }
    void Invocations_Instructions_MonoReference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( reference );
        storer.store( instance );
    }
    void Invocations_Instructions_MonoReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_MonoReference" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "reference", reference } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_PolyReference : public mega::io::Object
    Invocations_Instructions_PolyReference::Invocations_Instructions_PolyReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from_reference( loader )
    {
    }
    Invocations_Instructions_PolyReference::Invocations_Instructions_PolyReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Reference >& from_reference)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from_reference( from_reference )
    {
    }
    bool Invocations_Instructions_PolyReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( loader, const_cast< Invocations_Instructions_PolyReference* >( this ) ) };
    }
    void Invocations_Instructions_PolyReference::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_PolyReference::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from_reference );
    }
    void Invocations_Instructions_PolyReference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from_reference );
    }
    void Invocations_Instructions_PolyReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_PolyReference" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from_reference", from_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_PolyCase : public mega::io::Object
    Invocations_Instructions_PolyCase::Invocations_Instructions_PolyCase( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_PolyCase::Invocations_Instructions_PolyCase( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Reference >& reference, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( reference )
          , to( to )
    {
    }
    bool Invocations_Instructions_PolyCase::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( loader, const_cast< Invocations_Instructions_PolyCase* >( this ) ) };
    }
    void Invocations_Instructions_PolyCase::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_PolyCase::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( reference );
        loader.load( to );
    }
    void Invocations_Instructions_PolyCase::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( reference );
        storer.store( to );
    }
    void Invocations_Instructions_PolyCase::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_PolyCase" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "reference", reference } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_Failure : public mega::io::Object
    Invocations_Instructions_Failure::Invocations_Instructions_Failure( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Failure >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
    {
    }
    bool Invocations_Instructions_Failure::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Failure >( loader, const_cast< Invocations_Instructions_Failure* >( this ) ) };
    }
    void Invocations_Instructions_Failure::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Failure >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Failure::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Failure::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Failure::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Failure" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_Elimination : public mega::io::Object
    Invocations_Instructions_Elimination::Invocations_Instructions_Elimination( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Elimination >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
    {
    }
    bool Invocations_Instructions_Elimination::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Elimination >( loader, const_cast< Invocations_Instructions_Elimination* >( this ) ) };
    }
    void Invocations_Instructions_Elimination::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Elimination >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Elimination::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Elimination::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Elimination::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Elimination" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_Prune : public mega::io::Object
    Invocations_Instructions_Prune::Invocations_Instructions_Prune( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Prune >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
    {
    }
    bool Invocations_Instructions_Prune::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Prune >( loader, const_cast< Invocations_Instructions_Prune* >( this ) ) };
    }
    void Invocations_Instructions_Prune::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Prune >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Prune::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Prune::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Prune::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Prune" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Operation : public mega::io::Object
    Invocations_Operations_Operation::Invocations_Operations_Operation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Operation >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
          , instance( loader )
    {
    }
    Invocations_Operations_Operation::Invocations_Operations_Operation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance, const std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& return_types, const std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& parameter_types)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Operation >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
          , instance( instance )
          , return_types( return_types )
          , parameter_types( parameter_types )
    {
    }
    bool Invocations_Operations_Operation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Operation >( loader, const_cast< Invocations_Operations_Operation* >( this ) ) };
    }
    void Invocations_Operations_Operation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_Instruction->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Operation >( p_Operations_Invocations_Instructions_Instruction, this );
    }
    void Invocations_Operations_Operation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_Instruction );
        loader.load( instance );
        loader.load( return_types );
        loader.load( parameter_types );
    }
    void Invocations_Operations_Operation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_Instruction );
        storer.store( instance );
        storer.store( return_types );
        storer.store( parameter_types );
    }
    void Invocations_Operations_Operation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Operation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_types", return_types } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "parameter_types", parameter_types } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_BasicOperation : public mega::io::Object
    Invocations_Operations_BasicOperation::Invocations_Operations_BasicOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface( loader )
          , concrete_target( loader )
    {
    }
    Invocations_Operations_BasicOperation::Invocations_Operations_BasicOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_IContext >& interface, const data::Ptr< data::Concrete::Concrete_Context >& concrete_target)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface( interface )
          , concrete_target( concrete_target )
    {
    }
    bool Invocations_Operations_BasicOperation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( loader, const_cast< Invocations_Operations_BasicOperation* >( this ) ) };
    }
    void Invocations_Operations_BasicOperation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_Operation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( p_Operations_Invocations_Operations_Operation, this );
    }
    void Invocations_Operations_BasicOperation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_Operation );
        loader.load( interface );
        loader.load( concrete_target );
    }
    void Invocations_Operations_BasicOperation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_Operation );
        storer.store( interface );
        storer.store( concrete_target );
    }
    void Invocations_Operations_BasicOperation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_BasicOperation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface", interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_target", concrete_target } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_DimensionOperation : public mega::io::Object
    Invocations_Operations_DimensionOperation::Invocations_Operations_DimensionOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface_dimension( loader )
          , concrete_dimension( loader )
    {
    }
    Invocations_Operations_DimensionOperation::Invocations_Operations_DimensionOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_DimensionTrait >& interface_dimension, const data::Ptr< data::Concrete::Concrete_Dimensions_User >& concrete_dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface_dimension( interface_dimension )
          , concrete_dimension( concrete_dimension )
    {
    }
    bool Invocations_Operations_DimensionOperation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( loader, const_cast< Invocations_Operations_DimensionOperation* >( this ) ) };
    }
    void Invocations_Operations_DimensionOperation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_Operation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( p_Operations_Invocations_Operations_Operation, this );
    }
    void Invocations_Operations_DimensionOperation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_Operation );
        loader.load( interface_dimension );
        loader.load( concrete_dimension );
    }
    void Invocations_Operations_DimensionOperation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_Operation );
        storer.store( interface_dimension );
        storer.store( concrete_dimension );
    }
    void Invocations_Operations_DimensionOperation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_DimensionOperation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_dimension", interface_dimension } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_dimension", concrete_dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_Allocate : public mega::io::Object
    Invocations_Operations_Allocate::Invocations_Operations_Allocate( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Allocate >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Allocate::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Allocate >( loader, const_cast< Invocations_Operations_Allocate* >( this ) ) };
    }
    void Invocations_Operations_Allocate::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Allocate >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Allocate::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Allocate::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Allocate::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Allocate" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Call : public mega::io::Object
    Invocations_Operations_Call::Invocations_Operations_Call( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Call >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Call::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Call >( loader, const_cast< Invocations_Operations_Call* >( this ) ) };
    }
    void Invocations_Operations_Call::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Call >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Call::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Call::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Call::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Call" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Start : public mega::io::Object
    Invocations_Operations_Start::Invocations_Operations_Start( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Start >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Start::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Start >( loader, const_cast< Invocations_Operations_Start* >( this ) ) };
    }
    void Invocations_Operations_Start::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Start >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Start::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Start::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Start::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Start" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Stop : public mega::io::Object
    Invocations_Operations_Stop::Invocations_Operations_Stop( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Stop >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Stop::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Stop >( loader, const_cast< Invocations_Operations_Stop* >( this ) ) };
    }
    void Invocations_Operations_Stop::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Stop >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Stop::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Stop::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Stop::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Stop" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Save : public mega::io::Object
    Invocations_Operations_Save::Invocations_Operations_Save( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Save >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Save::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Save >( loader, const_cast< Invocations_Operations_Save* >( this ) ) };
    }
    void Invocations_Operations_Save::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Save >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Save::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Save::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Save::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Save" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Load : public mega::io::Object
    Invocations_Operations_Load::Invocations_Operations_Load( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Load >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Load::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Load >( loader, const_cast< Invocations_Operations_Load* >( this ) ) };
    }
    void Invocations_Operations_Load::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Load >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Load::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Load::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Load::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Load" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Files : public mega::io::Object
    Invocations_Operations_Files::Invocations_Operations_Files( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Files >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Files::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Files >( loader, const_cast< Invocations_Operations_Files* >( this ) ) };
    }
    void Invocations_Operations_Files::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Files >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Files::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Files::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Files::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Files" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_GetAction : public mega::io::Object
    Invocations_Operations_GetAction::Invocations_Operations_GetAction( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_GetAction >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_GetAction::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_GetAction >( loader, const_cast< Invocations_Operations_GetAction* >( this ) ) };
    }
    void Invocations_Operations_GetAction::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_GetAction >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_GetAction::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_GetAction::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_GetAction::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_GetAction" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_GetDimension : public mega::io::Object
    Invocations_Operations_GetDimension::Invocations_Operations_GetDimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_GetDimension >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_GetDimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_GetDimension >( loader, const_cast< Invocations_Operations_GetDimension* >( this ) ) };
    }
    void Invocations_Operations_GetDimension::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_GetDimension >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_GetDimension::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_GetDimension::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_GetDimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_GetDimension" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Read : public mega::io::Object
    Invocations_Operations_Read::Invocations_Operations_Read( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Read >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_Read::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Read >( loader, const_cast< Invocations_Operations_Read* >( this ) ) };
    }
    void Invocations_Operations_Read::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Read >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_Read::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Read::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Read::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Read" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Write : public mega::io::Object
    Invocations_Operations_Write::Invocations_Operations_Write( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Write >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_Write::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Write >( loader, const_cast< Invocations_Operations_Write* >( this ) ) };
    }
    void Invocations_Operations_Write::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Write >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_Write::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Write::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Write::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Write" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_WriteLink : public mega::io::Object
    Invocations_Operations_WriteLink::Invocations_Operations_WriteLink( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_WriteLink >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
          , dimension_reference( loader )
    {
    }
    Invocations_Operations_WriteLink::Invocations_Operations_WriteLink( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Dimension >& dimension_reference)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_WriteLink >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
          , dimension_reference( dimension_reference )
    {
    }
    bool Invocations_Operations_WriteLink::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_WriteLink >( loader, const_cast< Invocations_Operations_WriteLink* >( this ) ) };
    }
    void Invocations_Operations_WriteLink::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_WriteLink >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_WriteLink::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
        loader.load( dimension_reference );
    }
    void Invocations_Operations_WriteLink::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
        storer.store( dimension_reference );
    }
    void Invocations_Operations_WriteLink::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_WriteLink" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_reference", dimension_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_Range : public mega::io::Object
    Invocations_Operations_Range::Invocations_Operations_Range( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Range >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Range::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Range >( loader, const_cast< Invocations_Operations_Range* >( this ) ) };
    }
    void Invocations_Operations_Range::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Range >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Range::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Range::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Range::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Range" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Operations_InterfaceVariant : public mega::io::Object
    Operations_InterfaceVariant::Operations_InterfaceVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_InterfaceVariant >( loader, this ) )    {
    }
    Operations_InterfaceVariant::Operations_InterfaceVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Tree::Interface_IContext > >& context, const std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_InterfaceVariant >( loader, this ) )          , context( context )
          , dimension( dimension )
    {
    }
    bool Operations_InterfaceVariant::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >{ data::Ptr< data::Operations::Operations_InterfaceVariant >( loader, const_cast< Operations_InterfaceVariant* >( this ) ) };
    }
    void Operations_InterfaceVariant::set_inheritance_pointer()
    {
    }
    void Operations_InterfaceVariant::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( dimension );
    }
    void Operations_InterfaceVariant::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( dimension );
    }
    void Operations_InterfaceVariant::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_InterfaceVariant" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_ConcreteVariant : public mega::io::Object
    Operations_ConcreteVariant::Operations_ConcreteVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ConcreteVariant >( loader, this ) )    {
    }
    Operations_ConcreteVariant::Operations_ConcreteVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Concrete::Concrete_Context > >& context, const std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ConcreteVariant >( loader, this ) )          , context( context )
          , dimension( dimension )
    {
    }
    bool Operations_ConcreteVariant::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >{ data::Ptr< data::Operations::Operations_ConcreteVariant >( loader, const_cast< Operations_ConcreteVariant* >( this ) ) };
    }
    void Operations_ConcreteVariant::set_inheritance_pointer()
    {
    }
    void Operations_ConcreteVariant::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( dimension );
    }
    void Operations_ConcreteVariant::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( dimension );
    }
    void Operations_ConcreteVariant::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_ConcreteVariant" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Element : public mega::io::Object
    Operations_Element::Operations_Element( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Element >( loader, this ) )          , interface( loader )
          , concrete( loader )
    {
    }
    Operations_Element::Operations_Element( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_InterfaceVariant >& interface, const data::Ptr< data::Operations::Operations_ConcreteVariant >& concrete)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Element >( loader, this ) )          , interface( interface )
          , concrete( concrete )
    {
    }
    bool Operations_Element::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Element > >{ data::Ptr< data::Operations::Operations_Element >( loader, const_cast< Operations_Element* >( this ) ) };
    }
    void Operations_Element::set_inheritance_pointer()
    {
    }
    void Operations_Element::load( mega::io::Loader& loader )
    {
        loader.load( interface );
        loader.load( concrete );
    }
    void Operations_Element::store( mega::io::Storer& storer ) const
    {
        storer.store( interface );
        storer.store( concrete );
    }
    void Operations_Element::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Element" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface", interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_ElementVector : public mega::io::Object
    Operations_ElementVector::Operations_ElementVector( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ElementVector >( loader, this ) )    {
    }
    Operations_ElementVector::Operations_ElementVector( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_Element > >& elements)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ElementVector >( loader, this ) )          , elements( elements )
    {
    }
    bool Operations_ElementVector::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_ElementVector > >{ data::Ptr< data::Operations::Operations_ElementVector >( loader, const_cast< Operations_ElementVector* >( this ) ) };
    }
    void Operations_ElementVector::set_inheritance_pointer()
    {
    }
    void Operations_ElementVector::load( mega::io::Loader& loader )
    {
        loader.load( elements );
    }
    void Operations_ElementVector::store( mega::io::Storer& storer ) const
    {
        storer.store( elements );
    }
    void Operations_ElementVector::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_ElementVector" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "elements", elements } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Context : public mega::io::Object
    Operations_Context::Operations_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Context >( loader, this ) )    {
    }
    Operations_Context::Operations_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& vectors)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Context >( loader, this ) )          , vectors( vectors )
    {
    }
    bool Operations_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Context > >{ data::Ptr< data::Operations::Operations_Context >( loader, const_cast< Operations_Context* >( this ) ) };
    }
    void Operations_Context::set_inheritance_pointer()
    {
    }
    void Operations_Context::load( mega::io::Loader& loader )
    {
        loader.load( vectors );
    }
    void Operations_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( vectors );
    }
    void Operations_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Context" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "vectors", vectors } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_TypePath : public mega::io::Object
    Operations_TypePath::Operations_TypePath( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_TypePath >( loader, this ) )    {
    }
    Operations_TypePath::Operations_TypePath( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& vectors)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_TypePath >( loader, this ) )          , vectors( vectors )
    {
    }
    bool Operations_TypePath::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_TypePath > >{ data::Ptr< data::Operations::Operations_TypePath >( loader, const_cast< Operations_TypePath* >( this ) ) };
    }
    void Operations_TypePath::set_inheritance_pointer()
    {
    }
    void Operations_TypePath::load( mega::io::Loader& loader )
    {
        loader.load( vectors );
    }
    void Operations_TypePath::store( mega::io::Storer& storer ) const
    {
        storer.store( vectors );
    }
    void Operations_TypePath::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_TypePath" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "vectors", vectors } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_NameRoot : public mega::io::Object
    Operations_NameRoot::Operations_NameRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameRoot >( loader, this ) )    {
    }
    Operations_NameRoot::Operations_NameRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_Name > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameRoot >( loader, this ) )          , children( children )
    {
    }
    bool Operations_NameRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >{ data::Ptr< data::Operations::Operations_NameRoot >( loader, const_cast< Operations_NameRoot* >( this ) ) };
    }
    void Operations_NameRoot::set_inheritance_pointer()
    {
    }
    void Operations_NameRoot::load( mega::io::Loader& loader )
    {
        loader.load( children );
    }
    void Operations_NameRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( children );
    }
    void Operations_NameRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_NameRoot" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Name : public mega::io::Object
    Operations_Name::Operations_Name( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Name >( loader, this ) )          , p_Operations_Operations_NameRoot( loader )
          , element( loader )
    {
    }
    Operations_Name::Operations_Name( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_Element >& element, const bool& is_member, const bool& is_reference)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Name >( loader, this ) )          , p_Operations_Operations_NameRoot( loader )
          , element( element )
          , is_member( is_member )
          , is_reference( is_reference )
    {
    }
    bool Operations_Name::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >{ data::Ptr< data::Operations::Operations_Name >( loader, const_cast< Operations_Name* >( this ) ) };
    }
    void Operations_Name::set_inheritance_pointer()
    {
        p_Operations_Operations_NameRoot->m_inheritance = data::Ptr< data::Operations::Operations_Name >( p_Operations_Operations_NameRoot, this );
    }
    void Operations_Name::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Operations_NameRoot );
        loader.load( element );
        loader.load( is_member );
        loader.load( is_reference );
    }
    void Operations_Name::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Operations_NameRoot );
        storer.store( element );
        storer.store( is_member );
        storer.store( is_reference );
    }
    void Operations_Name::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Name" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "element", element } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_member", is_member } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_reference", is_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_NameResolution : public mega::io::Object
    Operations_NameResolution::Operations_NameResolution( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameResolution >( loader, this ) )          , root_name( loader )
    {
    }
    Operations_NameResolution::Operations_NameResolution( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_NameRoot >& root_name)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameResolution >( loader, this ) )          , root_name( root_name )
    {
    }
    bool Operations_NameResolution::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_NameResolution > >{ data::Ptr< data::Operations::Operations_NameResolution >( loader, const_cast< Operations_NameResolution* >( this ) ) };
    }
    void Operations_NameResolution::set_inheritance_pointer()
    {
    }
    void Operations_NameResolution::load( mega::io::Loader& loader )
    {
        loader.load( root_name );
    }
    void Operations_NameResolution::store( mega::io::Storer& storer ) const
    {
        storer.store( root_name );
    }
    void Operations_NameResolution::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_NameResolution" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "root_name", root_name } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Invocation : public mega::io::Object
    Operations_Invocation::Operations_Invocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocation >( loader, this ) )          , context( loader )
          , type_path( loader )
          , name_resolution( loader )
          , root_instruction( loader )
    {
    }
    Operations_Invocation::Operations_Invocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_Context >& context, const data::Ptr< data::Operations::Operations_TypePath >& type_path, const mega::OperationID& operation, const std::string& name, const std::string& context_str, const std::string& type_path_str, const std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& variables)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocation >( loader, this ) )          , context( context )
          , type_path( type_path )
          , operation( operation )
          , name( name )
          , context_str( context_str )
          , type_path_str( type_path_str )
          , variables( variables )
    {
    }
    bool Operations_Invocation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Invocation > >{ data::Ptr< data::Operations::Operations_Invocation >( loader, const_cast< Operations_Invocation* >( this ) ) };
    }
    void Operations_Invocation::set_inheritance_pointer()
    {
    }
    void Operations_Invocation::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( type_path );
        loader.load( operation );
        loader.load( name );
        loader.load( context_str );
        loader.load( type_path_str );
        loader.load( explicit_operation );
        loader.load( return_type_str );
        loader.load( runtime_return_type_str );
        loader.load( name_resolution );
        loader.load( root_instruction );
        loader.load( variables );
        loader.load( return_types_context );
        loader.load( return_types_dimension );
        loader.load( homogeneous );
        loader.load( is_function_call );
    }
    void Operations_Invocation::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( type_path );
        storer.store( operation );
        storer.store( name );
        storer.store( context_str );
        storer.store( type_path_str );
        VERIFY_RTE_MSG( explicit_operation.has_value(), "Operations::Operations_Invocation.explicit_operation has NOT been set" );
        storer.store( explicit_operation );
        VERIFY_RTE_MSG( return_type_str.has_value(), "Operations::Operations_Invocation.return_type_str has NOT been set" );
        storer.store( return_type_str );
        VERIFY_RTE_MSG( runtime_return_type_str.has_value(), "Operations::Operations_Invocation.runtime_return_type_str has NOT been set" );
        storer.store( runtime_return_type_str );
        VERIFY_RTE_MSG( name_resolution.has_value(), "Operations::Operations_Invocation.name_resolution has NOT been set" );
        storer.store( name_resolution );
        VERIFY_RTE_MSG( root_instruction.has_value(), "Operations::Operations_Invocation.root_instruction has NOT been set" );
        storer.store( root_instruction );
        storer.store( variables );
        VERIFY_RTE_MSG( return_types_context.has_value(), "Operations::Operations_Invocation.return_types_context has NOT been set" );
        storer.store( return_types_context );
        VERIFY_RTE_MSG( return_types_dimension.has_value(), "Operations::Operations_Invocation.return_types_dimension has NOT been set" );
        storer.store( return_types_dimension );
        VERIFY_RTE_MSG( homogeneous.has_value(), "Operations::Operations_Invocation.homogeneous has NOT been set" );
        storer.store( homogeneous );
        VERIFY_RTE_MSG( is_function_call.has_value(), "Operations::Operations_Invocation.is_function_call has NOT been set" );
        storer.store( is_function_call );
    }
    void Operations_Invocation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Invocation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type_path", type_path } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "operation", operation } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "name", name } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context_str", context_str } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type_path_str", type_path_str } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "explicit_operation", explicit_operation.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_type_str", return_type_str.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "runtime_return_type_str", runtime_return_type_str.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "name_resolution", name_resolution.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "root_instruction", root_instruction.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "variables", variables } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_types_context", return_types_context.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_types_dimension", return_types_dimension.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "homogeneous", homogeneous.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_function_call", is_function_call.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Invocations : public mega::io::Object
    Operations_Invocations::Operations_Invocations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocations >( loader, this ) )    {
    }
    Operations_Invocations::Operations_Invocations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& invocations)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocations >( loader, this ) )          , invocations( invocations )
    {
    }
    bool Operations_Invocations::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Invocations > >{ data::Ptr< data::Operations::Operations_Invocations >( loader, const_cast< Operations_Invocations* >( this ) ) };
    }
    void Operations_Invocations::set_inheritance_pointer()
    {
    }
    void Operations_Invocations::load( mega::io::Loader& loader )
    {
        loader.load( invocations );
    }
    void Operations_Invocations::store( mega::io::Storer& storer ) const
    {
        storer.store( invocations );
    }
    void Operations_Invocations::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Invocations" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "invocations", invocations } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}

std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& get_abstract_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_abstract_defs" );
            return part->abstract_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ActionDef > >& get_action_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_action_defs" );
            return part->action_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_alignment(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_alignment(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_alignment" );
            return part->alignment;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& get_alignment(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_alignment" );
            return part->alignment;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_allocated_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Nothing >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Singleton >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range32 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range64 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_RangeAny >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocated_context" );
            return part->allocated_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& get_allocation_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& get_allocation_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocation_dimensions" );
            return part->allocation_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& get_allocator(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& get_allocator(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ArgumentList >& get_argumentList(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_FunctionDef > part = 
                data::convert< data::AST::Parser_FunctionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_argumentList" );
            return part->argumentList;
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& get_arguments_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_arguments_trait" );
            return part->arguments_trait;
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ContextDef >& get_ast(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ContextDef >& operator()( data::Ptr< data::AST::Parser_SourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ast" );
            return part->ast;
        }
        data::Ptr< data::AST::Parser_ContextDef >& operator()( data::Ptr< data::AST::Parser_IncludeRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ast" );
            return part->ast;
        }
        data::Ptr< data::AST::Parser_ContextDef >& operator()( data::Ptr< data::AST::Parser_ObjectSourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ast" );
            return part->ast;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_body(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_body" );
            return part->body;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& get_buffer(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_buffer" );
            return part->buffer;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_BufferDef > >& get_buffer_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Buffer > part = 
                data::convert< data::Tree::Interface_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_buffer_defs" );
            return part->buffer_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& get_buffers(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Object > part = 
                data::convert< data::MemoryLayout::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_buffers" );
            return part->buffers;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& get_build_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_build_dir" );
            return part->build_dir;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_canonical_type(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_canonical_type" );
            return part->canonical_type;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_canonical_type(std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Tree::Interface_ReturnTypeTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_ReturnTypeTrait > part = 
                data::convert< data::Clang::Interface_ReturnTypeTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_canonical_type" );
            return part->canonical_type;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_ReturnType >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& get_canonical_types(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_ArgumentListTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_ArgumentListTrait > part = 
                data::convert< data::Clang::Interface_ArgumentListTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_canonical_types" );
            return part->canonical_types;
        }
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_ArgumentList >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::CardinalityRange& get_cardinality(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    struct Visitor
    {
        mega::CardinalityRange& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cardinality" );
            return part->cardinality;
        }
        mega::CardinalityRange& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::CardinalityRange& get_cardinality(std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >& m_data)
{
    struct Visitor
    {
        mega::CardinalityRange& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cardinality" );
            return part->cardinality;
        }
        mega::CardinalityRange& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cardinality" );
            return part->cardinality;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& get_children(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& get_children(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& get_children(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Name > >& get_children(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_Name > >& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameRoot > part = 
                data::convert< data::Operations::Operations_NameRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Operations_Name > >& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameRoot > part = 
                data::convert< data::Operations::Operations_NameRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_children(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Components::Components_Component >& get_component(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::AST::Parser_SourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::AST::Parser_IncludeRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::AST::Parser_ObjectSourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Components::Components_Component >& get_component(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Components::Components_Component >& get_component(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_component" );
            return part->component;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_concrete(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceDerivations::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& get_concrete(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_concrete(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Instance > part = 
                data::convert< data::Operations::Invocations_Variables_Instance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_ConcreteVariant >& get_concrete(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_ConcreteVariant >& operator()( data::Ptr< data::Operations::Operations_Element >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Element > part = 
                data::convert< data::Operations::Operations_Element >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& get_concrete(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete" );
            return part->concrete;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& get_concrete_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_concrete_id(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_concrete_id(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_User > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_concrete_id(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_concrete_id(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_id" );
            return part->concrete_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_concrete_target(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_target" );
            return part->concrete_target;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& get_concrete_type_id_seq_alloc(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_type_id_seq_alloc" );
            return part->concrete_type_id_seq_alloc;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& get_concrete_type_id_sequences(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_type_id_sequences" );
            return part->concrete_type_id_sequences;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& get_concrete_type_id_set_link(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_type_id_set_link" );
            return part->concrete_type_id_set_link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& get_concrete_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_concrete_type_ids" );
            return part->concrete_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& get_context(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_context(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Context >& get_context(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_Root > part = 
                data::convert< data::Operations::Invocations_Instructions_Root >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& get_context(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Operations_ConcreteVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                data::convert< data::Operations::Operations_ConcreteVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_IContext > >& get_context(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Operations::Operations_InterfaceVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                data::convert< data::Operations::Operations_InterfaceVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_Context >& get_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_Context >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_IContext > >& get_context(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_context_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_context_str" );
            return part->context_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_contexts(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_InheritanceTrait > part = 
                data::convert< data::Clang::Interface_InheritanceTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_contexts" );
            return part->contexts;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_contexts(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_contexts" );
            return part->contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& get_cppSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_CPPInclude > part = 
                data::convert< data::AST::Parser_CPPInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cppSourceFilePath" );
            return part->cppSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& get_cpp_defines(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cpp_defines" );
            return part->cpp_defines;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& get_cpp_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cpp_dependencies" );
            return part->cpp_dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& get_cpp_flags(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cpp_flags" );
            return part->cpp_flags;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::cppFilePath >& get_cpp_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::cppFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_cpp_source_files" );
            return part->cpp_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dependency > >& get_dependencies(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& get_dependencies(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dependencies" );
            return part->dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::DerivationDirection& get_derivation(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    struct Visitor
    {
        mega::DerivationDirection& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_derivation" );
            return part->derivation;
        }
        mega::DerivationDirection& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::DerivationDirection& get_derivation(std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >& m_data)
{
    struct Visitor
    {
        mega::DerivationDirection& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_derivation" );
            return part->derivation;
        }
        mega::DerivationDirection& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_derivation" );
            return part->derivation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& get_dim_allocation(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dim_allocation" );
            return part->dim_allocation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& get_dim_link(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dim_link" );
            return part->dim_link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_dim_user(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dim_user" );
            return part->dim_user;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& get_dimension(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    struct Visitor
    {
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Nothing >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Singleton >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range32 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range64 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_RangeAny >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_dimension(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Operations::Operations_ConcreteVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                data::convert< data::Operations::Operations_ConcreteVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& get_dimension(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::Operations::Operations_InterfaceVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                data::convert< data::Operations::Operations_InterfaceVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& get_dimension(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Dimension >& get_dimension_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_reference" );
            return part->dimension_reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_WriteLink > part = 
                data::convert< data::Operations::Invocations_Operations_WriteLink >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_reference" );
            return part->dimension_reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& get_dimension_traits(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Buffer > part = 
                data::convert< data::Tree::Interface_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dimension > >& get_dimensions(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Namespace > part = 
                data::convert< data::Concrete::Concrete_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Action > part = 
                data::convert< data::Concrete::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Event > part = 
                data::convert< data::Concrete::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Object > part = 
                data::convert< data::Concrete::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Buffer > part = 
                data::convert< data::Concrete::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& get_dimensions(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_dimensions" );
            return part->dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_Element >& get_element(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_Element >& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Name > part = 
                data::convert< data::Operations::Operations_Name >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_element" );
            return part->element;
        }
        data::Ptr< data::Operations::Operations_Element >& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Element > >& get_elements(std::variant< data::Ptr< data::Operations::Operations_ElementVector > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_Element > >& operator()( data::Ptr< data::Operations::Operations_ElementVector >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ElementVector > part = 
                data::convert< data::Operations::Operations_ElementVector >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_elements" );
            return part->elements;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_EventDef > >& get_event_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_event_defs" );
            return part->event_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::ExplicitOperationID >& get_explicit_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::ExplicitOperationID >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_explicit_operation" );
            return part->explicit_operation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::ComponentFilePath& get_file_path(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        mega::io::ComponentFilePath& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_file_path" );
            return part->file_path;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& get_from(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_from" );
            return part->from;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_from" );
            return part->from;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_from" );
            return part->from;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& get_from_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_PolyReference > part = 
                data::convert< data::Operations::Invocations_Instructions_PolyReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_from_reference" );
            return part->from_reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& get_function_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_function_defs" );
            return part->function_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_glob(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::DPGraph::Dependencies_Glob >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                data::convert< data::DPGraph::Dependencies_Glob >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_glob" );
            return part->glob;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& get_globs(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_globs" );
            return part->globs;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_hash_code(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_hash_code" );
            return part->hash_code;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_hash_code(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_hash_code" );
            return part->hash_code;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_hash_code(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_hash_code" );
            return part->hash_code;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< bool >& get_homogeneous(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< bool >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_homogeneous" );
            return part->homogeneous;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& get_id(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Identifier >& get_id(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Identifier >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_Identifier >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Identifier >& get_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Identifier >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_Identifier >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& get_id(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaIncludeNested > part = 
                data::convert< data::AST::Parser_MegaIncludeNested >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_id(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_id(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_id(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_identifier(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_identifier" );
            return part->identifier;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Identifier > >& get_ids(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Identifier > >& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ids" );
            return part->ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< boost::filesystem::path >& get_include_directories(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< boost::filesystem::path >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_include_directories" );
            return part->include_directories;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Include > >& get_includes(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_includes" );
            return part->includes;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& get_inheritance(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_AbstractDef > part = 
                data::convert< data::AST::Parser_AbstractDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ActionDef > part = 
                data::convert< data::AST::Parser_ActionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_EventDef > part = 
                data::convert< data::AST::Parser_EventDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ObjectDef > part = 
                data::convert< data::AST::Parser_ObjectDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_inheritance(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& get_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_contexts" );
            return part->inheritance_contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& get_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_contexts" );
            return part->inheritance_contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_dimensions" );
            return part->inheritance_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_dimensions" );
            return part->inheritance_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& get_inheritance_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& get_instance(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_Enumeration > part = 
                data::convert< data::Operations::Invocations_Instructions_Enumeration >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_instance" );
            return part->instance;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_IContext >& get_interface(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_IContext >& get_interface(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_InterfaceVariant >& get_interface(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_InterfaceVariant >& operator()( data::Ptr< data::Operations::Operations_Element >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Element > part = 
                data::convert< data::Operations::Operations_Element >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface" );
            return part->interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Action >& get_interface_action(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Action > part = 
                data::convert< data::Concrete::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_action" );
            return part->interface_action;
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Buffer >& get_interface_buffer(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Buffer > part = 
                data::convert< data::Concrete::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_buffer" );
            return part->interface_buffer;
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& get_interface_dimension(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_dimension" );
            return part->interface_dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& get_interface_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Event >& get_interface_event(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Event > part = 
                data::convert< data::Concrete::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_event" );
            return part->interface_event;
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Function >& get_interface_function(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Function > part = 
                data::convert< data::Concrete::Concrete_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_function" );
            return part->interface_function;
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_interface_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_interface_id(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_id" );
            return part->interface_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Namespace >& get_interface_namespace(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Namespace > part = 
                data::convert< data::Concrete::Concrete_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_namespace" );
            return part->interface_namespace;
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Object >& get_interface_object(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Object > part = 
                data::convert< data::Concrete::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_object" );
            return part->interface_object;
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Root >& get_interface_root(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Root > part = 
                data::convert< data::Concrete::Concrete_Root >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_root" );
            return part->interface_root;
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& get_interface_type_id_sequences(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_type_id_sequences" );
            return part->interface_type_id_sequences;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& get_interface_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_interface_type_ids" );
            return part->interface_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& get_invocations(std::variant< data::Ptr< data::Operations::Operations_Invocations > >& m_data)
{
    struct Visitor
    {
        std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& operator()( data::Ptr< data::Operations::Operations_Invocations >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocations > part = 
                data::convert< data::Operations::Operations_Invocations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_invocations" );
            return part->invocations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& get_isConst(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_isConst" );
            return part->isConst;
        }
        bool& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& get_isConst(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_isConst" );
            return part->isConst;
        }
        bool& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_isConst" );
            return part->isConst;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< bool >& get_is_function_call(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< bool >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_is_function_call" );
            return part->is_function_call;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& get_is_global(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_is_global" );
            return part->is_global;
        }
        bool& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& get_is_member(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Name > part = 
                data::convert< data::Operations::Operations_Name >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_is_member" );
            return part->is_member;
        }
        bool& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& get_is_reference(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Name > part = 
                data::convert< data::Operations::Operations_Name >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_is_reference" );
            return part->is_reference;
        }
        bool& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_line_number(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_line_number" );
            return part->line_number;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Link >& get_link(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Link > part = 
                data::convert< data::Concrete::Concrete_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link" );
            return part->link;
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Link >& get_link(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Link >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link" );
            return part->link;
        }
        data::Ptr< data::Concrete::Concrete_Link >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link" );
            return part->link;
        }
        data::Ptr< data::Concrete::Concrete_Link >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link" );
            return part->link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_LinkDef > >& get_link_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_defs" );
            return part->link_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_defs" );
            return part->link_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& get_link_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_dimensions" );
            return part->link_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_LinkInterface >& get_link_interface(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterfaceDef > part = 
                data::convert< data::AST::Parser_LinkInterfaceDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_interface" );
            return part->link_interface;
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& get_link_reference(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                data::convert< data::MemoryLayout::Concrete_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_reference" );
            return part->link_reference;
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& get_link_target(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_target" );
            return part->link_target;
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_target" );
            return part->link_target;
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& get_link_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_LinkInterface > part = 
                data::convert< data::Tree::Interface_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_link_trait" );
            return part->link_trait;
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_local_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                data::convert< data::MemoryLayout::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_local_size" );
            return part->local_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                data::convert< data::MemoryLayout::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_local_size" );
            return part->local_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& get_location(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::DPGraph::Dependencies_Glob >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                data::convert< data::DPGraph::Dependencies_Glob >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_location" );
            return part->location;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& get_mappings(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_mappings" );
            return part->mappings;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& get_megaSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_megaSourceFilePath" );
            return part->megaSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_megaSourceFilePath" );
            return part->megaSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_megaSourceFilePath" );
            return part->megaSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& get_mega_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_mega_dependencies" );
            return part->mega_dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& get_mega_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_mega_source_files" );
            return part->mega_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& get_mega_source_files(std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > part = 
                data::convert< data::DPGraph::Dependencies_TransitiveDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_mega_source_files" );
            return part->mega_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_name(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_name" );
            return part->name;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_name(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_name" );
            return part->name;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Operations::Operations_NameResolution > >& get_name_resolution(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Operations::Operations_NameResolution > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_name_resolution" );
            return part->name_resolution;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& get_namespace_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_namespace_defs" );
            return part->namespace_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& get_object_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_object_defs" );
            return part->object_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& get_objects(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_objects" );
            return part->objects;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_offset(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_User > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& get_offset(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& get_offset(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& get_offset(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::OperationID& get_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        mega::OperationID& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_operation" );
            return part->operation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::Ownership& get_ownership(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    struct Visitor
    {
        mega::Ownership& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ownership" );
            return part->ownership;
        }
        mega::Ownership& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::Ownership& get_ownership(std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >& m_data)
{
    struct Visitor
    {
        mega::Ownership& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ownership" );
            return part->ownership;
        }
        mega::Ownership& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_ownership" );
            return part->ownership;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& get_parameter_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parameter_types" );
            return part->parameter_types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_IContext >& get_parent(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Tree::Interface_DimensionTrait > part = 
                data::convert< data::Tree::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_ContextGroup >& get_parent(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_parent(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_parent(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_parent(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& get_parent(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_ContextGroup >& get_parent(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& get_parent_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Nothing >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Singleton >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range32 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range64 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_RangeAny >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parent_context" );
            return part->parent_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::MemoryLayout_Part >& get_part(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::MemoryLayout_Part >& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_User > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_part" );
            return part->part;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& get_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_part" );
            return part->part;
        }
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_part" );
            return part->part;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& get_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_part" );
            return part->part;
        }
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_part" );
            return part->part;
        }
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_part" );
            return part->part;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& get_parts(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_parts" );
            return part->parts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& get_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_reference" );
            return part->reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_reference" );
            return part->reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Model::HyperGraph_Relation >& get_relation(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceModel::Interface_Link > part = 
                data::convert< data::PerSourceModel::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_relation" );
            return part->relation;
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceModel::Interface_Link > part = 
                data::convert< data::PerSourceModel::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_relation" );
            return part->relation;
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& get_relations(std::variant< data::Ptr< data::Model::HyperGraph_Graph > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& operator()( data::Ptr< data::Model::HyperGraph_Graph >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Graph > part = 
                data::convert< data::Model::HyperGraph_Graph >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_relations" );
            return part->relations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& get_relations(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_relations" );
            return part->relations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< boost::filesystem::path >& get_resolution(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< boost::filesystem::path >& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_resolution" );
            return part->resolution;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ReturnType >& get_returnType(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_FunctionDef > part = 
                data::convert< data::AST::Parser_FunctionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_returnType" );
            return part->returnType;
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::string >& get_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::string >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_type_str" );
            return part->return_type_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& get_return_type_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_type_trait" );
            return part->return_type_trait;
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& get_return_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types" );
            return part->return_types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& get_return_types_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types_context" );
            return part->return_types_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& get_return_types_dimension(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_return_types_dimension" );
            return part->return_types_dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& get_root(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_root" );
            return part->root;
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_root" );
            return part->root;
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_root" );
            return part->root;
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ObjectSourceRoot >& get_root(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Root > part = 
                data::convert< data::Tree::Interface_Root >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_root" );
            return part->root;
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >& get_root_instruction(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_root_instruction" );
            return part->root_instruction;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_NameRoot >& get_root_name(std::variant< data::Ptr< data::Operations::Operations_NameResolution > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_NameRoot >& operator()( data::Ptr< data::Operations::Operations_NameResolution >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameResolution > part = 
                data::convert< data::Operations::Operations_NameResolution >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_root_name" );
            return part->root_name;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::string >& get_runtime_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::string >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_runtime_return_type_str" );
            return part->runtime_return_type_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& get_simple(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_simple" );
            return part->simple;
        }
        bool& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Size >& get_size(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ActionDef > part = 
                data::convert< data::AST::Parser_ActionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_EventDef > part = 
                data::convert< data::AST::Parser_EventDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_size(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_size(std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Tree::Interface_SizeTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_SizeTrait > part = 
                data::convert< data::Clang::Interface_SizeTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::AST::Parser_Size >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_size(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& get_size(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size" );
            return part->size;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& get_size_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size_trait" );
            return part->size_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_size_trait" );
            return part->size_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Link >& get_source(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_source" );
            return part->source;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& get_sourceFile(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_SourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_sourceFile" );
            return part->sourceFile;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_IncludeRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_sourceFile" );
            return part->sourceFile;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_ObjectSourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_sourceFile" );
            return part->sourceFile;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_source_file(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        mega::io::megaFilePath& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        mega::io::megaFilePath& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        mega::io::megaFilePath& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& get_source_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_LinkInterface >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_source_interface" );
            return part->source_interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& get_src_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_src_dir" );
            return part->src_dir;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ArgumentList > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ArgumentList >& arg ) const
        {
            data::Ptr< data::AST::Parser_ArgumentList > part = 
                data::convert< data::AST::Parser_ArgumentList >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ArgumentListTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ArgumentList >& arg ) const
        {
            data::Ptr< data::AST::Parser_ArgumentList > part = 
                data::convert< data::AST::Parser_ArgumentList >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ArgumentListTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_ArgumentList > part = 
                data::convert< data::AST::Parser_ArgumentList >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Dependency > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Dependency >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dependency > part = 
                data::convert< data::AST::Parser_Dependency >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Identifier > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Identifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_Identifier > part = 
                data::convert< data::AST::Parser_Identifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_SystemInclude > part = 
                data::convert< data::AST::Parser_SystemInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ReturnType > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ReturnType >& arg ) const
        {
            data::Ptr< data::AST::Parser_ReturnType > part = 
                data::convert< data::AST::Parser_ReturnType >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ReturnTypeTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ReturnType >& arg ) const
        {
            data::Ptr< data::AST::Parser_ReturnType > part = 
                data::convert< data::AST::Parser_ReturnType >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ReturnTypeTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_ReturnType > part = 
                data::convert< data::AST::Parser_ReturnType >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Size > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Size >& arg ) const
        {
            data::Ptr< data::AST::Parser_Size > part = 
                data::convert< data::AST::Parser_Size >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_SizeTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Size >& arg ) const
        {
            data::Ptr< data::AST::Parser_Size > part = 
                data::convert< data::AST::Parser_Size >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_SizeTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_Size > part = 
                data::convert< data::AST::Parser_Size >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& get_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            data::Ptr< data::AST::Parser_Inheritance > part = 
                data::convert< data::AST::Parser_Inheritance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_strings" );
            return part->strings;
        }
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& get_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            data::Ptr< data::AST::Parser_Inheritance > part = 
                data::convert< data::AST::Parser_Inheritance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_strings" );
            return part->strings;
        }
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_Inheritance > part = 
                data::convert< data::AST::Parser_Inheritance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_strings" );
            return part->strings;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_symbol(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol" );
            return part->symbol;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_symbol_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& get_symbol_id(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_id" );
            return part->symbol_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeIDSequence& get_symbol_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeIDSequence& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_ids" );
            return part->symbol_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& get_symbol_names(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_names" );
            return part->symbol_names;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& get_symbol_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbol_type_ids" );
            return part->symbol_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& get_symbols(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_symbols" );
            return part->symbols;
        }
        std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& get_target(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkDef > part = 
                data::convert< data::AST::Parser_LinkDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_target" );
            return part->target;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkDef > part = 
                data::convert< data::AST::Parser_LinkDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_target" );
            return part->target;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Link >& get_target(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_target" );
            return part->target;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& get_target_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_LinkInterface >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_target_interface" );
            return part->target_interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& get_to(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_total_domain_size(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_total_domain_size" );
            return part->total_domain_size;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& get_total_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                data::convert< data::MemoryLayout::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                data::convert< data::MemoryLayout::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                data::convert< data::MemoryLayout::Concrete_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Buffer > part = 
                data::convert< data::MemoryLayout::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_type(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_type" );
            return part->type;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_type(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_type" );
            return part->type;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_type" );
            return part->type;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::ComponentType& get_type(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        mega::ComponentType& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_type" );
            return part->type;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_TypePath >& get_type_path(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_TypePath >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_type_path" );
            return part->type_path;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& get_type_path_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_type_path_str" );
            return part->type_path_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& get_types(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_types" );
            return part->types;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_types" );
            return part->types;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_types" );
            return part->types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_user_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_user_dimensions" );
            return part->user_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& get_variables(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_variables" );
            return part->variables;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& get_vectors(std::variant< data::Ptr< data::Operations::Operations_Context > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& operator()( data::Ptr< data::Operations::Operations_Context >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Context > part = 
                data::convert< data::Operations::Operations_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_vectors" );
            return part->vectors;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& get_vectors(std::variant< data::Ptr< data::Operations::Operations_TypePath > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& operator()( data::Ptr< data::Operations::Operations_TypePath >& arg ) const
        {
            data::Ptr< data::Operations::Operations_TypePath > part = 
                data::convert< data::Operations::Operations_TypePath >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: get_vectors" );
            return part->vectors;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& insert_concrete_type_id_seq_alloc(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_concrete_type_id_seq_alloc" );
            return part->concrete_type_id_seq_alloc;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& insert_concrete_type_id_sequences(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_concrete_type_id_sequences" );
            return part->concrete_type_id_sequences;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& insert_concrete_type_id_set_link(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_concrete_type_id_set_link" );
            return part->concrete_type_id_set_link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& insert_concrete_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_concrete_type_ids" );
            return part->concrete_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& insert_cpp_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_cpp_dependencies" );
            return part->cpp_dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& insert_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_inheritance_contexts" );
            return part->inheritance_contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& insert_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_inheritance_contexts" );
            return part->inheritance_contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& insert_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_inheritance_dimensions" );
            return part->inheritance_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& insert_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_inheritance_dimensions" );
            return part->inheritance_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& insert_interface_type_id_sequences(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_interface_type_id_sequences" );
            return part->interface_type_id_sequences;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& insert_interface_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_interface_type_ids" );
            return part->interface_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& insert_invocations(std::variant< data::Ptr< data::Operations::Operations_Invocations > >& m_data)
{
    struct Visitor
    {
        std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& operator()( data::Ptr< data::Operations::Operations_Invocations >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocations > part = 
                data::convert< data::Operations::Operations_Invocations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_invocations" );
            return part->invocations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& insert_mega_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_mega_dependencies" );
            return part->mega_dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& insert_relations(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_relations" );
            return part->relations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& insert_symbol_names(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_symbol_names" );
            return part->symbol_names;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& insert_symbol_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: insert_symbol_type_ids" );
            return part->symbol_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& push_back_abstract_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_abstract_defs" );
            return part->abstract_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ActionDef > >& push_back_action_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_action_defs" );
            return part->action_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& push_back_allocation_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& push_back_allocation_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_allocation_dimensions" );
            return part->allocation_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_BufferDef > >& push_back_buffer_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Buffer > part = 
                data::convert< data::Tree::Interface_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_buffer_defs" );
            return part->buffer_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& push_back_buffers(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Object > part = 
                data::convert< data::MemoryLayout::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_buffers" );
            return part->buffers;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& push_back_canonical_types(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_ArgumentListTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_ArgumentListTrait > part = 
                data::convert< data::Clang::Interface_ArgumentListTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_canonical_types" );
            return part->canonical_types;
        }
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_ArgumentList >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& push_back_children(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& push_back_children(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& push_back_children(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Name > >& push_back_children(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_Name > >& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameRoot > part = 
                data::convert< data::Operations::Operations_NameRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Operations_Name > >& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameRoot > part = 
                data::convert< data::Operations::Operations_NameRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_children(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& push_back_concrete(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceDerivations::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& push_back_concrete(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_concrete" );
            return part->concrete;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_contexts(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_InheritanceTrait > part = 
                data::convert< data::Clang::Interface_InheritanceTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_contexts" );
            return part->contexts;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_contexts(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_contexts" );
            return part->contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& push_back_cpp_defines(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_cpp_defines" );
            return part->cpp_defines;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& push_back_cpp_flags(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_cpp_flags" );
            return part->cpp_flags;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::cppFilePath >& push_back_cpp_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::cppFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_cpp_source_files" );
            return part->cpp_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dependency > >& push_back_dependencies(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& push_back_dependencies(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dependencies" );
            return part->dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& push_back_dimension_traits(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Buffer > part = 
                data::convert< data::Tree::Interface_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dimension > >& push_back_dimensions(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& push_back_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Namespace > part = 
                data::convert< data::Concrete::Concrete_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Action > part = 
                data::convert< data::Concrete::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Event > part = 
                data::convert< data::Concrete::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Object > part = 
                data::convert< data::Concrete::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Buffer > part = 
                data::convert< data::Concrete::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& push_back_dimensions(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_dimensions" );
            return part->dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Element > >& push_back_elements(std::variant< data::Ptr< data::Operations::Operations_ElementVector > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_Element > >& operator()( data::Ptr< data::Operations::Operations_ElementVector >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ElementVector > part = 
                data::convert< data::Operations::Operations_ElementVector >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_elements" );
            return part->elements;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_EventDef > >& push_back_event_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_event_defs" );
            return part->event_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& push_back_function_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_function_defs" );
            return part->function_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& push_back_globs(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_globs" );
            return part->globs;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Identifier > >& push_back_ids(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Identifier > >& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_ids" );
            return part->ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< boost::filesystem::path >& push_back_include_directories(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< boost::filesystem::path >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_include_directories" );
            return part->include_directories;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Include > >& push_back_includes(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_includes" );
            return part->includes;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_inheritance(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_LinkDef > >& push_back_link_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_link_defs" );
            return part->link_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_link_defs" );
            return part->link_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& push_back_link_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_link_dimensions" );
            return part->link_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& push_back_mappings(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_mappings" );
            return part->mappings;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& push_back_mega_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_mega_source_files" );
            return part->mega_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& push_back_mega_source_files(std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > part = 
                data::convert< data::DPGraph::Dependencies_TransitiveDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_mega_source_files" );
            return part->mega_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& push_back_namespace_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_namespace_defs" );
            return part->namespace_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& push_back_object_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_object_defs" );
            return part->object_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& push_back_objects(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_objects" );
            return part->objects;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& push_back_parameter_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parameter_types" );
            return part->parameter_types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& push_back_parts(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_parts" );
            return part->parts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& push_back_relations(std::variant< data::Ptr< data::Model::HyperGraph_Graph > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& operator()( data::Ptr< data::Model::HyperGraph_Graph >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Graph > part = 
                data::convert< data::Model::HyperGraph_Graph >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_relations" );
            return part->relations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< boost::filesystem::path >& push_back_resolution(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< boost::filesystem::path >& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_resolution" );
            return part->resolution;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& push_back_return_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types" );
            return part->return_types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& push_back_return_types_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types_context" );
            return part->return_types_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& push_back_return_types_dimension(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_return_types_dimension" );
            return part->return_types_dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& push_back_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            data::Ptr< data::AST::Parser_Inheritance > part = 
                data::convert< data::AST::Parser_Inheritance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_strings" );
            return part->strings;
        }
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& push_back_symbols(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_symbols" );
            return part->symbols;
        }
        std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& push_back_types(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_types" );
            return part->types;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_types" );
            return part->types;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_types" );
            return part->types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& push_back_user_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_user_dimensions" );
            return part->user_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& push_back_variables(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_variables" );
            return part->variables;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& push_back_vectors(std::variant< data::Ptr< data::Operations::Operations_Context > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& operator()( data::Ptr< data::Operations::Operations_Context >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Context > part = 
                data::convert< data::Operations::Operations_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_vectors" );
            return part->vectors;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& push_back_vectors(std::variant< data::Ptr< data::Operations::Operations_TypePath > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& operator()( data::Ptr< data::Operations::Operations_TypePath >& arg ) const
        {
            data::Ptr< data::Operations::Operations_TypePath > part = 
                data::convert< data::Operations::Operations_TypePath >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: push_back_vectors" );
            return part->vectors;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& set_abstract_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_abstract_defs" );
            return part->abstract_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ActionDef > >& set_action_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_action_defs" );
            return part->action_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ActionDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_alignment(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_alignment(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_alignment" );
            return part->alignment;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_alignment" );
            return part->alignment;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& set_alignment(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_alignment" );
            return part->alignment;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_allocated_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Nothing >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Singleton >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range32 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range64 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Allocators_RangeAny >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocated_context" );
            return part->allocated_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& set_allocation_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& set_allocation_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocation_dimensions" );
            return part->allocation_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& set_allocator(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                data::convert< data::MemoryLayout::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& set_allocator(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_allocator" );
            return part->allocator;
        }
        data::Ptr< data::MemoryLayout::Allocators_Allocator >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ArgumentList >& set_argumentList(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_FunctionDef > part = 
                data::convert< data::AST::Parser_FunctionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_argumentList" );
            return part->argumentList;
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ArgumentList >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& set_arguments_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_arguments_trait" );
            return part->arguments_trait;
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ContextDef >& set_ast(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ContextDef >& operator()( data::Ptr< data::AST::Parser_SourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_ast" );
            return part->ast;
        }
        data::Ptr< data::AST::Parser_ContextDef >& operator()( data::Ptr< data::AST::Parser_IncludeRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_ast" );
            return part->ast;
        }
        data::Ptr< data::AST::Parser_ContextDef >& operator()( data::Ptr< data::AST::Parser_ObjectSourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_ast" );
            return part->ast;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_body(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::Body::Parser_ContextDef > part = 
                data::convert< data::Body::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_body" );
            return part->body;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& set_buffer(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_buffer" );
            return part->buffer;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_BufferDef > >& set_buffer_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Buffer > part = 
                data::convert< data::Tree::Interface_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_buffer_defs" );
            return part->buffer_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_BufferDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& set_buffers(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Object > part = 
                data::convert< data::MemoryLayout::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_buffers" );
            return part->buffers;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& set_build_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_build_dir" );
            return part->build_dir;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_canonical_type(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_canonical_type" );
            return part->canonical_type;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_canonical_type(std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Tree::Interface_ReturnTypeTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_ReturnTypeTrait > part = 
                data::convert< data::Clang::Interface_ReturnTypeTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_canonical_type" );
            return part->canonical_type;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_ReturnType >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& set_canonical_types(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_ArgumentListTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_ArgumentListTrait > part = 
                data::convert< data::Clang::Interface_ArgumentListTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_canonical_types" );
            return part->canonical_types;
        }
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_ArgumentList >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::CardinalityRange& set_cardinality(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    struct Visitor
    {
        mega::CardinalityRange& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_cardinality" );
            return part->cardinality;
        }
        mega::CardinalityRange& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& set_children(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& set_children(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                data::convert< data::Concrete::Concrete_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& set_children(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Name > >& set_children(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_Name > >& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameRoot > part = 
                data::convert< data::Operations::Operations_NameRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Operations::Operations_Name > >& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameRoot > part = 
                data::convert< data::Operations::Operations_NameRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_children(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_ContextGroup > part = 
                data::convert< data::Tree::Interface_ContextGroup >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_children" );
            return part->children;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Components::Components_Component >& set_component(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::AST::Parser_SourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::AST::Parser_IncludeRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::AST::Parser_ObjectSourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Components::Components_Component >& set_component(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Components::Components_Component >& set_component(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
        data::Ptr< data::Components::Components_Component >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_component" );
            return part->component;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_concrete(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceDerivations::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& set_concrete(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_concrete(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Instance > part = 
                data::convert< data::Operations::Invocations_Variables_Instance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_ConcreteVariant >& set_concrete(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_ConcreteVariant >& operator()( data::Ptr< data::Operations::Operations_Element >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Element > part = 
                data::convert< data::Operations::Operations_Element >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& set_concrete(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete" );
            return part->concrete;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& set_concrete_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_dimension" );
            return part->concrete_dimension;
        }
        data::Ptr< data::Concrete::Concrete_Dimensions_User >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_concrete_id(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_concrete_id(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_User > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_concrete_id(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_concrete_id(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
        mega::TypeID& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::PerSourceConcreteTable::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_id" );
            return part->concrete_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_concrete_target(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_target" );
            return part->concrete_target;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& set_concrete_type_id_seq_alloc(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_type_id_seq_alloc" );
            return part->concrete_type_id_seq_alloc;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& set_concrete_type_id_sequences(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_type_id_sequences" );
            return part->concrete_type_id_sequences;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& set_concrete_type_id_set_link(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequencePair, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_type_id_set_link" );
            return part->concrete_type_id_set_link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& set_concrete_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_concrete_type_ids" );
            return part->concrete_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& set_context(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_context(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Context >& set_context(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_Root > part = 
                data::convert< data::Operations::Invocations_Instructions_Root >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Context >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& set_context(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Operations_ConcreteVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                data::convert< data::Operations::Operations_ConcreteVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_IContext > >& set_context(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Operations::Operations_InterfaceVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                data::convert< data::Operations::Operations_InterfaceVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_Context >& set_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_Context >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_IContext > >& set_context(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context" );
            return part->context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_context_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_context_str" );
            return part->context_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_contexts(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_InheritanceTrait > part = 
                data::convert< data::Clang::Interface_InheritanceTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_contexts" );
            return part->contexts;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_contexts(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_contexts" );
            return part->contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& set_cppSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_CPPInclude > part = 
                data::convert< data::AST::Parser_CPPInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_cppSourceFilePath" );
            return part->cppSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& set_cpp_defines(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_cpp_defines" );
            return part->cpp_defines;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& set_cpp_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_cpp_dependencies" );
            return part->cpp_dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& set_cpp_flags(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_cpp_flags" );
            return part->cpp_flags;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::cppFilePath >& set_cpp_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::cppFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_cpp_source_files" );
            return part->cpp_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dependency > >& set_dependencies(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
        std::vector< data::Ptr< data::AST::Parser_Dependency > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& set_dependencies(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dependencies" );
            return part->dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::DerivationDirection& set_derivation(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    struct Visitor
    {
        mega::DerivationDirection& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_derivation" );
            return part->derivation;
        }
        mega::DerivationDirection& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& set_dim_allocation(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dim_allocation" );
            return part->dim_allocation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& set_dim_link(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dim_link" );
            return part->dim_link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_dim_user(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dim_user" );
            return part->dim_user;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& set_dimension(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    struct Visitor
    {
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Nothing >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Singleton >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range32 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range64 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
        std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& operator()( data::Ptr< data::MemoryLayout::Allocators_RangeAny >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_dimension(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Operations::Operations_ConcreteVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                data::convert< data::Operations::Operations_ConcreteVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& set_dimension(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::Operations::Operations_InterfaceVariant >& arg ) const
        {
            data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                data::convert< data::Operations::Operations_InterfaceVariant >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& set_dimension(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension" );
            return part->dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Dimension >& set_dimension_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_reference" );
            return part->dimension_reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_WriteLink > part = 
                data::convert< data::Operations::Invocations_Operations_WriteLink >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_reference" );
            return part->dimension_reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Dimension >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& set_dimension_traits(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Buffer > part = 
                data::convert< data::Tree::Interface_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimension_traits" );
            return part->dimension_traits;
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dimension > >& set_dimensions(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::AST::Parser_Dimension > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Namespace > part = 
                data::convert< data::Concrete::Concrete_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Action > part = 
                data::convert< data::Concrete::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Event > part = 
                data::convert< data::Concrete::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Object > part = 
                data::convert< data::Concrete::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Buffer > part = 
                data::convert< data::Concrete::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& set_dimensions(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_dimensions" );
            return part->dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_Element >& set_element(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_Element >& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Name > part = 
                data::convert< data::Operations::Operations_Name >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_element" );
            return part->element;
        }
        data::Ptr< data::Operations::Operations_Element >& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Element > >& set_elements(std::variant< data::Ptr< data::Operations::Operations_ElementVector > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_Element > >& operator()( data::Ptr< data::Operations::Operations_ElementVector >& arg ) const
        {
            data::Ptr< data::Operations::Operations_ElementVector > part = 
                data::convert< data::Operations::Operations_ElementVector >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_elements" );
            return part->elements;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_EventDef > >& set_event_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_event_defs" );
            return part->event_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_EventDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::ExplicitOperationID >& set_explicit_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::ExplicitOperationID >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_explicit_operation" );
            return part->explicit_operation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::ComponentFilePath& set_file_path(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        mega::io::ComponentFilePath& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_file_path" );
            return part->file_path;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& set_from(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_from" );
            return part->from;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_from" );
            return part->from;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_from" );
            return part->from;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& set_from_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_PolyReference > part = 
                data::convert< data::Operations::Invocations_Instructions_PolyReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_from_reference" );
            return part->from_reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& set_function_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_function_defs" );
            return part->function_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_glob(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::DPGraph::Dependencies_Glob >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                data::convert< data::DPGraph::Dependencies_Glob >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_glob" );
            return part->glob;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& set_globs(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_globs" );
            return part->globs;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_hash_code(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_hash_code" );
            return part->hash_code;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_hash_code(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_hash_code" );
            return part->hash_code;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_hash_code(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_hash_code" );
            return part->hash_code;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< bool >& set_homogeneous(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< bool >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_homogeneous" );
            return part->homogeneous;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& set_id(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Identifier >& set_id(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Identifier >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_Identifier >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& set_id(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaIncludeNested > part = 
                data::convert< data::AST::Parser_MegaIncludeNested >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ScopedIdentifier >& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_id(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID >& arg ) const
        {
            data::Ptr< data::ConcreteTable::Symbols_ConcreteTypeID > part = 
                data::convert< data::ConcreteTable::Symbols_ConcreteTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_id(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_id(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_id" );
            return part->id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_identifier(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_identifier" );
            return part->identifier;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Identifier > >& set_ids(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Identifier > >& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_ids" );
            return part->ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< boost::filesystem::path >& set_include_directories(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< boost::filesystem::path >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_include_directories" );
            return part->include_directories;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_Include > >& set_includes(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
        std::vector< data::Ptr< data::AST::Parser_Include > >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ContextDef > part = 
                data::convert< data::AST::Parser_ContextDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_includes" );
            return part->includes;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& set_inheritance(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_AbstractDef > part = 
                data::convert< data::AST::Parser_AbstractDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ActionDef > part = 
                data::convert< data::AST::Parser_ActionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_EventDef > part = 
                data::convert< data::AST::Parser_EventDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ObjectDef > part = 
                data::convert< data::AST::Parser_ObjectDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_inheritance(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance" );
            return part->inheritance;
        }
        std::vector< data::Ptr< data::Tree::Interface_IContext > >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& set_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_contexts" );
            return part->inheritance_contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& set_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_contexts" );
            return part->inheritance_contexts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_dimensions" );
            return part->inheritance_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_dimensions" );
            return part->inheritance_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& set_inheritance_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Abstract > part = 
                data::convert< data::Tree::Interface_Abstract >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_inheritance_trait" );
            return part->inheritance_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& set_instance(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_Enumeration > part = 
                data::convert< data::Operations::Invocations_Instructions_Enumeration >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_instance" );
            return part->instance;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_IContext >& set_interface(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_IContext >& set_interface(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_InterfaceVariant >& set_interface(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_InterfaceVariant >& operator()( data::Ptr< data::Operations::Operations_Element >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Element > part = 
                data::convert< data::Operations::Operations_Element >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface" );
            return part->interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Action >& set_interface_action(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Action > part = 
                data::convert< data::Concrete::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_action" );
            return part->interface_action;
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Action >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Buffer >& set_interface_buffer(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Buffer > part = 
                data::convert< data::Concrete::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_buffer" );
            return part->interface_buffer;
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Buffer >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& set_interface_dimension(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_dimension" );
            return part->interface_dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& set_interface_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_dimension" );
            return part->interface_dimension;
        }
        data::Ptr< data::Tree::Interface_DimensionTrait >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Event >& set_interface_event(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Event > part = 
                data::convert< data::Concrete::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_event" );
            return part->interface_event;
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Event >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Function >& set_interface_function(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Function > part = 
                data::convert< data::Concrete::Concrete_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_function" );
            return part->interface_function;
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Function >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_interface_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_interface_id(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_id" );
            return part->interface_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Namespace >& set_interface_namespace(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Namespace > part = 
                data::convert< data::Concrete::Concrete_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_namespace" );
            return part->interface_namespace;
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Namespace >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Object >& set_interface_object(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Object > part = 
                data::convert< data::Concrete::Concrete_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_object" );
            return part->interface_object;
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Object >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Root >& set_interface_root(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Root > part = 
                data::convert< data::Concrete::Concrete_Root >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_root" );
            return part->interface_root;
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Root >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& set_interface_type_id_sequences(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeIDSequence, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_type_id_sequences" );
            return part->interface_type_id_sequences;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& set_interface_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_interface_type_ids" );
            return part->interface_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& set_invocations(std::variant< data::Ptr< data::Operations::Operations_Invocations > >& m_data)
{
    struct Visitor
    {
        std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& operator()( data::Ptr< data::Operations::Operations_Invocations >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocations > part = 
                data::convert< data::Operations::Operations_Invocations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_invocations" );
            return part->invocations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& set_isConst(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_isConst" );
            return part->isConst;
        }
        bool& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< bool >& set_is_function_call(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< bool >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_is_function_call" );
            return part->is_function_call;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& set_is_global(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_is_global" );
            return part->is_global;
        }
        bool& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        bool& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& set_is_member(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Name > part = 
                data::convert< data::Operations::Operations_Name >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_is_member" );
            return part->is_member;
        }
        bool& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& set_is_reference(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Operations::Operations_Name >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Name > part = 
                data::convert< data::Operations::Operations_Name >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_is_reference" );
            return part->is_reference;
        }
        bool& operator()( data::Ptr< data::Operations::Operations_NameRoot >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_line_number(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_line_number" );
            return part->line_number;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Link >& set_link(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Link > part = 
                data::convert< data::Concrete::Concrete_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link" );
            return part->link;
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Link >& set_link(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Link >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link" );
            return part->link;
        }
        data::Ptr< data::Concrete::Concrete_Link >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link" );
            return part->link;
        }
        data::Ptr< data::Concrete::Concrete_Link >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link" );
            return part->link;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_LinkDef > >& set_link_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_defs" );
            return part->link_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_defs" );
            return part->link_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_LinkDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& set_link_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_dimensions" );
            return part->link_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_LinkInterface >& set_link_interface(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterfaceDef > part = 
                data::convert< data::AST::Parser_LinkInterfaceDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_interface" );
            return part->link_interface;
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_LinkInterface >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& set_link_reference(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                data::convert< data::MemoryLayout::Concrete_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_reference" );
            return part->link_reference;
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& set_link_target(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_target" );
            return part->link_target;
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Link > part = 
                data::convert< data::Tree::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_target" );
            return part->link_target;
        }
        std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& set_link_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_LinkInterface > part = 
                data::convert< data::Tree::Interface_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_link_trait" );
            return part->link_trait;
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_local_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                data::convert< data::MemoryLayout::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_local_size" );
            return part->local_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                data::convert< data::MemoryLayout::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_local_size" );
            return part->local_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& set_location(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::DPGraph::Dependencies_Glob >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                data::convert< data::DPGraph::Dependencies_Glob >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_location" );
            return part->location;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& set_mappings(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& operator()( data::Ptr< data::Derivations::Derivation_Mapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_Mapping > part = 
                data::convert< data::Derivations::Derivation_Mapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_mappings" );
            return part->mappings;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& set_megaSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_megaSourceFilePath" );
            return part->megaSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_megaSourceFilePath" );
            return part->megaSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_megaSourceFilePath" );
            return part->megaSourceFilePath;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& set_mega_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_mega_dependencies" );
            return part->mega_dependencies;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& set_mega_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_mega_source_files" );
            return part->mega_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< mega::io::megaFilePath >& set_mega_source_files(std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< mega::io::megaFilePath >& operator()( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > part = 
                data::convert< data::DPGraph::Dependencies_TransitiveDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_mega_source_files" );
            return part->mega_source_files;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_name(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_name" );
            return part->name;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_name(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_name" );
            return part->name;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Operations::Operations_NameResolution > >& set_name_resolution(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Operations::Operations_NameResolution > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_name_resolution" );
            return part->name_resolution;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& set_namespace_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Namespace > part = 
                data::convert< data::Tree::Interface_Namespace >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_namespace_defs" );
            return part->namespace_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ContextDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& set_object_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Object > part = 
                data::convert< data::Tree::Interface_Object >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_object_defs" );
            return part->object_defs;
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& set_objects(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& operator()( data::Ptr< data::DPGraph::Dependencies_Analysis >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                data::convert< data::DPGraph::Dependencies_Analysis >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_objects" );
            return part->objects;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_offset(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_User > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& set_offset(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& set_offset(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& set_offset(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_offset" );
            return part->offset;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::OperationID& set_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        mega::OperationID& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_operation" );
            return part->operation;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::Ownership& set_ownership(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    struct Visitor
    {
        mega::Ownership& operator()( data::Ptr< data::AST::Parser_LinkInterface >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkInterface > part = 
                data::convert< data::AST::Parser_LinkInterface >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_ownership" );
            return part->ownership;
        }
        mega::Ownership& operator()( data::Ptr< data::Tree::Interface_LinkTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& set_parameter_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parameter_types" );
            return part->parameter_types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_IContext >& set_parent(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Tree::Interface_DimensionTrait > part = 
                data::convert< data::Tree::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_IContext >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_ContextGroup >& set_parent(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Context > part = 
                data::convert< data::Concrete::Concrete_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_ContextGroup >& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_parent(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_parent(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_parent(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Concrete::Concrete_Context >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& set_parent(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                data::convert< data::Operations::Invocations_Variables_Variable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_ContextGroup >& set_parent(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
        data::Ptr< data::Tree::Interface_ContextGroup >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::Tree::Interface_IContext > part = 
                data::convert< data::Tree::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent" );
            return part->parent;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& set_parent_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Nothing >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Singleton >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range32 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_Range64 >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
        std::optional< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::MemoryLayout::Allocators_RangeAny >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parent_context" );
            return part->parent_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::MemoryLayout::MemoryLayout_Part >& set_part(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::MemoryLayout::MemoryLayout_Part >& operator()( data::Ptr< data::Concrete::Concrete_Dimensions_User >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_User > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_User >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_part" );
            return part->part;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& set_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_part" );
            return part->part;
        }
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_part" );
            return part->part;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& set_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_part" );
            return part->part;
        }
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_part" );
            return part->part;
        }
        std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_part" );
            return part->part;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& set_parts(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parts" );
            return part->parts;
        }
        std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_parts" );
            return part->parts;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& set_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_reference" );
            return part->reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_reference" );
            return part->reference;
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Reference >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Model::HyperGraph_Relation >& set_relation(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceModel::Interface_Link > part = 
                data::convert< data::PerSourceModel::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_relation" );
            return part->relation;
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceModel::Interface_Link > part = 
                data::convert< data::PerSourceModel::Interface_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_relation" );
            return part->relation;
        }
        data::Ptr< data::Model::HyperGraph_Relation >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& set_relations(std::variant< data::Ptr< data::Model::HyperGraph_Graph > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& operator()( data::Ptr< data::Model::HyperGraph_Graph >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Graph > part = 
                data::convert< data::Model::HyperGraph_Graph >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_relations" );
            return part->relations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& set_relations(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_relations" );
            return part->relations;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< boost::filesystem::path >& set_resolution(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        std::vector< boost::filesystem::path >& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_resolution" );
            return part->resolution;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ReturnType >& set_returnType(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_FunctionDef > part = 
                data::convert< data::AST::Parser_FunctionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_returnType" );
            return part->returnType;
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ReturnType >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::string >& set_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::string >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_type_str" );
            return part->return_type_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& set_return_type_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Function > part = 
                data::convert< data::Tree::Interface_Function >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_type_trait" );
            return part->return_type_trait;
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& set_return_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
        std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                data::convert< data::Operations::Invocations_Operations_Operation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types" );
            return part->return_types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& set_return_types_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types_context" );
            return part->return_types_context;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& set_return_types_dimension(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_return_types_dimension" );
            return part->return_types_dimension;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& set_root(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_root" );
            return part->root;
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_root" );
            return part->root;
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            data::Ptr< data::AST::Parser_MegaInclude > part = 
                data::convert< data::AST::Parser_MegaInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_root" );
            return part->root;
        }
        std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_ObjectSourceRoot >& set_root(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Root > part = 
                data::convert< data::Tree::Interface_Root >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_root" );
            return part->root;
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_ObjectSourceRoot >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >& set_root_instruction(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_root_instruction" );
            return part->root_instruction;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_NameRoot >& set_root_name(std::variant< data::Ptr< data::Operations::Operations_NameResolution > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_NameRoot >& operator()( data::Ptr< data::Operations::Operations_NameResolution >& arg ) const
        {
            data::Ptr< data::Operations::Operations_NameResolution > part = 
                data::convert< data::Operations::Operations_NameResolution >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_root_name" );
            return part->root_name;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::string >& set_runtime_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::optional< std::string >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_runtime_return_type_str" );
            return part->runtime_return_type_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
bool& set_simple(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        bool& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_simple" );
            return part->simple;
        }
        bool& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Size >& set_size(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_ActionDef > part = 
                data::convert< data::AST::Parser_ActionDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_EventDef > part = 
                data::convert< data::AST::Parser_EventDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Size >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_size(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_size(std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Tree::Interface_SizeTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_SizeTrait > part = 
                data::convert< data::Clang::Interface_SizeTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::AST::Parser_Size >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_size(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< mega::U64 >& set_size(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::optional< mega::U64 >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size" );
            return part->size;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& set_size_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Action > part = 
                data::convert< data::Tree::Interface_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size_trait" );
            return part->size_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::Tree::Interface_Event > part = 
                data::convert< data::Tree::Interface_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_size_trait" );
            return part->size_trait;
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Link >& set_source(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_source" );
            return part->source;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& set_sourceFile(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_SourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_sourceFile" );
            return part->sourceFile;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_IncludeRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_sourceFile" );
            return part->sourceFile;
        }
        boost::filesystem::path& operator()( data::Ptr< data::AST::Parser_ObjectSourceRoot >& arg ) const
        {
            data::Ptr< data::AST::Parser_SourceRoot > part = 
                data::convert< data::AST::Parser_SourceRoot >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_sourceFile" );
            return part->sourceFile;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_source_file(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ScopedIdentifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                data::convert< data::AST::Parser_ScopedIdentifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    struct Visitor
    {
        mega::io::megaFilePath& operator()( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >& arg ) const
        {
            data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    struct Visitor
    {
        mega::io::megaFilePath& operator()( data::Ptr< data::Derivations::Derivation_ObjectMapping >& arg ) const
        {
            data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    struct Visitor
    {
        mega::io::megaFilePath& operator()( data::Ptr< data::Model::HyperGraph_Relations >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relations > part = 
                data::convert< data::Model::HyperGraph_Relations >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_source_file" );
            return part->source_file;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& set_source_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_LinkInterface >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_source_interface" );
            return part->source_interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
boost::filesystem::path& set_src_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        boost::filesystem::path& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_src_dir" );
            return part->src_dir;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_ArgumentList > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ArgumentList >& arg ) const
        {
            data::Ptr< data::AST::Parser_ArgumentList > part = 
                data::convert< data::AST::Parser_ArgumentList >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ArgumentListTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Dependency > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Dependency >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dependency > part = 
                data::convert< data::AST::Parser_Dependency >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Identifier > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Identifier >& arg ) const
        {
            data::Ptr< data::AST::Parser_Identifier > part = 
                data::convert< data::AST::Parser_Identifier >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_str" );
            return part->str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_SystemInclude >& arg ) const
        {
            data::Ptr< data::AST::Parser_SystemInclude > part = 
                data::convert< data::AST::Parser_SystemInclude >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::AST::Parser_Include >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MegaInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MegaIncludeInline >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_MegaIncludeNested >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::string& operator()( data::Ptr< data::AST::Parser_CPPInclude >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_ReturnType > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_ReturnType >& arg ) const
        {
            data::Ptr< data::AST::Parser_ReturnType > part = 
                data::convert< data::AST::Parser_ReturnType >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_ReturnTypeTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Size > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Size >& arg ) const
        {
            data::Ptr< data::AST::Parser_Size > part = 
                data::convert< data::AST::Parser_Size >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_str" );
            return part->str;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_SizeTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< std::string >& set_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance > >& m_data)
{
    struct Visitor
    {
        std::vector< std::string >& operator()( data::Ptr< data::AST::Parser_Inheritance >& arg ) const
        {
            data::Ptr< data::AST::Parser_Inheritance > part = 
                data::convert< data::AST::Parser_Inheritance >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_strings" );
            return part->strings;
        }
        std::vector< std::string >& operator()( data::Ptr< data::Tree::Interface_InheritanceTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_symbol(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol" );
            return part->symbol;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_symbol_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeID& set_symbol_id(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    struct Visitor
    {
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_IContext >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Namespace >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Abstract >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Action >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Event >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Function >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Object >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Link >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_LinkInterface >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
        mega::TypeID& operator()( data::Ptr< data::Tree::Interface_Buffer >& arg ) const
        {
            data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_id" );
            return part->symbol_id;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::TypeIDSequence& set_symbol_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > >& m_data)
{
    struct Visitor
    {
        mega::TypeIDSequence& operator()( data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_InterfaceTypeID > part = 
                data::convert< data::SymbolTable::Symbols_InterfaceTypeID >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_ids" );
            return part->symbol_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& set_symbol_names(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< std::string, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_names" );
            return part->symbol_names;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& set_symbol_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    struct Visitor
    {
        std::map< mega::TypeID, data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::SymbolTable::Symbols_SymbolTable >& arg ) const
        {
            data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbol_type_ids" );
            return part->symbol_type_ids;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& set_symbols(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                data::convert< data::Clang::Interface_DimensionTrait >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_symbols" );
            return part->symbols;
        }
        std::vector< data::Ptr< data::SymbolTable::Symbols_SymbolTypeID > >& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& set_target(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkDef > part = 
                data::convert< data::AST::Parser_LinkDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_target" );
            return part->target;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ContextDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_NamespaceDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_AbstractDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ActionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_EventDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_FunctionDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_ObjectDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_LinkInterfaceDef >& arg ) const
        {
            data::Ptr< data::AST::Parser_LinkDef > part = 
                data::convert< data::AST::Parser_LinkDef >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_target" );
            return part->target;
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_BufferDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::AST::Parser_Inheritance >& operator()( data::Ptr< data::AST::Parser_MetaDef >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_Link >& set_target(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_Link >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_target" );
            return part->target;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& set_target_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Tree::Interface_LinkInterface >& operator()( data::Ptr< data::Model::HyperGraph_Relation >& arg ) const
        {
            data::Ptr< data::Model::HyperGraph_Relation > part = 
                data::convert< data::Model::HyperGraph_Relation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_target_interface" );
            return part->target_interface;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& set_to(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Save >, data::Ptr< data::Operations::Invocations_Operations_Load >, data::Ptr< data::Operations::Invocations_Operations_Files >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_to" );
            return part->to;
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Instruction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Failure >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Elimination >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Instructions_Prune >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Operation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Allocate >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Call >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Start >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Stop >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Save >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Load >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Files >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetAction >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_GetDimension >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Read >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Write >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_WriteLink >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        data::Ptr< data::Operations::Invocations_Variables_Instance >& operator()( data::Ptr< data::Operations::Invocations_Operations_Range >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_total_domain_size(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_total_domain_size" );
            return part->total_domain_size;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::U64& set_total_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    struct Visitor
    {
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Action >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                data::convert< data::MemoryLayout::Concrete_Action >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Event >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                data::convert< data::MemoryLayout::Concrete_Event >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Link >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                data::convert< data::MemoryLayout::Concrete_Link >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Buffer >& arg ) const
        {
            data::Ptr< data::MemoryLayout::Concrete_Buffer > part = 
                data::convert< data::MemoryLayout::Concrete_Buffer >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_total_size" );
            return part->total_size;
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_ContextGroup >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Context >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Namespace >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Function >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Object >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        mega::U64& operator()( data::Ptr< data::Concrete::Concrete_Root >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_type(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::AST::Parser_Dimension >& arg ) const
        {
            data::Ptr< data::AST::Parser_Dimension > part = 
                data::convert< data::AST::Parser_Dimension >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_type" );
            return part->type;
        }
        std::string& operator()( data::Ptr< data::Tree::Interface_DimensionTrait >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
    }visitor;
    return std::visit( visitor, m_data );
}
mega::ComponentType& set_type(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    struct Visitor
    {
        mega::ComponentType& operator()( data::Ptr< data::Components::Components_Component >& arg ) const
        {
            data::Ptr< data::Components::Components_Component > part = 
                data::convert< data::Components::Components_Component >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_type" );
            return part->type;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
data::Ptr< data::Operations::Operations_TypePath >& set_type_path(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        data::Ptr< data::Operations::Operations_TypePath >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_type_path" );
            return part->type_path;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::string& set_type_path_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::string& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_type_path_str" );
            return part->type_path_str;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& set_types(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Reference >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_types" );
            return part->types;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Variable >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Instance >& arg ) const
        {
            THROW_RTE( "Database used with incorrect type" );
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Dimension >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_types" );
            return part->types;
        }
        std::vector< data::Ptr< data::Concrete::Concrete_Context > >& operator()( data::Ptr< data::Operations::Invocations_Variables_Context >& arg ) const
        {
            data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                data::convert< data::Operations::Invocations_Variables_Reference >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_types" );
            return part->types;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_user_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& operator()( data::Ptr< data::MemoryLayout::MemoryLayout_Part >& arg ) const
        {
            data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_user_dimensions" );
            return part->user_dimensions;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& set_variables(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > >& operator()( data::Ptr< data::Operations::Operations_Invocation >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Invocation > part = 
                data::convert< data::Operations::Operations_Invocation >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_variables" );
            return part->variables;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& set_vectors(std::variant< data::Ptr< data::Operations::Operations_Context > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& operator()( data::Ptr< data::Operations::Operations_Context >& arg ) const
        {
            data::Ptr< data::Operations::Operations_Context > part = 
                data::convert< data::Operations::Operations_Context >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_vectors" );
            return part->vectors;
        }
    }visitor;
    return std::visit( visitor, m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& set_vectors(std::variant< data::Ptr< data::Operations::Operations_TypePath > >& m_data)
{
    struct Visitor
    {
        std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& operator()( data::Ptr< data::Operations::Operations_TypePath >& arg ) const
        {
            data::Ptr< data::Operations::Operations_TypePath > part = 
                data::convert< data::Operations::Operations_TypePath >( arg );
            VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                "Invalid data reference in: set_vectors" );
            return part->vectors;
        }
    }visitor;
    return std::visit( visitor, m_data );
}

mega::io::Object* Factory::create( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
{
    switch( objectInfo.getType() )
    {
        case 0: return new Components::Components_Component( loader, objectInfo );
        case 1: return new AST::Parser_Identifier( loader, objectInfo );
        case 2: return new AST::Parser_ScopedIdentifier( loader, objectInfo );
        case 3: return new AST::Parser_ArgumentList( loader, objectInfo );
        case 4: return new AST::Parser_ReturnType( loader, objectInfo );
        case 5: return new AST::Parser_Inheritance( loader, objectInfo );
        case 6: return new AST::Parser_Size( loader, objectInfo );
        case 7: return new AST::Parser_LinkInterface( loader, objectInfo );
        case 8: return new AST::Parser_Dimension( loader, objectInfo );
        case 9: return new AST::Parser_Include( loader, objectInfo );
        case 10: return new AST::Parser_SystemInclude( loader, objectInfo );
        case 11: return new AST::Parser_MegaInclude( loader, objectInfo );
        case 12: return new AST::Parser_MegaIncludeInline( loader, objectInfo );
        case 13: return new AST::Parser_MegaIncludeNested( loader, objectInfo );
        case 14: return new AST::Parser_CPPInclude( loader, objectInfo );
        case 15: return new AST::Parser_Dependency( loader, objectInfo );
        case 16: return new AST::Parser_ContextDef( loader, objectInfo );
        case 18: return new AST::Parser_NamespaceDef( loader, objectInfo );
        case 19: return new AST::Parser_AbstractDef( loader, objectInfo );
        case 20: return new AST::Parser_ActionDef( loader, objectInfo );
        case 21: return new AST::Parser_EventDef( loader, objectInfo );
        case 22: return new AST::Parser_FunctionDef( loader, objectInfo );
        case 23: return new AST::Parser_ObjectDef( loader, objectInfo );
        case 24: return new AST::Parser_LinkDef( loader, objectInfo );
        case 25: return new AST::Parser_LinkInterfaceDef( loader, objectInfo );
        case 26: return new AST::Parser_BufferDef( loader, objectInfo );
        case 27: return new AST::Parser_MetaDef( loader, objectInfo );
        case 28: return new AST::Parser_SourceRoot( loader, objectInfo );
        case 29: return new AST::Parser_IncludeRoot( loader, objectInfo );
        case 30: return new AST::Parser_ObjectSourceRoot( loader, objectInfo );
        case 17: return new Body::Parser_ContextDef( loader, objectInfo );
        case 31: return new Tree::Interface_DimensionTrait( loader, objectInfo );
        case 35: return new Tree::Interface_InheritanceTrait( loader, objectInfo );
        case 37: return new Tree::Interface_LinkTrait( loader, objectInfo );
        case 38: return new Tree::Interface_ReturnTypeTrait( loader, objectInfo );
        case 40: return new Tree::Interface_ArgumentListTrait( loader, objectInfo );
        case 42: return new Tree::Interface_SizeTrait( loader, objectInfo );
        case 44: return new Tree::Interface_ContextGroup( loader, objectInfo );
        case 45: return new Tree::Interface_Root( loader, objectInfo );
        case 46: return new Tree::Interface_IContext( loader, objectInfo );
        case 49: return new Tree::Interface_Namespace( loader, objectInfo );
        case 50: return new Tree::Interface_Abstract( loader, objectInfo );
        case 51: return new Tree::Interface_Action( loader, objectInfo );
        case 52: return new Tree::Interface_Event( loader, objectInfo );
        case 53: return new Tree::Interface_Function( loader, objectInfo );
        case 54: return new Tree::Interface_Object( loader, objectInfo );
        case 55: return new Tree::Interface_Link( loader, objectInfo );
        case 57: return new Tree::Interface_LinkInterface( loader, objectInfo );
        case 58: return new Tree::Interface_Buffer( loader, objectInfo );
        case 132: return new DPGraph::Dependencies_Glob( loader, objectInfo );
        case 133: return new DPGraph::Dependencies_SourceFileDependencies( loader, objectInfo );
        case 134: return new DPGraph::Dependencies_TransitiveDependencies( loader, objectInfo );
        case 135: return new DPGraph::Dependencies_Analysis( loader, objectInfo );
        case 136: return new SymbolTable::Symbols_SymbolTypeID( loader, objectInfo );
        case 137: return new SymbolTable::Symbols_InterfaceTypeID( loader, objectInfo );
        case 139: return new SymbolTable::Symbols_SymbolTable( loader, objectInfo );
        case 32: return new PerSourceSymbols::Interface_DimensionTrait( loader, objectInfo );
        case 47: return new PerSourceSymbols::Interface_IContext( loader, objectInfo );
        case 34: return new Clang::Interface_DimensionTrait( loader, objectInfo );
        case 36: return new Clang::Interface_InheritanceTrait( loader, objectInfo );
        case 39: return new Clang::Interface_ReturnTypeTrait( loader, objectInfo );
        case 41: return new Clang::Interface_ArgumentListTrait( loader, objectInfo );
        case 43: return new Clang::Interface_SizeTrait( loader, objectInfo );
        case 94: return new Concrete::Concrete_Dimensions_User( loader, objectInfo );
        case 104: return new Concrete::Concrete_ContextGroup( loader, objectInfo );
        case 105: return new Concrete::Concrete_Context( loader, objectInfo );
        case 108: return new Concrete::Concrete_Namespace( loader, objectInfo );
        case 109: return new Concrete::Concrete_Action( loader, objectInfo );
        case 111: return new Concrete::Concrete_Event( loader, objectInfo );
        case 113: return new Concrete::Concrete_Function( loader, objectInfo );
        case 114: return new Concrete::Concrete_Object( loader, objectInfo );
        case 116: return new Concrete::Concrete_Link( loader, objectInfo );
        case 118: return new Concrete::Concrete_Buffer( loader, objectInfo );
        case 120: return new Concrete::Concrete_Root( loader, objectInfo );
        case 141: return new Derivations::Derivation_ObjectMapping( loader, objectInfo );
        case 142: return new Derivations::Derivation_Mapping( loader, objectInfo );
        case 33: return new PerSourceDerivations::Interface_DimensionTrait( loader, objectInfo );
        case 48: return new PerSourceDerivations::Interface_IContext( loader, objectInfo );
        case 143: return new Model::HyperGraph_Relation( loader, objectInfo );
        case 144: return new Model::HyperGraph_Relations( loader, objectInfo );
        case 145: return new Model::HyperGraph_Graph( loader, objectInfo );
        case 56: return new PerSourceModel::Interface_Link( loader, objectInfo );
        case 96: return new MemoryLayout::Concrete_Dimensions_User( loader, objectInfo );
        case 97: return new MemoryLayout::Concrete_Dimensions_LinkReference( loader, objectInfo );
        case 99: return new MemoryLayout::Concrete_Dimensions_LinkSingle( loader, objectInfo );
        case 100: return new MemoryLayout::Concrete_Dimensions_LinkMany( loader, objectInfo );
        case 101: return new MemoryLayout::Concrete_Dimensions_Allocation( loader, objectInfo );
        case 103: return new MemoryLayout::Concrete_Dimensions_Allocator( loader, objectInfo );
        case 107: return new MemoryLayout::Concrete_Context( loader, objectInfo );
        case 110: return new MemoryLayout::Concrete_Action( loader, objectInfo );
        case 112: return new MemoryLayout::Concrete_Event( loader, objectInfo );
        case 115: return new MemoryLayout::Concrete_Object( loader, objectInfo );
        case 117: return new MemoryLayout::Concrete_Link( loader, objectInfo );
        case 119: return new MemoryLayout::Concrete_Buffer( loader, objectInfo );
        case 146: return new MemoryLayout::Allocators_Allocator( loader, objectInfo );
        case 147: return new MemoryLayout::Allocators_Nothing( loader, objectInfo );
        case 148: return new MemoryLayout::Allocators_Singleton( loader, objectInfo );
        case 149: return new MemoryLayout::Allocators_Range( loader, objectInfo );
        case 150: return new MemoryLayout::Allocators_Range32( loader, objectInfo );
        case 151: return new MemoryLayout::Allocators_Range64( loader, objectInfo );
        case 152: return new MemoryLayout::Allocators_RangeAny( loader, objectInfo );
        case 153: return new MemoryLayout::MemoryLayout_Part( loader, objectInfo );
        case 154: return new MemoryLayout::MemoryLayout_Buffer( loader, objectInfo );
        case 155: return new MemoryLayout::MemoryLayout_NonSimpleBuffer( loader, objectInfo );
        case 156: return new MemoryLayout::MemoryLayout_SimpleBuffer( loader, objectInfo );
        case 157: return new MemoryLayout::MemoryLayout_GPUBuffer( loader, objectInfo );
        case 138: return new ConcreteTable::Symbols_ConcreteTypeID( loader, objectInfo );
        case 140: return new ConcreteTable::Symbols_SymbolTable( loader, objectInfo );
        case 95: return new PerSourceConcreteTable::Concrete_Dimensions_User( loader, objectInfo );
        case 98: return new PerSourceConcreteTable::Concrete_Dimensions_LinkReference( loader, objectInfo );
        case 102: return new PerSourceConcreteTable::Concrete_Dimensions_Allocation( loader, objectInfo );
        case 106: return new PerSourceConcreteTable::Concrete_Context( loader, objectInfo );
        case 59: return new Operations::Invocations_Variables_Variable( loader, objectInfo );
        case 60: return new Operations::Invocations_Variables_Instance( loader, objectInfo );
        case 61: return new Operations::Invocations_Variables_Reference( loader, objectInfo );
        case 62: return new Operations::Invocations_Variables_Dimension( loader, objectInfo );
        case 63: return new Operations::Invocations_Variables_Context( loader, objectInfo );
        case 64: return new Operations::Invocations_Instructions_Instruction( loader, objectInfo );
        case 65: return new Operations::Invocations_Instructions_InstructionGroup( loader, objectInfo );
        case 66: return new Operations::Invocations_Instructions_Root( loader, objectInfo );
        case 67: return new Operations::Invocations_Instructions_ParentDerivation( loader, objectInfo );
        case 68: return new Operations::Invocations_Instructions_ChildDerivation( loader, objectInfo );
        case 69: return new Operations::Invocations_Instructions_EnumDerivation( loader, objectInfo );
        case 70: return new Operations::Invocations_Instructions_Enumeration( loader, objectInfo );
        case 71: return new Operations::Invocations_Instructions_DimensionReferenceRead( loader, objectInfo );
        case 72: return new Operations::Invocations_Instructions_MonoReference( loader, objectInfo );
        case 73: return new Operations::Invocations_Instructions_PolyReference( loader, objectInfo );
        case 74: return new Operations::Invocations_Instructions_PolyCase( loader, objectInfo );
        case 75: return new Operations::Invocations_Instructions_Failure( loader, objectInfo );
        case 76: return new Operations::Invocations_Instructions_Elimination( loader, objectInfo );
        case 77: return new Operations::Invocations_Instructions_Prune( loader, objectInfo );
        case 78: return new Operations::Invocations_Operations_Operation( loader, objectInfo );
        case 79: return new Operations::Invocations_Operations_BasicOperation( loader, objectInfo );
        case 80: return new Operations::Invocations_Operations_DimensionOperation( loader, objectInfo );
        case 81: return new Operations::Invocations_Operations_Allocate( loader, objectInfo );
        case 82: return new Operations::Invocations_Operations_Call( loader, objectInfo );
        case 83: return new Operations::Invocations_Operations_Start( loader, objectInfo );
        case 84: return new Operations::Invocations_Operations_Stop( loader, objectInfo );
        case 85: return new Operations::Invocations_Operations_Save( loader, objectInfo );
        case 86: return new Operations::Invocations_Operations_Load( loader, objectInfo );
        case 87: return new Operations::Invocations_Operations_Files( loader, objectInfo );
        case 88: return new Operations::Invocations_Operations_GetAction( loader, objectInfo );
        case 89: return new Operations::Invocations_Operations_GetDimension( loader, objectInfo );
        case 90: return new Operations::Invocations_Operations_Read( loader, objectInfo );
        case 91: return new Operations::Invocations_Operations_Write( loader, objectInfo );
        case 92: return new Operations::Invocations_Operations_WriteLink( loader, objectInfo );
        case 93: return new Operations::Invocations_Operations_Range( loader, objectInfo );
        case 121: return new Operations::Operations_InterfaceVariant( loader, objectInfo );
        case 122: return new Operations::Operations_ConcreteVariant( loader, objectInfo );
        case 123: return new Operations::Operations_Element( loader, objectInfo );
        case 124: return new Operations::Operations_ElementVector( loader, objectInfo );
        case 125: return new Operations::Operations_Context( loader, objectInfo );
        case 126: return new Operations::Operations_TypePath( loader, objectInfo );
        case 127: return new Operations::Operations_NameRoot( loader, objectInfo );
        case 128: return new Operations::Operations_Name( loader, objectInfo );
        case 129: return new Operations::Operations_NameResolution( loader, objectInfo );
        case 130: return new Operations::Operations_Invocation( loader, objectInfo );
        case 131: return new Operations::Operations_Invocations( loader, objectInfo );
        default:
            THROW_RTE( "Unrecognised object type ID" );
    }
}

}
