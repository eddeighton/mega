
#include "database/model/data.hxx"

#include "nlohmann/json.hpp"

namespace nlohmann {
    template <typename T>
    struct adl_serializer< std::optional<T> > 
    {
        static void to_json(json& j, const std::optional<T>& opt) 
        {
            if (!opt.has_value()) 
            {
                j = nullptr;
            } 
            else 
            {
                j = opt.value();
            }
        }
        static void from_json(const json& j, std::optional<T>& opt) 
        {
            if (j.is_null()) 
            {
                opt = std::optional<T>();
            } 
            else 
            {
                opt = j.get<T>();
            }
        }
    };
}

namespace data
{

namespace Components
{
    // struct Components_Component : public mega::io::Object
    Components_Component::Components_Component( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Components::Components_Component >( loader, this ) )    {
    }
    Components_Component::Components_Component( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::ComponentType& type, const std::string& name, const boost::filesystem::path& src_dir, const boost::filesystem::path& build_dir, const std::vector< std::string >& cpp_flags, const std::vector< std::string >& cpp_defines, const std::vector< boost::filesystem::path >& include_directories, const std::vector< mega::io::megaFilePath >& dependencies, const std::vector< mega::io::megaFilePath >& mega_source_files, const std::vector< mega::io::cppFilePath >& cpp_source_files)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Components::Components_Component >( loader, this ) )          , type( type )
          , name( name )
          , src_dir( src_dir )
          , build_dir( build_dir )
          , cpp_flags( cpp_flags )
          , cpp_defines( cpp_defines )
          , include_directories( include_directories )
          , dependencies( dependencies )
          , mega_source_files( mega_source_files )
          , cpp_source_files( cpp_source_files )
    {
    }
    bool Components_Component::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Components::Components_Component > >{ data::Ptr< data::Components::Components_Component >( loader, const_cast< Components_Component* >( this ) ) };
    }
    void Components_Component::set_inheritance_pointer()
    {
    }
    void Components_Component::load( mega::io::Loader& loader )
    {
        loader.load( type );
        loader.load( name );
        loader.load( src_dir );
        loader.load( build_dir );
        loader.load( cpp_flags );
        loader.load( cpp_defines );
        loader.load( include_directories );
        loader.load( dependencies );
        loader.load( mega_source_files );
        loader.load( cpp_source_files );
    }
    void Components_Component::store( mega::io::Storer& storer ) const
    {
        storer.store( type );
        storer.store( name );
        storer.store( src_dir );
        storer.store( build_dir );
        storer.store( cpp_flags );
        storer.store( cpp_defines );
        storer.store( include_directories );
        storer.store( dependencies );
        storer.store( mega_source_files );
        storer.store( cpp_source_files );
    }
    void Components_Component::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Components_Component" },
                { "filetype" , "Components" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "type", type } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "name", name } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "src_dir", src_dir } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "build_dir", build_dir } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_flags", cpp_flags } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_defines", cpp_defines } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "include_directories", include_directories } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dependencies", dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "mega_source_files", mega_source_files } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_source_files", cpp_source_files } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace AST
{
    // struct Parser_Identifier : public mega::io::Object
    Parser_Identifier::Parser_Identifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Identifier >( loader, this ) )    {
    }
    Parser_Identifier::Parser_Identifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Identifier >( loader, this ) )          , str( str )
    {
    }
    bool Parser_Identifier::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Identifier > >{ data::Ptr< data::AST::Parser_Identifier >( loader, const_cast< Parser_Identifier* >( this ) ) };
    }
    void Parser_Identifier::set_inheritance_pointer()
    {
    }
    void Parser_Identifier::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_Identifier::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_Identifier::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Identifier" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ScopedIdentifier : public mega::io::Object
    Parser_ScopedIdentifier::Parser_ScopedIdentifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ScopedIdentifier >( loader, this ) )    {
    }
    Parser_ScopedIdentifier::Parser_ScopedIdentifier( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_Identifier > >& ids, const std::string& source_file, const std::size_t& line_number)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ScopedIdentifier >( loader, this ) )          , ids( ids )
          , source_file( source_file )
          , line_number( line_number )
    {
    }
    bool Parser_ScopedIdentifier::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >{ data::Ptr< data::AST::Parser_ScopedIdentifier >( loader, const_cast< Parser_ScopedIdentifier* >( this ) ) };
    }
    void Parser_ScopedIdentifier::set_inheritance_pointer()
    {
    }
    void Parser_ScopedIdentifier::load( mega::io::Loader& loader )
    {
        loader.load( ids );
        loader.load( source_file );
        loader.load( line_number );
    }
    void Parser_ScopedIdentifier::store( mega::io::Storer& storer ) const
    {
        storer.store( ids );
        storer.store( source_file );
        storer.store( line_number );
    }
    void Parser_ScopedIdentifier::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ScopedIdentifier" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "ids", ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "line_number", line_number } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ArgumentList : public mega::io::Object
    Parser_ArgumentList::Parser_ArgumentList( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ArgumentList >( loader, this ) )    {
    }
    Parser_ArgumentList::Parser_ArgumentList( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ArgumentList >( loader, this ) )          , str( str )
    {
    }
    bool Parser_ArgumentList::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >{ data::Ptr< data::AST::Parser_ArgumentList >( loader, const_cast< Parser_ArgumentList* >( this ) ) };
    }
    void Parser_ArgumentList::set_inheritance_pointer()
    {
    }
    void Parser_ArgumentList::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_ArgumentList::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_ArgumentList::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ArgumentList" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ReturnType : public mega::io::Object
    Parser_ReturnType::Parser_ReturnType( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ReturnType >( loader, this ) )    {
    }
    Parser_ReturnType::Parser_ReturnType( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ReturnType >( loader, this ) )          , str( str )
    {
    }
    bool Parser_ReturnType::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >{ data::Ptr< data::AST::Parser_ReturnType >( loader, const_cast< Parser_ReturnType* >( this ) ) };
    }
    void Parser_ReturnType::set_inheritance_pointer()
    {
    }
    void Parser_ReturnType::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_ReturnType::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_ReturnType::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ReturnType" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Inheritance : public mega::io::Object
    Parser_Inheritance::Parser_Inheritance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Inheritance >( loader, this ) )    {
    }
    Parser_Inheritance::Parser_Inheritance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< std::string >& strings)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Inheritance >( loader, this ) )          , strings( strings )
    {
    }
    bool Parser_Inheritance::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >{ data::Ptr< data::AST::Parser_Inheritance >( loader, const_cast< Parser_Inheritance* >( this ) ) };
    }
    void Parser_Inheritance::set_inheritance_pointer()
    {
    }
    void Parser_Inheritance::load( mega::io::Loader& loader )
    {
        loader.load( strings );
    }
    void Parser_Inheritance::store( mega::io::Storer& storer ) const
    {
        storer.store( strings );
    }
    void Parser_Inheritance::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Inheritance" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "strings", strings } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Size : public mega::io::Object
    Parser_Size::Parser_Size( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Size >( loader, this ) )    {
    }
    Parser_Size::Parser_Size( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Size >( loader, this ) )          , str( str )
    {
    }
    bool Parser_Size::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >{ data::Ptr< data::AST::Parser_Size >( loader, const_cast< Parser_Size* >( this ) ) };
    }
    void Parser_Size::set_inheritance_pointer()
    {
    }
    void Parser_Size::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_Size::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_Size::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Size" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_LinkInterface : public mega::io::Object
    Parser_LinkInterface::Parser_LinkInterface( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterface >( loader, this ) )    {
    }
    Parser_LinkInterface::Parser_LinkInterface( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::CardinalityRange& cardinality, const mega::DerivationDirection& derivation, const mega::Ownership& ownership)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterface >( loader, this ) )          , cardinality( cardinality )
          , derivation( derivation )
          , ownership( ownership )
    {
    }
    bool Parser_LinkInterface::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >{ data::Ptr< data::AST::Parser_LinkInterface >( loader, const_cast< Parser_LinkInterface* >( this ) ) };
    }
    void Parser_LinkInterface::set_inheritance_pointer()
    {
    }
    void Parser_LinkInterface::load( mega::io::Loader& loader )
    {
        loader.load( cardinality );
        loader.load( derivation );
        loader.load( ownership );
    }
    void Parser_LinkInterface::store( mega::io::Storer& storer ) const
    {
        storer.store( cardinality );
        storer.store( derivation );
        storer.store( ownership );
    }
    void Parser_LinkInterface::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_LinkInterface" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "cardinality", cardinality } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "derivation", derivation } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "ownership", ownership } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Dimension : public mega::io::Object
    Parser_Dimension::Parser_Dimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dimension >( loader, this ) )          , id( loader )
    {
    }
    Parser_Dimension::Parser_Dimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const bool& isConst, const data::Ptr< data::AST::Parser_Identifier >& id, const std::string& type)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dimension >( loader, this ) )          , isConst( isConst )
          , id( id )
          , type( type )
    {
    }
    bool Parser_Dimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >{ data::Ptr< data::AST::Parser_Dimension >( loader, const_cast< Parser_Dimension* >( this ) ) };
    }
    void Parser_Dimension::set_inheritance_pointer()
    {
    }
    void Parser_Dimension::load( mega::io::Loader& loader )
    {
        loader.load( isConst );
        loader.load( id );
        loader.load( type );
    }
    void Parser_Dimension::store( mega::io::Storer& storer ) const
    {
        storer.store( isConst );
        storer.store( id );
        storer.store( type );
    }
    void Parser_Dimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Dimension" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "isConst", isConst } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type", type } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Include : public mega::io::Object
    Parser_Include::Parser_Include( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Include >( loader, this ) )    {
    }
    bool Parser_Include::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_Include >( loader, const_cast< Parser_Include* >( this ) ) };
    }
    void Parser_Include::set_inheritance_pointer()
    {
    }
    void Parser_Include::load( mega::io::Loader& loader )
    {
    }
    void Parser_Include::store( mega::io::Storer& storer ) const
    {
    }
    void Parser_Include::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Include" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_SystemInclude : public mega::io::Object
    Parser_SystemInclude::Parser_SystemInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SystemInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
    {
    }
    Parser_SystemInclude::Parser_SystemInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SystemInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , str( str )
    {
    }
    bool Parser_SystemInclude::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_SystemInclude >( loader, const_cast< Parser_SystemInclude* >( this ) ) };
    }
    void Parser_SystemInclude::set_inheritance_pointer()
    {
        p_AST_Parser_Include->m_inheritance = data::Ptr< data::AST::Parser_SystemInclude >( p_AST_Parser_Include, this );
    }
    void Parser_SystemInclude::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Include );
        loader.load( str );
    }
    void Parser_SystemInclude::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Include );
        storer.store( str );
    }
    void Parser_SystemInclude::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_SystemInclude" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_MegaInclude : public mega::io::Object
    Parser_MegaInclude::Parser_MegaInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , root( loader )
    {
    }
    Parser_MegaInclude::Parser_MegaInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& megaSourceFilePath)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , megaSourceFilePath( megaSourceFilePath )
    {
    }
    bool Parser_MegaInclude::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_MegaInclude >( loader, const_cast< Parser_MegaInclude* >( this ) ) };
    }
    void Parser_MegaInclude::set_inheritance_pointer()
    {
        p_AST_Parser_Include->m_inheritance = data::Ptr< data::AST::Parser_MegaInclude >( p_AST_Parser_Include, this );
    }
    void Parser_MegaInclude::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Include );
        loader.load( megaSourceFilePath );
        loader.load( root );
    }
    void Parser_MegaInclude::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Include );
        storer.store( megaSourceFilePath );
        VERIFY_RTE_MSG( root.has_value(), "AST::Parser_MegaInclude.root has NOT been set" );
        storer.store( root );
    }
    void Parser_MegaInclude::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MegaInclude" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "megaSourceFilePath", megaSourceFilePath } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "root", root.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_MegaIncludeInline : public mega::io::Object
    Parser_MegaIncludeInline::Parser_MegaIncludeInline( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaIncludeInline >( loader, this ) )          , p_AST_Parser_MegaInclude( loader )
    {
    }
    bool Parser_MegaIncludeInline::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_MegaIncludeInline >( loader, const_cast< Parser_MegaIncludeInline* >( this ) ) };
    }
    void Parser_MegaIncludeInline::set_inheritance_pointer()
    {
        p_AST_Parser_MegaInclude->m_inheritance = data::Ptr< data::AST::Parser_MegaIncludeInline >( p_AST_Parser_MegaInclude, this );
    }
    void Parser_MegaIncludeInline::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_MegaInclude );
    }
    void Parser_MegaIncludeInline::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_MegaInclude );
    }
    void Parser_MegaIncludeInline::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MegaIncludeInline" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_MegaIncludeNested : public mega::io::Object
    Parser_MegaIncludeNested::Parser_MegaIncludeNested( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaIncludeNested >( loader, this ) )          , p_AST_Parser_MegaInclude( loader )
          , id( loader )
    {
    }
    Parser_MegaIncludeNested::Parser_MegaIncludeNested( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ScopedIdentifier >& id)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MegaIncludeNested >( loader, this ) )          , p_AST_Parser_MegaInclude( loader )
          , id( id )
    {
    }
    bool Parser_MegaIncludeNested::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_MegaIncludeNested >( loader, const_cast< Parser_MegaIncludeNested* >( this ) ) };
    }
    void Parser_MegaIncludeNested::set_inheritance_pointer()
    {
        p_AST_Parser_MegaInclude->m_inheritance = data::Ptr< data::AST::Parser_MegaIncludeNested >( p_AST_Parser_MegaInclude, this );
    }
    void Parser_MegaIncludeNested::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_MegaInclude );
        loader.load( id );
    }
    void Parser_MegaIncludeNested::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_MegaInclude );
        storer.store( id );
    }
    void Parser_MegaIncludeNested::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MegaIncludeNested" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_CPPInclude : public mega::io::Object
    Parser_CPPInclude::Parser_CPPInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_CPPInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
    {
    }
    Parser_CPPInclude::Parser_CPPInclude( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& cppSourceFilePath)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_CPPInclude >( loader, this ) )          , p_AST_Parser_Include( loader )
          , cppSourceFilePath( cppSourceFilePath )
    {
    }
    bool Parser_CPPInclude::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >{ data::Ptr< data::AST::Parser_CPPInclude >( loader, const_cast< Parser_CPPInclude* >( this ) ) };
    }
    void Parser_CPPInclude::set_inheritance_pointer()
    {
        p_AST_Parser_Include->m_inheritance = data::Ptr< data::AST::Parser_CPPInclude >( p_AST_Parser_Include, this );
    }
    void Parser_CPPInclude::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Include );
        loader.load( cppSourceFilePath );
    }
    void Parser_CPPInclude::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Include );
        storer.store( cppSourceFilePath );
    }
    void Parser_CPPInclude::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_CPPInclude" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "cppSourceFilePath", cppSourceFilePath } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_Dependency : public mega::io::Object
    Parser_Dependency::Parser_Dependency( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dependency >( loader, this ) )    {
    }
    Parser_Dependency::Parser_Dependency( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_Dependency >( loader, this ) )          , str( str )
    {
    }
    bool Parser_Dependency::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Dependency > >{ data::Ptr< data::AST::Parser_Dependency >( loader, const_cast< Parser_Dependency* >( this ) ) };
    }
    void Parser_Dependency::set_inheritance_pointer()
    {
    }
    void Parser_Dependency::load( mega::io::Loader& loader )
    {
        loader.load( str );
    }
    void Parser_Dependency::store( mega::io::Storer& storer ) const
    {
        storer.store( str );
    }
    void Parser_Dependency::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_Dependency" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "str", str } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ContextDef : public mega::io::Object
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ContextDef >( loader, this ) )          , p_Body_Parser_ContextDef( loader )
          , id( loader )
    {
    }
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ScopedIdentifier >& id, const std::vector< data::Ptr< data::AST::Parser_ContextDef > >& children, const std::vector< data::Ptr< data::AST::Parser_Dimension > >& dimensions, const std::vector< data::Ptr< data::AST::Parser_Include > >& includes, const std::vector< data::Ptr< data::AST::Parser_Dependency > >& dependencies)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ContextDef >( loader, this ) )          , p_Body_Parser_ContextDef( loader )
          , id( id )
          , children( children )
          , dimensions( dimensions )
          , includes( includes )
          , dependencies( dependencies )
    {
    }
    bool Parser_ContextDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_ContextDef >( loader, const_cast< Parser_ContextDef* >( this ) ) };
    }
    void Parser_ContextDef::set_inheritance_pointer()
    {
    }
    void Parser_ContextDef::load( mega::io::Loader& loader )
    {
        loader.load( p_Body_Parser_ContextDef );
        loader.load( id );
        loader.load( children );
        loader.load( dimensions );
        loader.load( includes );
        loader.load( dependencies );
    }
    void Parser_ContextDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Body_Parser_ContextDef );
        storer.store( id );
        storer.store( children );
        storer.store( dimensions );
        storer.store( includes );
        storer.store( dependencies );
    }
    void Parser_ContextDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ContextDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "includes", includes } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dependencies", dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_NamespaceDef : public mega::io::Object
    Parser_NamespaceDef::Parser_NamespaceDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_NamespaceDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
    {
    }
    bool Parser_NamespaceDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_NamespaceDef >( loader, const_cast< Parser_NamespaceDef* >( this ) ) };
    }
    void Parser_NamespaceDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_NamespaceDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_NamespaceDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
    }
    void Parser_NamespaceDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
    }
    void Parser_NamespaceDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_NamespaceDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_AbstractDef : public mega::io::Object
    Parser_AbstractDef::Parser_AbstractDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_AbstractDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( loader )
    {
    }
    Parser_AbstractDef::Parser_AbstractDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_AbstractDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( inheritance )
    {
    }
    bool Parser_AbstractDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_AbstractDef >( loader, const_cast< Parser_AbstractDef* >( this ) ) };
    }
    void Parser_AbstractDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_AbstractDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_AbstractDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( inheritance );
    }
    void Parser_AbstractDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( inheritance );
    }
    void Parser_AbstractDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_AbstractDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ActionDef : public mega::io::Object
    Parser_ActionDef::Parser_ActionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ActionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( loader )
          , inheritance( loader )
    {
    }
    Parser_ActionDef::Parser_ActionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Size >& size, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ActionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( size )
          , inheritance( inheritance )
    {
    }
    bool Parser_ActionDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_ActionDef >( loader, const_cast< Parser_ActionDef* >( this ) ) };
    }
    void Parser_ActionDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_ActionDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_ActionDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( size );
        loader.load( inheritance );
    }
    void Parser_ActionDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( size );
        storer.store( inheritance );
    }
    void Parser_ActionDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ActionDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_EventDef : public mega::io::Object
    Parser_EventDef::Parser_EventDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_EventDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( loader )
          , inheritance( loader )
    {
    }
    Parser_EventDef::Parser_EventDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Size >& size, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_EventDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , size( size )
          , inheritance( inheritance )
    {
    }
    bool Parser_EventDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_EventDef >( loader, const_cast< Parser_EventDef* >( this ) ) };
    }
    void Parser_EventDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_EventDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_EventDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( size );
        loader.load( inheritance );
    }
    void Parser_EventDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( size );
        storer.store( inheritance );
    }
    void Parser_EventDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_EventDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_FunctionDef : public mega::io::Object
    Parser_FunctionDef::Parser_FunctionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_FunctionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , argumentList( loader )
          , returnType( loader )
    {
    }
    Parser_FunctionDef::Parser_FunctionDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ArgumentList >& argumentList, const data::Ptr< data::AST::Parser_ReturnType >& returnType)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_FunctionDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , argumentList( argumentList )
          , returnType( returnType )
    {
    }
    bool Parser_FunctionDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_FunctionDef >( loader, const_cast< Parser_FunctionDef* >( this ) ) };
    }
    void Parser_FunctionDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_FunctionDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_FunctionDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( argumentList );
        loader.load( returnType );
    }
    void Parser_FunctionDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( argumentList );
        storer.store( returnType );
    }
    void Parser_FunctionDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_FunctionDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "argumentList", argumentList } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "returnType", returnType } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_ObjectDef : public mega::io::Object
    Parser_ObjectDef::Parser_ObjectDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ObjectDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( loader )
    {
    }
    Parser_ObjectDef::Parser_ObjectDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Inheritance >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ObjectDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , inheritance( inheritance )
    {
    }
    bool Parser_ObjectDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_ObjectDef >( loader, const_cast< Parser_ObjectDef* >( this ) ) };
    }
    void Parser_ObjectDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_ObjectDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_ObjectDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( inheritance );
    }
    void Parser_ObjectDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( inheritance );
    }
    void Parser_ObjectDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ObjectDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_LinkDef : public mega::io::Object
    Parser_LinkDef::Parser_LinkDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , target( loader )
    {
    }
    Parser_LinkDef::Parser_LinkDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_Inheritance >& target)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
          , target( target )
    {
    }
    bool Parser_LinkDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_LinkDef >( loader, const_cast< Parser_LinkDef* >( this ) ) };
    }
    void Parser_LinkDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_LinkDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_LinkDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
        loader.load( target );
    }
    void Parser_LinkDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
        storer.store( target );
    }
    void Parser_LinkDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_LinkDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "target", target } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_LinkInterfaceDef : public mega::io::Object
    Parser_LinkInterfaceDef::Parser_LinkInterfaceDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterfaceDef >( loader, this ) )          , p_AST_Parser_LinkDef( loader )
          , link_interface( loader )
    {
    }
    Parser_LinkInterfaceDef::Parser_LinkInterfaceDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_LinkInterface >& link_interface)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_LinkInterfaceDef >( loader, this ) )          , p_AST_Parser_LinkDef( loader )
          , link_interface( link_interface )
    {
    }
    bool Parser_LinkInterfaceDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_LinkInterfaceDef >( loader, const_cast< Parser_LinkInterfaceDef* >( this ) ) };
    }
    void Parser_LinkInterfaceDef::set_inheritance_pointer()
    {
        p_AST_Parser_LinkDef->m_inheritance = data::Ptr< data::AST::Parser_LinkInterfaceDef >( p_AST_Parser_LinkDef, this );
    }
    void Parser_LinkInterfaceDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_LinkDef );
        loader.load( link_interface );
    }
    void Parser_LinkInterfaceDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_LinkDef );
        storer.store( link_interface );
    }
    void Parser_LinkInterfaceDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_LinkInterfaceDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_interface", link_interface } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_BufferDef : public mega::io::Object
    Parser_BufferDef::Parser_BufferDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_BufferDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
    {
    }
    bool Parser_BufferDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_BufferDef >( loader, const_cast< Parser_BufferDef* >( this ) ) };
    }
    void Parser_BufferDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_BufferDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_BufferDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
    }
    void Parser_BufferDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
    }
    void Parser_BufferDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_BufferDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_MetaDef : public mega::io::Object
    Parser_MetaDef::Parser_MetaDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_MetaDef >( loader, this ) )          , p_AST_Parser_ContextDef( loader )
    {
    }
    bool Parser_MetaDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >{ data::Ptr< data::AST::Parser_MetaDef >( loader, const_cast< Parser_MetaDef* >( this ) ) };
    }
    void Parser_MetaDef::set_inheritance_pointer()
    {
        p_AST_Parser_ContextDef->m_inheritance = data::Ptr< data::AST::Parser_MetaDef >( p_AST_Parser_ContextDef, this );
    }
    void Parser_MetaDef::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ContextDef );
    }
    void Parser_MetaDef::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ContextDef );
    }
    void Parser_MetaDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_MetaDef" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_SourceRoot : public mega::io::Object
    Parser_SourceRoot::Parser_SourceRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SourceRoot >( loader, this ) )          , component( loader )
          , ast( loader )
    {
    }
    Parser_SourceRoot::Parser_SourceRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& sourceFile, const data::Ptr< data::Components::Components_Component >& component, const data::Ptr< data::AST::Parser_ContextDef >& ast)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_SourceRoot >( loader, this ) )          , sourceFile( sourceFile )
          , component( component )
          , ast( ast )
    {
    }
    bool Parser_SourceRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >{ data::Ptr< data::AST::Parser_SourceRoot >( loader, const_cast< Parser_SourceRoot* >( this ) ) };
    }
    void Parser_SourceRoot::set_inheritance_pointer()
    {
    }
    void Parser_SourceRoot::load( mega::io::Loader& loader )
    {
        loader.load( sourceFile );
        loader.load( component );
        loader.load( ast );
    }
    void Parser_SourceRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( sourceFile );
        storer.store( component );
        storer.store( ast );
    }
    void Parser_SourceRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_SourceRoot" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "sourceFile", sourceFile } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "component", component } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "ast", ast } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Parser_IncludeRoot : public mega::io::Object
    Parser_IncludeRoot::Parser_IncludeRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_IncludeRoot >( loader, this ) )          , p_AST_Parser_SourceRoot( loader )
    {
    }
    bool Parser_IncludeRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >{ data::Ptr< data::AST::Parser_IncludeRoot >( loader, const_cast< Parser_IncludeRoot* >( this ) ) };
    }
    void Parser_IncludeRoot::set_inheritance_pointer()
    {
        p_AST_Parser_SourceRoot->m_inheritance = data::Ptr< data::AST::Parser_IncludeRoot >( p_AST_Parser_SourceRoot, this );
    }
    void Parser_IncludeRoot::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_SourceRoot );
    }
    void Parser_IncludeRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_SourceRoot );
    }
    void Parser_IncludeRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_IncludeRoot" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Parser_ObjectSourceRoot : public mega::io::Object
    Parser_ObjectSourceRoot::Parser_ObjectSourceRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::AST::Parser_ObjectSourceRoot >( loader, this ) )          , p_AST_Parser_SourceRoot( loader )
    {
    }
    bool Parser_ObjectSourceRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >{ data::Ptr< data::AST::Parser_ObjectSourceRoot >( loader, const_cast< Parser_ObjectSourceRoot* >( this ) ) };
    }
    void Parser_ObjectSourceRoot::set_inheritance_pointer()
    {
        p_AST_Parser_SourceRoot->m_inheritance = data::Ptr< data::AST::Parser_ObjectSourceRoot >( p_AST_Parser_SourceRoot, this );
    }
    void Parser_ObjectSourceRoot::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_SourceRoot );
    }
    void Parser_ObjectSourceRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_SourceRoot );
    }
    void Parser_ObjectSourceRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ObjectSourceRoot" },
                { "filetype" , "AST" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
}
namespace Body
{
    // struct Parser_ContextDef : public mega::io::Object
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )    {
    }
    Parser_ContextDef::Parser_ContextDef( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& body)
        :   mega::io::Object( objectInfo )          , body( body )
    {
    }
    bool Parser_ContextDef::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Parser_ContextDef::set_inheritance_pointer()
    {
    }
    void Parser_ContextDef::load( mega::io::Loader& loader )
    {
        loader.load( body );
    }
    void Parser_ContextDef::store( mega::io::Storer& storer ) const
    {
        storer.store( body );
    }
    void Parser_ContextDef::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Parser_ContextDef" },
                { "filetype" , "Body" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "body", body } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Tree
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_DimensionTrait >( loader, this ) )          , p_AST_Parser_Dimension( loader )
          , p_PerSourceSymbols_Interface_DimensionTrait( loader )
          , p_PerSourceDerivations_Interface_DimensionTrait( loader )
          , p_Clang_Interface_DimensionTrait( loader )
          , parent( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_IContext >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_DimensionTrait >( loader, this ) )          , p_AST_Parser_Dimension( loader )
          , p_PerSourceSymbols_Interface_DimensionTrait( loader )
          , p_PerSourceDerivations_Interface_DimensionTrait( loader )
          , p_Clang_Interface_DimensionTrait( loader )
          , parent( parent )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >{ data::Ptr< data::Tree::Interface_DimensionTrait >( loader, const_cast< Interface_DimensionTrait* >( this ) ) };
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_AST_Parser_Dimension->m_inheritance = data::Ptr< data::Tree::Interface_DimensionTrait >( p_AST_Parser_Dimension, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Dimension );
        loader.load( parent );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Dimension );
        storer.store( parent );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_InheritanceTrait : public mega::io::Object
    Interface_InheritanceTrait::Interface_InheritanceTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_InheritanceTrait >( loader, this ) )          , p_AST_Parser_Inheritance( loader )
          , p_Clang_Interface_InheritanceTrait( loader )
    {
    }
    bool Interface_InheritanceTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >{ data::Ptr< data::Tree::Interface_InheritanceTrait >( loader, const_cast< Interface_InheritanceTrait* >( this ) ) };
    }
    void Interface_InheritanceTrait::set_inheritance_pointer()
    {
        p_AST_Parser_Inheritance->m_inheritance = data::Ptr< data::Tree::Interface_InheritanceTrait >( p_AST_Parser_Inheritance, this );
    }
    void Interface_InheritanceTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Inheritance );
    }
    void Interface_InheritanceTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Inheritance );
    }
    void Interface_InheritanceTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_InheritanceTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_LinkTrait : public mega::io::Object
    Interface_LinkTrait::Interface_LinkTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_LinkTrait >( loader, this ) )          , p_AST_Parser_LinkInterface( loader )
    {
    }
    bool Interface_LinkTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >{ data::Ptr< data::Tree::Interface_LinkTrait >( loader, const_cast< Interface_LinkTrait* >( this ) ) };
    }
    void Interface_LinkTrait::set_inheritance_pointer()
    {
        p_AST_Parser_LinkInterface->m_inheritance = data::Ptr< data::Tree::Interface_LinkTrait >( p_AST_Parser_LinkInterface, this );
    }
    void Interface_LinkTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_LinkInterface );
    }
    void Interface_LinkTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_LinkInterface );
    }
    void Interface_LinkTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_LinkTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_ReturnTypeTrait : public mega::io::Object
    Interface_ReturnTypeTrait::Interface_ReturnTypeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ReturnTypeTrait >( loader, this ) )          , p_AST_Parser_ReturnType( loader )
          , p_Clang_Interface_ReturnTypeTrait( loader )
    {
    }
    bool Interface_ReturnTypeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >{ data::Ptr< data::Tree::Interface_ReturnTypeTrait >( loader, const_cast< Interface_ReturnTypeTrait* >( this ) ) };
    }
    void Interface_ReturnTypeTrait::set_inheritance_pointer()
    {
        p_AST_Parser_ReturnType->m_inheritance = data::Ptr< data::Tree::Interface_ReturnTypeTrait >( p_AST_Parser_ReturnType, this );
    }
    void Interface_ReturnTypeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ReturnType );
    }
    void Interface_ReturnTypeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ReturnType );
    }
    void Interface_ReturnTypeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ReturnTypeTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_ArgumentListTrait : public mega::io::Object
    Interface_ArgumentListTrait::Interface_ArgumentListTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ArgumentListTrait >( loader, this ) )          , p_AST_Parser_ArgumentList( loader )
          , p_Clang_Interface_ArgumentListTrait( loader )
    {
    }
    bool Interface_ArgumentListTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >{ data::Ptr< data::Tree::Interface_ArgumentListTrait >( loader, const_cast< Interface_ArgumentListTrait* >( this ) ) };
    }
    void Interface_ArgumentListTrait::set_inheritance_pointer()
    {
        p_AST_Parser_ArgumentList->m_inheritance = data::Ptr< data::Tree::Interface_ArgumentListTrait >( p_AST_Parser_ArgumentList, this );
    }
    void Interface_ArgumentListTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_ArgumentList );
    }
    void Interface_ArgumentListTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_ArgumentList );
    }
    void Interface_ArgumentListTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ArgumentListTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_SizeTrait : public mega::io::Object
    Interface_SizeTrait::Interface_SizeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_SizeTrait >( loader, this ) )          , p_AST_Parser_Size( loader )
          , p_Clang_Interface_SizeTrait( loader )
    {
    }
    bool Interface_SizeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >{ data::Ptr< data::Tree::Interface_SizeTrait >( loader, const_cast< Interface_SizeTrait* >( this ) ) };
    }
    void Interface_SizeTrait::set_inheritance_pointer()
    {
        p_AST_Parser_Size->m_inheritance = data::Ptr< data::Tree::Interface_SizeTrait >( p_AST_Parser_Size, this );
    }
    void Interface_SizeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_AST_Parser_Size );
    }
    void Interface_SizeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_AST_Parser_Size );
    }
    void Interface_SizeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_SizeTrait" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Interface_ContextGroup : public mega::io::Object
    Interface_ContextGroup::Interface_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ContextGroup >( loader, this ) )    {
    }
    Interface_ContextGroup::Interface_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_ContextGroup >( loader, this ) )          , children( children )
    {
    }
    bool Interface_ContextGroup::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_ContextGroup >( loader, const_cast< Interface_ContextGroup* >( this ) ) };
    }
    void Interface_ContextGroup::set_inheritance_pointer()
    {
    }
    void Interface_ContextGroup::load( mega::io::Loader& loader )
    {
        loader.load( children );
    }
    void Interface_ContextGroup::store( mega::io::Storer& storer ) const
    {
        storer.store( children );
    }
    void Interface_ContextGroup::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ContextGroup" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Root : public mega::io::Object
    Interface_Root::Interface_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Root >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , root( loader )
    {
    }
    Interface_Root::Interface_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::AST::Parser_ObjectSourceRoot >& root)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Root >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , root( root )
    {
    }
    bool Interface_Root::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Root >( loader, const_cast< Interface_Root* >( this ) ) };
    }
    void Interface_Root::set_inheritance_pointer()
    {
        p_Tree_Interface_ContextGroup->m_inheritance = data::Ptr< data::Tree::Interface_Root >( p_Tree_Interface_ContextGroup, this );
    }
    void Interface_Root::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ContextGroup );
        loader.load( root );
    }
    void Interface_Root::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ContextGroup );
        storer.store( root );
    }
    void Interface_Root::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Root" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "root", root } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_IContext : public mega::io::Object
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_IContext >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , p_PerSourceSymbols_Interface_IContext( loader )
          , p_PerSourceDerivations_Interface_IContext( loader )
          , parent( loader )
    {
    }
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& identifier, const data::Ptr< data::Tree::Interface_ContextGroup >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_IContext >( loader, this ) )          , p_Tree_Interface_ContextGroup( loader )
          , p_PerSourceSymbols_Interface_IContext( loader )
          , p_PerSourceDerivations_Interface_IContext( loader )
          , identifier( identifier )
          , parent( parent )
    {
    }
    bool Interface_IContext::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_IContext >( loader, const_cast< Interface_IContext* >( this ) ) };
    }
    void Interface_IContext::set_inheritance_pointer()
    {
        p_Tree_Interface_ContextGroup->m_inheritance = data::Ptr< data::Tree::Interface_IContext >( p_Tree_Interface_ContextGroup, this );
    }
    void Interface_IContext::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ContextGroup );
        loader.load( identifier );
        loader.load( parent );
    }
    void Interface_IContext::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ContextGroup );
        storer.store( identifier );
        storer.store( parent );
    }
    void Interface_IContext::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_IContext" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "identifier", identifier } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Namespace : public mega::io::Object
    Interface_Namespace::Interface_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Namespace >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Namespace::Interface_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const bool& is_global, const std::vector< data::Ptr< data::AST::Parser_ContextDef > >& namespace_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Namespace >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , is_global( is_global )
          , namespace_defs( namespace_defs )
    {
    }
    bool Interface_Namespace::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Namespace >( loader, const_cast< Interface_Namespace* >( this ) ) };
    }
    void Interface_Namespace::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Namespace >( p_Tree_Interface_IContext, this );
    }
    void Interface_Namespace::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( is_global );
        loader.load( namespace_defs );
        loader.load( dimension_traits );
    }
    void Interface_Namespace::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( is_global );
        storer.store( namespace_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Namespace.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
    }
    void Interface_Namespace::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Namespace" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_global", is_global } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "namespace_defs", namespace_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Abstract : public mega::io::Object
    Interface_Abstract::Interface_Abstract( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Abstract >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Abstract::Interface_Abstract( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& abstract_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Abstract >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , abstract_defs( abstract_defs )
    {
    }
    bool Interface_Abstract::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Abstract >( loader, const_cast< Interface_Abstract* >( this ) ) };
    }
    void Interface_Abstract::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Abstract >( p_Tree_Interface_IContext, this );
    }
    void Interface_Abstract::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( abstract_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
    }
    void Interface_Abstract::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( abstract_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Abstract.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Abstract.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
    }
    void Interface_Abstract::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Abstract" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "abstract_defs", abstract_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Action : public mega::io::Object
    Interface_Action::Interface_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Action >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Action::Interface_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_ActionDef > >& action_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Action >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , action_defs( action_defs )
    {
    }
    bool Interface_Action::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Action >( loader, const_cast< Interface_Action* >( this ) ) };
    }
    void Interface_Action::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Action >( p_Tree_Interface_IContext, this );
    }
    void Interface_Action::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( action_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
        loader.load( size_trait );
    }
    void Interface_Action::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( action_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Action.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Action.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
        VERIFY_RTE_MSG( size_trait.has_value(), "Tree::Interface_Action.size_trait has NOT been set" );
        storer.store( size_trait );
    }
    void Interface_Action::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Action" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "action_defs", action_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size_trait", size_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Event : public mega::io::Object
    Interface_Event::Interface_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Event >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Event::Interface_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_EventDef > >& event_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Event >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , event_defs( event_defs )
    {
    }
    bool Interface_Event::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Event >( loader, const_cast< Interface_Event* >( this ) ) };
    }
    void Interface_Event::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Event >( p_Tree_Interface_IContext, this );
    }
    void Interface_Event::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( event_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
        loader.load( size_trait );
    }
    void Interface_Event::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( event_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Event.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Event.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
        VERIFY_RTE_MSG( size_trait.has_value(), "Tree::Interface_Event.size_trait has NOT been set" );
        storer.store( size_trait );
    }
    void Interface_Event::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Event" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "event_defs", event_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size_trait", size_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Function : public mega::io::Object
    Interface_Function::Interface_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Function >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , return_type_trait( loader )
          , arguments_trait( loader )
    {
    }
    Interface_Function::Interface_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& function_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Function >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , function_defs( function_defs )
    {
    }
    bool Interface_Function::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Function >( loader, const_cast< Interface_Function* >( this ) ) };
    }
    void Interface_Function::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Function >( p_Tree_Interface_IContext, this );
    }
    void Interface_Function::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( function_defs );
        loader.load( return_type_trait );
        loader.load( arguments_trait );
    }
    void Interface_Function::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( function_defs );
        VERIFY_RTE_MSG( return_type_trait.has_value(), "Tree::Interface_Function.return_type_trait has NOT been set" );
        storer.store( return_type_trait );
        VERIFY_RTE_MSG( arguments_trait.has_value(), "Tree::Interface_Function.arguments_trait has NOT been set" );
        storer.store( arguments_trait );
    }
    void Interface_Function::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Function" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "function_defs", function_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_type_trait", return_type_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "arguments_trait", arguments_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Object : public mega::io::Object
    Interface_Object::Interface_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Object >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Object::Interface_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& object_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Object >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , object_defs( object_defs )
    {
    }
    bool Interface_Object::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Object >( loader, const_cast< Interface_Object* >( this ) ) };
    }
    void Interface_Object::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Object >( p_Tree_Interface_IContext, this );
    }
    void Interface_Object::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( object_defs );
        loader.load( dimension_traits );
        loader.load( inheritance_trait );
    }
    void Interface_Object::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( object_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Object.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
        VERIFY_RTE_MSG( inheritance_trait.has_value(), "Tree::Interface_Object.inheritance_trait has NOT been set" );
        storer.store( inheritance_trait );
    }
    void Interface_Object::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Object" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "object_defs", object_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_trait", inheritance_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Link : public mega::io::Object
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Link >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , p_PerSourceModel_Interface_Link( loader )
          , link_target( loader )
    {
    }
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_LinkDef > >& link_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Link >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , p_PerSourceModel_Interface_Link( loader )
          , link_defs( link_defs )
    {
    }
    bool Interface_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Link >( loader, const_cast< Interface_Link* >( this ) ) };
    }
    void Interface_Link::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Link >( p_Tree_Interface_IContext, this );
    }
    void Interface_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( link_defs );
        loader.load( link_target );
    }
    void Interface_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( link_defs );
        VERIFY_RTE_MSG( link_target.has_value(), "Tree::Interface_Link.link_target has NOT been set" );
        storer.store( link_target );
    }
    void Interface_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Link" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_defs", link_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_target", link_target.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_LinkInterface : public mega::io::Object
    Interface_LinkInterface::Interface_LinkInterface( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_LinkInterface >( loader, this ) )          , p_Tree_Interface_Link( loader )
          , link_trait( loader )
    {
    }
    bool Interface_LinkInterface::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_LinkInterface >( loader, const_cast< Interface_LinkInterface* >( this ) ) };
    }
    void Interface_LinkInterface::set_inheritance_pointer()
    {
        p_Tree_Interface_Link->m_inheritance = data::Ptr< data::Tree::Interface_LinkInterface >( p_Tree_Interface_Link, this );
    }
    void Interface_LinkInterface::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_Link );
        loader.load( link_trait );
    }
    void Interface_LinkInterface::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_Link );
        VERIFY_RTE_MSG( link_trait.has_value(), "Tree::Interface_LinkInterface.link_trait has NOT been set" );
        storer.store( link_trait );
    }
    void Interface_LinkInterface::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_LinkInterface" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_trait", link_trait.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_Buffer : public mega::io::Object
    Interface_Buffer::Interface_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Buffer >( loader, this ) )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_Buffer::Interface_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::AST::Parser_BufferDef > >& buffer_defs)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Tree::Interface_Buffer >( loader, this ) )          , p_Tree_Interface_IContext( loader )
          , buffer_defs( buffer_defs )
    {
    }
    bool Interface_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >{ data::Ptr< data::Tree::Interface_Buffer >( loader, const_cast< Interface_Buffer* >( this ) ) };
    }
    void Interface_Buffer::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->m_inheritance = data::Ptr< data::Tree::Interface_Buffer >( p_Tree_Interface_IContext, this );
    }
    void Interface_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( buffer_defs );
        loader.load( dimension_traits );
    }
    void Interface_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( buffer_defs );
        VERIFY_RTE_MSG( dimension_traits.has_value(), "Tree::Interface_Buffer.dimension_traits has NOT been set" );
        storer.store( dimension_traits );
    }
    void Interface_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Buffer" },
                { "filetype" , "Tree" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "buffer_defs", buffer_defs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_traits", dimension_traits.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace DPGraph
{
    // struct Dependencies_Glob : public mega::io::Object
    Dependencies_Glob::Dependencies_Glob( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Glob >( loader, this ) )    {
    }
    Dependencies_Glob::Dependencies_Glob( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const boost::filesystem::path& location, const std::string& glob)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Glob >( loader, this ) )          , location( location )
          , glob( glob )
    {
    }
    bool Dependencies_Glob::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >{ data::Ptr< data::DPGraph::Dependencies_Glob >( loader, const_cast< Dependencies_Glob* >( this ) ) };
    }
    void Dependencies_Glob::set_inheritance_pointer()
    {
    }
    void Dependencies_Glob::load( mega::io::Loader& loader )
    {
        loader.load( location );
        loader.load( glob );
    }
    void Dependencies_Glob::store( mega::io::Storer& storer ) const
    {
        storer.store( location );
        storer.store( glob );
    }
    void Dependencies_Glob::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_Glob" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "location", location } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "glob", glob } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Dependencies_SourceFileDependencies : public mega::io::Object
    Dependencies_SourceFileDependencies::Dependencies_SourceFileDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >( loader, this ) )    {
    }
    Dependencies_SourceFileDependencies::Dependencies_SourceFileDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::io::megaFilePath& source_file, const std::size_t& hash_code, const std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& globs, const std::vector< boost::filesystem::path >& resolution)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >( loader, this ) )          , source_file( source_file )
          , hash_code( hash_code )
          , globs( globs )
          , resolution( resolution )
    {
    }
    bool Dependencies_SourceFileDependencies::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >{ data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies >( loader, const_cast< Dependencies_SourceFileDependencies* >( this ) ) };
    }
    void Dependencies_SourceFileDependencies::set_inheritance_pointer()
    {
    }
    void Dependencies_SourceFileDependencies::load( mega::io::Loader& loader )
    {
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( globs );
        loader.load( resolution );
    }
    void Dependencies_SourceFileDependencies::store( mega::io::Storer& storer ) const
    {
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( globs );
        storer.store( resolution );
    }
    void Dependencies_SourceFileDependencies::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_SourceFileDependencies" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "globs", globs } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "resolution", resolution } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Dependencies_TransitiveDependencies : public mega::io::Object
    Dependencies_TransitiveDependencies::Dependencies_TransitiveDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >( loader, this ) )    {
    }
    Dependencies_TransitiveDependencies::Dependencies_TransitiveDependencies( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< mega::io::megaFilePath >& mega_source_files)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >( loader, this ) )          , mega_source_files( mega_source_files )
    {
    }
    bool Dependencies_TransitiveDependencies::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >{ data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies >( loader, const_cast< Dependencies_TransitiveDependencies* >( this ) ) };
    }
    void Dependencies_TransitiveDependencies::set_inheritance_pointer()
    {
    }
    void Dependencies_TransitiveDependencies::load( mega::io::Loader& loader )
    {
        loader.load( mega_source_files );
    }
    void Dependencies_TransitiveDependencies::store( mega::io::Storer& storer ) const
    {
        storer.store( mega_source_files );
    }
    void Dependencies_TransitiveDependencies::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_TransitiveDependencies" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "mega_source_files", mega_source_files } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Dependencies_Analysis : public mega::io::Object
    Dependencies_Analysis::Dependencies_Analysis( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Analysis >( loader, this ) )    {
    }
    Dependencies_Analysis::Dependencies_Analysis( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& objects, const std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& mega_dependencies, const std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& cpp_dependencies)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::DPGraph::Dependencies_Analysis >( loader, this ) )          , objects( objects )
          , mega_dependencies( mega_dependencies )
          , cpp_dependencies( cpp_dependencies )
    {
    }
    bool Dependencies_Analysis::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >{ data::Ptr< data::DPGraph::Dependencies_Analysis >( loader, const_cast< Dependencies_Analysis* >( this ) ) };
    }
    void Dependencies_Analysis::set_inheritance_pointer()
    {
    }
    void Dependencies_Analysis::load( mega::io::Loader& loader )
    {
        loader.load( objects );
        loader.load( mega_dependencies );
        loader.load( cpp_dependencies );
    }
    void Dependencies_Analysis::store( mega::io::Storer& storer ) const
    {
        storer.store( objects );
        storer.store( mega_dependencies );
        storer.store( cpp_dependencies );
    }
    void Dependencies_Analysis::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Dependencies_Analysis" },
                { "filetype" , "DPGraph" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "objects", objects } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "mega_dependencies", mega_dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "cpp_dependencies", cpp_dependencies } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace SymbolTable
{
    // struct Symbols_Symbol : public mega::io::Object
    Symbols_Symbol::Symbols_Symbol( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_Symbol >( loader, this ) )    {
    }
    Symbols_Symbol::Symbols_Symbol( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::string& symbol, const std::int32_t& id, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& contexts, const std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_Symbol >( loader, this ) )          , symbol( symbol )
          , id( id )
          , contexts( contexts )
          , dimensions( dimensions )
    {
    }
    bool Symbols_Symbol::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >{ data::Ptr< data::SymbolTable::Symbols_Symbol >( loader, const_cast< Symbols_Symbol* >( this ) ) };
    }
    void Symbols_Symbol::set_inheritance_pointer()
    {
    }
    void Symbols_Symbol::load( mega::io::Loader& loader )
    {
        loader.load( symbol );
        loader.load( id );
        loader.load( contexts );
        loader.load( dimensions );
    }
    void Symbols_Symbol::store( mega::io::Storer& storer ) const
    {
        storer.store( symbol );
        storer.store( id );
        storer.store( contexts );
        storer.store( dimensions );
    }
    void Symbols_Symbol::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_Symbol" },
                { "filetype" , "SymbolTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol", symbol } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "contexts", contexts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_SymbolSet : public mega::io::Object
    Symbols_SymbolSet::Symbols_SymbolSet( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolSet >( loader, this ) )          , p_ConcreteTable_Symbols_SymbolSet( loader )
    {
    }
    Symbols_SymbolSet::Symbols_SymbolSet( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& symbols, const mega::io::megaFilePath& source_file, const std::size_t& hash_code, const std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& context_symbols, const std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& dimension_symbols, const std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >& context_type_ids, const std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >& dimension_type_ids)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolSet >( loader, this ) )          , p_ConcreteTable_Symbols_SymbolSet( loader )
          , symbols( symbols )
          , source_file( source_file )
          , hash_code( hash_code )
          , context_symbols( context_symbols )
          , dimension_symbols( dimension_symbols )
          , context_type_ids( context_type_ids )
          , dimension_type_ids( dimension_type_ids )
    {
    }
    bool Symbols_SymbolSet::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >{ data::Ptr< data::SymbolTable::Symbols_SymbolSet >( loader, const_cast< Symbols_SymbolSet* >( this ) ) };
    }
    void Symbols_SymbolSet::set_inheritance_pointer()
    {
    }
    void Symbols_SymbolSet::load( mega::io::Loader& loader )
    {
        loader.load( symbols );
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( context_symbols );
        loader.load( dimension_symbols );
        loader.load( context_type_ids );
        loader.load( dimension_type_ids );
    }
    void Symbols_SymbolSet::store( mega::io::Storer& storer ) const
    {
        storer.store( symbols );
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( context_symbols );
        storer.store( dimension_symbols );
        storer.store( context_type_ids );
        storer.store( dimension_type_ids );
    }
    void Symbols_SymbolSet::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolSet" },
                { "filetype" , "SymbolTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbols", symbols } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context_symbols", context_symbols } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_symbols", dimension_symbols } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context_type_ids", context_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_type_ids", dimension_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_SymbolTable : public mega::io::Object
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolTable >( loader, this ) )          , p_ConcreteTable_Symbols_SymbolTable( loader )
    {
    }
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& symbol_sets, const std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& symbols, const std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >& context_type_ids, const std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >& dimension_type_ids, const std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >& symbol_id_map)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::SymbolTable::Symbols_SymbolTable >( loader, this ) )          , p_ConcreteTable_Symbols_SymbolTable( loader )
          , symbol_sets( symbol_sets )
          , symbols( symbols )
          , context_type_ids( context_type_ids )
          , dimension_type_ids( dimension_type_ids )
          , symbol_id_map( symbol_id_map )
    {
    }
    bool Symbols_SymbolTable::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >{ data::Ptr< data::SymbolTable::Symbols_SymbolTable >( loader, const_cast< Symbols_SymbolTable* >( this ) ) };
    }
    void Symbols_SymbolTable::set_inheritance_pointer()
    {
    }
    void Symbols_SymbolTable::load( mega::io::Loader& loader )
    {
        loader.load( symbol_sets );
        loader.load( symbols );
        loader.load( context_type_ids );
        loader.load( dimension_type_ids );
        loader.load( symbol_id_map );
    }
    void Symbols_SymbolTable::store( mega::io::Storer& storer ) const
    {
        storer.store( symbol_sets );
        storer.store( symbols );
        storer.store( context_type_ids );
        storer.store( dimension_type_ids );
        storer.store( symbol_id_map );
    }
    void Symbols_SymbolTable::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolTable" },
                { "filetype" , "SymbolTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_sets", symbol_sets } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbols", symbols } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context_type_ids", context_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_type_ids", dimension_type_ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol_id_map", symbol_id_map } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceSymbols
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_DimensionTrait > p_Tree_Interface_DimensionTrait, const std::int32_t& symbol)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( p_Tree_Interface_DimensionTrait )
          , symbol( symbol )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_DimensionTrait->p_PerSourceSymbols_Interface_DimensionTrait = data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait >( p_Tree_Interface_DimensionTrait, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_DimensionTrait );
        loader.load( symbol );
        loader.load( type_id );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_DimensionTrait );
        storer.store( symbol );
        VERIFY_RTE_MSG( type_id.has_value(), "Tree::Interface_DimensionTrait.type_id has NOT been set" );
        storer.store( type_id );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "PerSourceSymbols" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol", symbol } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type_id", type_id.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_IContext : public mega::io::Object
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_IContext > p_Tree_Interface_IContext, const std::int32_t& symbol)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( p_Tree_Interface_IContext )
          , symbol( symbol )
    {
    }
    bool Interface_IContext::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_IContext::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->p_PerSourceSymbols_Interface_IContext = data::Ptr< data::PerSourceSymbols::Interface_IContext >( p_Tree_Interface_IContext, this );
    }
    void Interface_IContext::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( symbol );
        loader.load( type_id );
    }
    void Interface_IContext::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( symbol );
        VERIFY_RTE_MSG( type_id.has_value(), "Tree::Interface_IContext.type_id has NOT been set" );
        storer.store( type_id );
    }
    void Interface_IContext::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_IContext" },
                { "filetype" , "PerSourceSymbols" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbol", symbol } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type_id", type_id.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Clang
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_DimensionTrait > p_Tree_Interface_DimensionTrait, const std::string& canonical_type, const std::size_t& size, const bool& simple, const std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >& symbols)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( p_Tree_Interface_DimensionTrait )
          , canonical_type( canonical_type )
          , size( size )
          , simple( simple )
          , symbols( symbols )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_DimensionTrait->p_Clang_Interface_DimensionTrait = data::Ptr< data::Clang::Interface_DimensionTrait >( p_Tree_Interface_DimensionTrait, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_DimensionTrait );
        loader.load( canonical_type );
        loader.load( size );
        loader.load( simple );
        loader.load( symbols );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_DimensionTrait );
        storer.store( canonical_type );
        storer.store( size );
        storer.store( simple );
        storer.store( symbols );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "canonical_type", canonical_type } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "simple", simple } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "symbols", symbols } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_InheritanceTrait : public mega::io::Object
    Interface_InheritanceTrait::Interface_InheritanceTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_InheritanceTrait( loader )
    {
    }
    Interface_InheritanceTrait::Interface_InheritanceTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_InheritanceTrait > p_Tree_Interface_InheritanceTrait, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& contexts)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_InheritanceTrait( p_Tree_Interface_InheritanceTrait )
          , contexts( contexts )
    {
    }
    bool Interface_InheritanceTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_InheritanceTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_InheritanceTrait->p_Clang_Interface_InheritanceTrait = data::Ptr< data::Clang::Interface_InheritanceTrait >( p_Tree_Interface_InheritanceTrait, this );
    }
    void Interface_InheritanceTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_InheritanceTrait );
        loader.load( contexts );
    }
    void Interface_InheritanceTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_InheritanceTrait );
        storer.store( contexts );
    }
    void Interface_InheritanceTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_InheritanceTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "contexts", contexts } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_ReturnTypeTrait : public mega::io::Object
    Interface_ReturnTypeTrait::Interface_ReturnTypeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ReturnTypeTrait( loader )
    {
    }
    Interface_ReturnTypeTrait::Interface_ReturnTypeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_ReturnTypeTrait > p_Tree_Interface_ReturnTypeTrait, const std::string& canonical_type)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ReturnTypeTrait( p_Tree_Interface_ReturnTypeTrait )
          , canonical_type( canonical_type )
    {
    }
    bool Interface_ReturnTypeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_ReturnTypeTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_ReturnTypeTrait->p_Clang_Interface_ReturnTypeTrait = data::Ptr< data::Clang::Interface_ReturnTypeTrait >( p_Tree_Interface_ReturnTypeTrait, this );
    }
    void Interface_ReturnTypeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ReturnTypeTrait );
        loader.load( canonical_type );
    }
    void Interface_ReturnTypeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ReturnTypeTrait );
        storer.store( canonical_type );
    }
    void Interface_ReturnTypeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ReturnTypeTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "canonical_type", canonical_type } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_ArgumentListTrait : public mega::io::Object
    Interface_ArgumentListTrait::Interface_ArgumentListTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ArgumentListTrait( loader )
    {
    }
    Interface_ArgumentListTrait::Interface_ArgumentListTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_ArgumentListTrait > p_Tree_Interface_ArgumentListTrait, const std::vector< std::string >& canonical_types)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_ArgumentListTrait( p_Tree_Interface_ArgumentListTrait )
          , canonical_types( canonical_types )
    {
    }
    bool Interface_ArgumentListTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_ArgumentListTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_ArgumentListTrait->p_Clang_Interface_ArgumentListTrait = data::Ptr< data::Clang::Interface_ArgumentListTrait >( p_Tree_Interface_ArgumentListTrait, this );
    }
    void Interface_ArgumentListTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_ArgumentListTrait );
        loader.load( canonical_types );
    }
    void Interface_ArgumentListTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_ArgumentListTrait );
        storer.store( canonical_types );
    }
    void Interface_ArgumentListTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_ArgumentListTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "canonical_types", canonical_types } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_SizeTrait : public mega::io::Object
    Interface_SizeTrait::Interface_SizeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_SizeTrait( loader )
    {
    }
    Interface_SizeTrait::Interface_SizeTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_SizeTrait > p_Tree_Interface_SizeTrait, const std::size_t& size)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_SizeTrait( p_Tree_Interface_SizeTrait )
          , size( size )
    {
    }
    bool Interface_SizeTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_SizeTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_SizeTrait->p_Clang_Interface_SizeTrait = data::Ptr< data::Clang::Interface_SizeTrait >( p_Tree_Interface_SizeTrait, this );
    }
    void Interface_SizeTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_SizeTrait );
        loader.load( size );
    }
    void Interface_SizeTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_SizeTrait );
        storer.store( size );
    }
    void Interface_SizeTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_SizeTrait" },
                { "filetype" , "Clang" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "size", size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Concrete
{
    // struct Concrete_Dimensions_User : public mega::io::Object
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Dimensions_User >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_User( loader )
          , parent( loader )
          , interface_dimension( loader )
    {
    }
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& parent, const data::Ptr< data::Tree::Interface_DimensionTrait >& interface_dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Dimensions_User >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_User( loader )
          , parent( parent )
          , interface_dimension( interface_dimension )
    {
    }
    bool Concrete_Dimensions_User::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >{ data::Ptr< data::Concrete::Concrete_Dimensions_User >( loader, const_cast< Concrete_Dimensions_User* >( this ) ) };
    }
    void Concrete_Dimensions_User::set_inheritance_pointer()
    {
    }
    void Concrete_Dimensions_User::load( mega::io::Loader& loader )
    {
        loader.load( parent );
        loader.load( interface_dimension );
    }
    void Concrete_Dimensions_User::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
        storer.store( interface_dimension );
    }
    void Concrete_Dimensions_User::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_User" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_dimension", interface_dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_ContextGroup : public mega::io::Object
    Concrete_ContextGroup::Concrete_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_ContextGroup >( loader, this ) )    {
    }
    Concrete_ContextGroup::Concrete_ContextGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Concrete::Concrete_Context > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_ContextGroup >( loader, this ) )          , children( children )
    {
    }
    bool Concrete_ContextGroup::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_ContextGroup >( loader, const_cast< Concrete_ContextGroup* >( this ) ) };
    }
    void Concrete_ContextGroup::set_inheritance_pointer()
    {
    }
    void Concrete_ContextGroup::load( mega::io::Loader& loader )
    {
        loader.load( children );
    }
    void Concrete_ContextGroup::store( mega::io::Storer& storer ) const
    {
        storer.store( children );
    }
    void Concrete_ContextGroup::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_ContextGroup" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Context : public mega::io::Object
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Context >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , p_PerSourceConcreteTable_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Context( loader )
          , parent( loader )
          , interface( loader )
    {
    }
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_ContextGroup >& parent, const data::Ptr< data::Tree::Interface_IContext >& interface, const std::vector< data::Ptr< data::Tree::Interface_IContext > >& inheritance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Context >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , p_PerSourceConcreteTable_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Context( loader )
          , parent( parent )
          , interface( interface )
          , inheritance( inheritance )
    {
    }
    bool Concrete_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Context >( loader, const_cast< Concrete_Context* >( this ) ) };
    }
    void Concrete_Context::set_inheritance_pointer()
    {
        p_Concrete_Concrete_ContextGroup->m_inheritance = data::Ptr< data::Concrete::Concrete_Context >( p_Concrete_Concrete_ContextGroup, this );
    }
    void Concrete_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_ContextGroup );
        loader.load( parent );
        loader.load( interface );
        loader.load( inheritance );
    }
    void Concrete_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_ContextGroup );
        storer.store( parent );
        storer.store( interface );
        storer.store( inheritance );
    }
    void Concrete_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Context" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface", interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance", inheritance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Namespace : public mega::io::Object
    Concrete_Namespace::Concrete_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Namespace >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_namespace( loader )
    {
    }
    Concrete_Namespace::Concrete_Namespace( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Namespace >& interface_namespace, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Namespace >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_namespace( interface_namespace )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Namespace::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Namespace >( loader, const_cast< Concrete_Namespace* >( this ) ) };
    }
    void Concrete_Namespace::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Namespace >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Namespace::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_namespace );
        loader.load( dimensions );
    }
    void Concrete_Namespace::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_namespace );
        storer.store( dimensions );
    }
    void Concrete_Namespace::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Namespace" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_namespace", interface_namespace } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Action : public mega::io::Object
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Action >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Action( loader )
          , interface_action( loader )
    {
    }
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Action >& interface_action, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Action >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Action( loader )
          , interface_action( interface_action )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Action::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Action >( loader, const_cast< Concrete_Action* >( this ) ) };
    }
    void Concrete_Action::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Action >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Action::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_action );
        loader.load( dimensions );
    }
    void Concrete_Action::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_action );
        storer.store( dimensions );
    }
    void Concrete_Action::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Action" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_action", interface_action } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Event : public mega::io::Object
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Event >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Event( loader )
          , interface_event( loader )
    {
    }
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Event >& interface_event, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Event >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Event( loader )
          , interface_event( interface_event )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Event::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Event >( loader, const_cast< Concrete_Event* >( this ) ) };
    }
    void Concrete_Event::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Event >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Event::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_event );
        loader.load( dimensions );
    }
    void Concrete_Event::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_event );
        storer.store( dimensions );
    }
    void Concrete_Event::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Event" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_event", interface_event } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Function : public mega::io::Object
    Concrete_Function::Concrete_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Function >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_function( loader )
    {
    }
    Concrete_Function::Concrete_Function( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Function >& interface_function)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Function >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , interface_function( interface_function )
    {
    }
    bool Concrete_Function::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Function >( loader, const_cast< Concrete_Function* >( this ) ) };
    }
    void Concrete_Function::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Function >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Function::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_function );
    }
    void Concrete_Function::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_function );
    }
    void Concrete_Function::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Function" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_function", interface_function } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Object : public mega::io::Object
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Object >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Object( loader )
          , interface_object( loader )
    {
    }
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Object >& interface_object, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Object >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Object( loader )
          , interface_object( interface_object )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Object::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Object >( loader, const_cast< Concrete_Object* >( this ) ) };
    }
    void Concrete_Object::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Object >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Object::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_object );
        loader.load( dimensions );
    }
    void Concrete_Object::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_object );
        storer.store( dimensions );
    }
    void Concrete_Object::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Object" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_object", interface_object } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Link : public mega::io::Object
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Link >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Link( loader )
          , link( loader )
    {
    }
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Link >& link)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Link >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Link( loader )
          , link( link )
    {
    }
    bool Concrete_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Link >( loader, const_cast< Concrete_Link* >( this ) ) };
    }
    void Concrete_Link::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Link >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( link );
    }
    void Concrete_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( link );
    }
    void Concrete_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Link" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link", link } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Buffer : public mega::io::Object
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Buffer >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Buffer( loader )
          , interface_buffer( loader )
    {
    }
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Buffer >& interface_buffer, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Buffer >( loader, this ) )          , p_Concrete_Concrete_Context( loader )
          , p_MemoryLayout_Concrete_Buffer( loader )
          , interface_buffer( interface_buffer )
          , dimensions( dimensions )
    {
    }
    bool Concrete_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Buffer >( loader, const_cast< Concrete_Buffer* >( this ) ) };
    }
    void Concrete_Buffer::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->m_inheritance = data::Ptr< data::Concrete::Concrete_Buffer >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( interface_buffer );
        loader.load( dimensions );
    }
    void Concrete_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( interface_buffer );
        storer.store( dimensions );
    }
    void Concrete_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Buffer" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_buffer", interface_buffer } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimensions", dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Root : public mega::io::Object
    Concrete_Root::Concrete_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Root >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , interface_root( loader )
    {
    }
    Concrete_Root::Concrete_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Root >& interface_root)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Concrete::Concrete_Root >( loader, this ) )          , p_Concrete_Concrete_ContextGroup( loader )
          , interface_root( interface_root )
    {
    }
    bool Concrete_Root::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >{ data::Ptr< data::Concrete::Concrete_Root >( loader, const_cast< Concrete_Root* >( this ) ) };
    }
    void Concrete_Root::set_inheritance_pointer()
    {
        p_Concrete_Concrete_ContextGroup->m_inheritance = data::Ptr< data::Concrete::Concrete_Root >( p_Concrete_Concrete_ContextGroup, this );
    }
    void Concrete_Root::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_ContextGroup );
        loader.load( interface_root );
    }
    void Concrete_Root::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_ContextGroup );
        storer.store( interface_root );
    }
    void Concrete_Root::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Root" },
                { "filetype" , "Concrete" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_root", interface_root } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace ConcreteTable
{
    // struct Symbols_ConcreteSymbol : public mega::io::Object
    Symbols_ConcreteSymbol::Symbols_ConcreteSymbol( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol >( loader, this ) )          , context( loader )
    {
    }
    Symbols_ConcreteSymbol::Symbols_ConcreteSymbol( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< std::int32_t >& id_sequence, const std::int32_t& id, const data::Ptr< data::Concrete::Concrete_Context >& context)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol >( loader, this ) )          , id_sequence( id_sequence )
          , id( id )
          , context( context )
    {
    }
    bool Symbols_ConcreteSymbol::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >{ data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol >( loader, const_cast< Symbols_ConcreteSymbol* >( this ) ) };
    }
    void Symbols_ConcreteSymbol::set_inheritance_pointer()
    {
    }
    void Symbols_ConcreteSymbol::load( mega::io::Loader& loader )
    {
        loader.load( id_sequence );
        loader.load( id );
        loader.load( context );
    }
    void Symbols_ConcreteSymbol::store( mega::io::Storer& storer ) const
    {
        storer.store( id_sequence );
        storer.store( id );
        storer.store( context );
    }
    void Symbols_ConcreteSymbol::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_ConcreteSymbol" },
                { "filetype" , "ConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "id_sequence", id_sequence } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "id", id } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_SymbolSet : public mega::io::Object
    Symbols_SymbolSet::Symbols_SymbolSet( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_SymbolTable_Symbols_SymbolSet( loader )
    {
    }
    Symbols_SymbolSet::Symbols_SymbolSet( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< SymbolTable::Symbols_SymbolSet > p_SymbolTable_Symbols_SymbolSet, const std::size_t& concrete_hash_code, const std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& concrete_symbols, const std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >& context_concrete_ids)
        :   mega::io::Object( objectInfo )          , p_SymbolTable_Symbols_SymbolSet( p_SymbolTable_Symbols_SymbolSet )
          , concrete_hash_code( concrete_hash_code )
          , concrete_symbols( concrete_symbols )
          , context_concrete_ids( context_concrete_ids )
    {
    }
    bool Symbols_SymbolSet::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Symbols_SymbolSet::set_inheritance_pointer()
    {
        p_SymbolTable_Symbols_SymbolSet->p_ConcreteTable_Symbols_SymbolSet = data::Ptr< data::ConcreteTable::Symbols_SymbolSet >( p_SymbolTable_Symbols_SymbolSet, this );
    }
    void Symbols_SymbolSet::load( mega::io::Loader& loader )
    {
        loader.load( p_SymbolTable_Symbols_SymbolSet );
        loader.load( concrete_hash_code );
        loader.load( concrete_symbols );
        loader.load( context_concrete_ids );
    }
    void Symbols_SymbolSet::store( mega::io::Storer& storer ) const
    {
        storer.store( p_SymbolTable_Symbols_SymbolSet );
        storer.store( concrete_hash_code );
        storer.store( concrete_symbols );
        storer.store( context_concrete_ids );
    }
    void Symbols_SymbolSet::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolSet" },
                { "filetype" , "ConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_hash_code", concrete_hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_symbols", concrete_symbols } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context_concrete_ids", context_concrete_ids } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Symbols_SymbolTable : public mega::io::Object
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_SymbolTable_Symbols_SymbolTable( loader )
    {
    }
    Symbols_SymbolTable::Symbols_SymbolTable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< SymbolTable::Symbols_SymbolTable > p_SymbolTable_Symbols_SymbolTable, const std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& concrete_symbol_ids, const std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& concrete_symbols, const std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >& concrete_context_map)
        :   mega::io::Object( objectInfo )          , p_SymbolTable_Symbols_SymbolTable( p_SymbolTable_Symbols_SymbolTable )
          , concrete_symbol_ids( concrete_symbol_ids )
          , concrete_symbols( concrete_symbols )
          , concrete_context_map( concrete_context_map )
    {
    }
    bool Symbols_SymbolTable::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Symbols_SymbolTable::set_inheritance_pointer()
    {
        p_SymbolTable_Symbols_SymbolTable->p_ConcreteTable_Symbols_SymbolTable = data::Ptr< data::ConcreteTable::Symbols_SymbolTable >( p_SymbolTable_Symbols_SymbolTable, this );
    }
    void Symbols_SymbolTable::load( mega::io::Loader& loader )
    {
        loader.load( p_SymbolTable_Symbols_SymbolTable );
        loader.load( concrete_symbol_ids );
        loader.load( concrete_symbols );
        loader.load( concrete_context_map );
    }
    void Symbols_SymbolTable::store( mega::io::Storer& storer ) const
    {
        storer.store( p_SymbolTable_Symbols_SymbolTable );
        storer.store( concrete_symbol_ids );
        storer.store( concrete_symbols );
        storer.store( concrete_context_map );
    }
    void Symbols_SymbolTable::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Symbols_SymbolTable" },
                { "filetype" , "ConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_symbol_ids", concrete_symbol_ids } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_symbols", concrete_symbols } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_context_map", concrete_context_map } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceConcreteTable
{
    // struct Concrete_Context : public mega::io::Object
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( loader )
    {
    }
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Context > p_Concrete_Concrete_Context, const std::int32_t& concrete_id)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( p_Concrete_Concrete_Context )
          , concrete_id( concrete_id )
    {
    }
    bool Concrete_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Context::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->p_PerSourceConcreteTable_Concrete_Context = data::Ptr< data::PerSourceConcreteTable::Concrete_Context >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( concrete_id );
    }
    void Concrete_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( concrete_id );
    }
    void Concrete_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Context" },
                { "filetype" , "PerSourceConcreteTable" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_id", concrete_id } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Derivations
{
    // struct Derivation_ObjectMapping : public mega::io::Object
    Derivation_ObjectMapping::Derivation_ObjectMapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_ObjectMapping >( loader, this ) )    {
    }
    Derivation_ObjectMapping::Derivation_ObjectMapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::io::megaFilePath& source_file, const std::size_t& hash_code, const std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& inheritance_contexts, const std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& inheritance_dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_ObjectMapping >( loader, this ) )          , source_file( source_file )
          , hash_code( hash_code )
          , inheritance_contexts( inheritance_contexts )
          , inheritance_dimensions( inheritance_dimensions )
    {
    }
    bool Derivation_ObjectMapping::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >{ data::Ptr< data::Derivations::Derivation_ObjectMapping >( loader, const_cast< Derivation_ObjectMapping* >( this ) ) };
    }
    void Derivation_ObjectMapping::set_inheritance_pointer()
    {
    }
    void Derivation_ObjectMapping::load( mega::io::Loader& loader )
    {
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( inheritance_contexts );
        loader.load( inheritance_dimensions );
    }
    void Derivation_ObjectMapping::store( mega::io::Storer& storer ) const
    {
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( inheritance_contexts );
        storer.store( inheritance_dimensions );
    }
    void Derivation_ObjectMapping::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Derivation_ObjectMapping" },
                { "filetype" , "Derivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_contexts", inheritance_contexts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_dimensions", inheritance_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Derivation_Mapping : public mega::io::Object
    Derivation_Mapping::Derivation_Mapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_Mapping >( loader, this ) )    {
    }
    Derivation_Mapping::Derivation_Mapping( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& mappings, const std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& inheritance_contexts, const std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& inheritance_dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Derivations::Derivation_Mapping >( loader, this ) )          , mappings( mappings )
          , inheritance_contexts( inheritance_contexts )
          , inheritance_dimensions( inheritance_dimensions )
    {
    }
    bool Derivation_Mapping::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >{ data::Ptr< data::Derivations::Derivation_Mapping >( loader, const_cast< Derivation_Mapping* >( this ) ) };
    }
    void Derivation_Mapping::set_inheritance_pointer()
    {
    }
    void Derivation_Mapping::load( mega::io::Loader& loader )
    {
        loader.load( mappings );
        loader.load( inheritance_contexts );
        loader.load( inheritance_dimensions );
    }
    void Derivation_Mapping::store( mega::io::Storer& storer ) const
    {
        storer.store( mappings );
        storer.store( inheritance_contexts );
        storer.store( inheritance_dimensions );
    }
    void Derivation_Mapping::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Derivation_Mapping" },
                { "filetype" , "Derivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "mappings", mappings } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_contexts", inheritance_contexts } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "inheritance_dimensions", inheritance_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceDerivations
{
    // struct Interface_DimensionTrait : public mega::io::Object
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( loader )
    {
    }
    Interface_DimensionTrait::Interface_DimensionTrait( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_DimensionTrait > p_Tree_Interface_DimensionTrait, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& concrete)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_DimensionTrait( p_Tree_Interface_DimensionTrait )
          , concrete( concrete )
    {
    }
    bool Interface_DimensionTrait::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_DimensionTrait::set_inheritance_pointer()
    {
        p_Tree_Interface_DimensionTrait->p_PerSourceDerivations_Interface_DimensionTrait = data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait >( p_Tree_Interface_DimensionTrait, this );
    }
    void Interface_DimensionTrait::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_DimensionTrait );
        loader.load( concrete );
    }
    void Interface_DimensionTrait::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_DimensionTrait );
        storer.store( concrete );
    }
    void Interface_DimensionTrait::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_DimensionTrait" },
                { "filetype" , "PerSourceDerivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Interface_IContext : public mega::io::Object
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( loader )
    {
    }
    Interface_IContext::Interface_IContext( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_IContext > p_Tree_Interface_IContext, const std::vector< data::Ptr< data::Concrete::Concrete_Context > >& concrete)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_IContext( p_Tree_Interface_IContext )
          , concrete( concrete )
    {
    }
    bool Interface_IContext::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_IContext::set_inheritance_pointer()
    {
        p_Tree_Interface_IContext->p_PerSourceDerivations_Interface_IContext = data::Ptr< data::PerSourceDerivations::Interface_IContext >( p_Tree_Interface_IContext, this );
    }
    void Interface_IContext::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_IContext );
        loader.load( concrete );
    }
    void Interface_IContext::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_IContext );
        storer.store( concrete );
    }
    void Interface_IContext::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_IContext" },
                { "filetype" , "PerSourceDerivations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace Model
{
    // struct HyperGraph_Relation : public mega::io::Object
    HyperGraph_Relation::HyperGraph_Relation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relation >( loader, this ) )          , source( loader )
          , target( loader )
          , source_interface( loader )
          , target_interface( loader )
    {
    }
    HyperGraph_Relation::HyperGraph_Relation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_Link >& source, const data::Ptr< data::Tree::Interface_Link >& target, const data::Ptr< data::Tree::Interface_LinkInterface >& source_interface, const data::Ptr< data::Tree::Interface_LinkInterface >& target_interface)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relation >( loader, this ) )          , source( source )
          , target( target )
          , source_interface( source_interface )
          , target_interface( target_interface )
    {
    }
    bool HyperGraph_Relation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Model::HyperGraph_Relation > >{ data::Ptr< data::Model::HyperGraph_Relation >( loader, const_cast< HyperGraph_Relation* >( this ) ) };
    }
    void HyperGraph_Relation::set_inheritance_pointer()
    {
    }
    void HyperGraph_Relation::load( mega::io::Loader& loader )
    {
        loader.load( source );
        loader.load( target );
        loader.load( source_interface );
        loader.load( target_interface );
    }
    void HyperGraph_Relation::store( mega::io::Storer& storer ) const
    {
        storer.store( source );
        storer.store( target );
        storer.store( source_interface );
        storer.store( target_interface );
    }
    void HyperGraph_Relation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "HyperGraph_Relation" },
                { "filetype" , "Model" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source", source } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "target", target } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_interface", source_interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "target_interface", target_interface } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct HyperGraph_Relations : public mega::io::Object
    HyperGraph_Relations::HyperGraph_Relations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relations >( loader, this ) )    {
    }
    HyperGraph_Relations::HyperGraph_Relations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const mega::io::megaFilePath& source_file, const std::size_t& hash_code, const std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& relations)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Relations >( loader, this ) )          , source_file( source_file )
          , hash_code( hash_code )
          , relations( relations )
    {
    }
    bool HyperGraph_Relations::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Model::HyperGraph_Relations > >{ data::Ptr< data::Model::HyperGraph_Relations >( loader, const_cast< HyperGraph_Relations* >( this ) ) };
    }
    void HyperGraph_Relations::set_inheritance_pointer()
    {
    }
    void HyperGraph_Relations::load( mega::io::Loader& loader )
    {
        loader.load( source_file );
        loader.load( hash_code );
        loader.load( relations );
    }
    void HyperGraph_Relations::store( mega::io::Storer& storer ) const
    {
        storer.store( source_file );
        storer.store( hash_code );
        storer.store( relations );
    }
    void HyperGraph_Relations::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "HyperGraph_Relations" },
                { "filetype" , "Model" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "source_file", source_file } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "hash_code", hash_code } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "relations", relations } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct HyperGraph_Graph : public mega::io::Object
    HyperGraph_Graph::HyperGraph_Graph( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Graph >( loader, this ) )    {
    }
    HyperGraph_Graph::HyperGraph_Graph( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& relations)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Model::HyperGraph_Graph >( loader, this ) )          , relations( relations )
    {
    }
    bool HyperGraph_Graph::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Model::HyperGraph_Graph > >{ data::Ptr< data::Model::HyperGraph_Graph >( loader, const_cast< HyperGraph_Graph* >( this ) ) };
    }
    void HyperGraph_Graph::set_inheritance_pointer()
    {
    }
    void HyperGraph_Graph::load( mega::io::Loader& loader )
    {
        loader.load( relations );
    }
    void HyperGraph_Graph::store( mega::io::Storer& storer ) const
    {
        storer.store( relations );
    }
    void HyperGraph_Graph::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "HyperGraph_Graph" },
                { "filetype" , "Model" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "relations", relations } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace PerSourceModel
{
    // struct Interface_Link : public mega::io::Object
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_Link( loader )
          , relation( loader )
    {
    }
    Interface_Link::Interface_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Tree::Interface_Link > p_Tree_Interface_Link, const data::Ptr< data::Model::HyperGraph_Relation >& relation)
        :   mega::io::Object( objectInfo )          , p_Tree_Interface_Link( p_Tree_Interface_Link )
          , relation( relation )
    {
    }
    bool Interface_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Interface_Link::set_inheritance_pointer()
    {
        p_Tree_Interface_Link->p_PerSourceModel_Interface_Link = data::Ptr< data::PerSourceModel::Interface_Link >( p_Tree_Interface_Link, this );
    }
    void Interface_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Tree_Interface_Link );
        loader.load( relation );
    }
    void Interface_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Tree_Interface_Link );
        storer.store( relation );
    }
    void Interface_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Interface_Link" },
                { "filetype" , "PerSourceModel" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "relation", relation } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}
namespace MemoryLayout
{
    // struct Concrete_Dimensions_User : public mega::io::Object
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Dimensions_User( loader )
          , part( loader )
    {
    }
    Concrete_Dimensions_User::Concrete_Dimensions_User( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Dimensions_User > p_Concrete_Concrete_Dimensions_User, const data::Ptr< data::MemoryLayout::MemoryLayout_Part >& part)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Dimensions_User( p_Concrete_Concrete_Dimensions_User )
          , part( part )
    {
    }
    bool Concrete_Dimensions_User::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Dimensions_User::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Dimensions_User->p_MemoryLayout_Concrete_Dimensions_User = data::Ptr< data::MemoryLayout::Concrete_Dimensions_User >( p_Concrete_Concrete_Dimensions_User, this );
    }
    void Concrete_Dimensions_User::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Dimensions_User );
        loader.load( part );
    }
    void Concrete_Dimensions_User::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Dimensions_User );
        storer.store( part );
    }
    void Concrete_Dimensions_User::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_User" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "part", part } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_LinkReference : public mega::io::Object
    Concrete_Dimensions_LinkReference::Concrete_Dimensions_LinkReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >( loader, this ) )          , link( loader )
          , part( loader )
    {
    }
    Concrete_Dimensions_LinkReference::Concrete_Dimensions_LinkReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Link >& link)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >( loader, this ) )          , link( link )
    {
    }
    bool Concrete_Dimensions_LinkReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >( loader, const_cast< Concrete_Dimensions_LinkReference* >( this ) ) };
    }
    void Concrete_Dimensions_LinkReference::set_inheritance_pointer()
    {
    }
    void Concrete_Dimensions_LinkReference::load( mega::io::Loader& loader )
    {
        loader.load( link );
        loader.load( part );
    }
    void Concrete_Dimensions_LinkReference::store( mega::io::Storer& storer ) const
    {
        storer.store( link );
        VERIFY_RTE_MSG( part.has_value(), "MemoryLayout::Concrete_Dimensions_LinkReference.part has NOT been set" );
        storer.store( part );
    }
    void Concrete_Dimensions_LinkReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkReference" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "link", link } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "part", part.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_LinkSingle : public mega::io::Object
    Concrete_Dimensions_LinkSingle::Concrete_Dimensions_LinkSingle( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_LinkReference( loader )
    {
    }
    bool Concrete_Dimensions_LinkSingle::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >( loader, const_cast< Concrete_Dimensions_LinkSingle* >( this ) ) };
    }
    void Concrete_Dimensions_LinkSingle::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_LinkReference->m_inheritance = data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >( p_MemoryLayout_Concrete_Dimensions_LinkReference, this );
    }
    void Concrete_Dimensions_LinkSingle::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkSingle::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkSingle::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkSingle" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Concrete_Dimensions_LinkMany : public mega::io::Object
    Concrete_Dimensions_LinkMany::Concrete_Dimensions_LinkMany( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_LinkReference( loader )
    {
    }
    bool Concrete_Dimensions_LinkMany::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >( loader, const_cast< Concrete_Dimensions_LinkMany* >( this ) ) };
    }
    void Concrete_Dimensions_LinkMany::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_LinkReference->m_inheritance = data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany >( p_MemoryLayout_Concrete_Dimensions_LinkReference, this );
    }
    void Concrete_Dimensions_LinkMany::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkMany::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_LinkReference );
    }
    void Concrete_Dimensions_LinkMany::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_LinkMany" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Concrete_Dimensions_Allocation : public mega::io::Object
    Concrete_Dimensions_Allocation::Concrete_Dimensions_Allocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >( loader, this ) )          , parent( loader )
          , part( loader )
    {
    }
    Concrete_Dimensions_Allocation::Concrete_Dimensions_Allocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >( loader, this ) )          , parent( parent )
    {
    }
    bool Concrete_Dimensions_Allocation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >( loader, const_cast< Concrete_Dimensions_Allocation* >( this ) ) };
    }
    void Concrete_Dimensions_Allocation::set_inheritance_pointer()
    {
    }
    void Concrete_Dimensions_Allocation::load( mega::io::Loader& loader )
    {
        loader.load( parent );
        loader.load( part );
    }
    void Concrete_Dimensions_Allocation::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
        VERIFY_RTE_MSG( part.has_value(), "MemoryLayout::Concrete_Dimensions_Allocation.part has NOT been set" );
        storer.store( part );
    }
    void Concrete_Dimensions_Allocation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_Allocation" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "part", part.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Dimensions_Allocator : public mega::io::Object
    Concrete_Dimensions_Allocator::Concrete_Dimensions_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_Allocation( loader )
          , allocator( loader )
    {
    }
    Concrete_Dimensions_Allocator::Concrete_Dimensions_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::MemoryLayout::Allocators_Allocator >& allocator)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( loader, this ) )          , p_MemoryLayout_Concrete_Dimensions_Allocation( loader )
          , allocator( allocator )
    {
    }
    bool Concrete_Dimensions_Allocator::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >{ data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( loader, const_cast< Concrete_Dimensions_Allocator* >( this ) ) };
    }
    void Concrete_Dimensions_Allocator::set_inheritance_pointer()
    {
        p_MemoryLayout_Concrete_Dimensions_Allocation->m_inheritance = data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator >( p_MemoryLayout_Concrete_Dimensions_Allocation, this );
    }
    void Concrete_Dimensions_Allocator::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Concrete_Dimensions_Allocation );
        loader.load( allocator );
    }
    void Concrete_Dimensions_Allocator::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Concrete_Dimensions_Allocation );
        storer.store( allocator );
    }
    void Concrete_Dimensions_Allocator::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Dimensions_Allocator" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocator", allocator } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Context : public mega::io::Object
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( loader )
          , allocator( loader )
    {
    }
    Concrete_Context::Concrete_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Context > p_Concrete_Concrete_Context, const data::Ptr< data::MemoryLayout::Allocators_Allocator >& allocator, const std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& allocation_dimensions)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Context( p_Concrete_Concrete_Context )
          , allocator( allocator )
          , allocation_dimensions( allocation_dimensions )
    {
    }
    bool Concrete_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Context::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Context->p_MemoryLayout_Concrete_Context = data::Ptr< data::MemoryLayout::Concrete_Context >( p_Concrete_Concrete_Context, this );
    }
    void Concrete_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Context );
        loader.load( allocator );
        loader.load( allocation_dimensions );
    }
    void Concrete_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Context );
        storer.store( allocator );
        storer.store( allocation_dimensions );
    }
    void Concrete_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Context" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocator", allocator } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocation_dimensions", allocation_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Action : public mega::io::Object
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Action( loader )
    {
    }
    Concrete_Action::Concrete_Action( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Action > p_Concrete_Concrete_Action, const std::size_t& local_size, const std::size_t& total_size)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Action( p_Concrete_Concrete_Action )
          , local_size( local_size )
          , total_size( total_size )
    {
    }
    bool Concrete_Action::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Action::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Action->p_MemoryLayout_Concrete_Action = data::Ptr< data::MemoryLayout::Concrete_Action >( p_Concrete_Concrete_Action, this );
    }
    void Concrete_Action::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Action );
        loader.load( local_size );
        loader.load( total_size );
    }
    void Concrete_Action::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Action );
        storer.store( local_size );
        storer.store( total_size );
    }
    void Concrete_Action::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Action" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "local_size", local_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Event : public mega::io::Object
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Event( loader )
    {
    }
    Concrete_Event::Concrete_Event( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Event > p_Concrete_Concrete_Event, const std::size_t& local_size, const std::size_t& total_size)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Event( p_Concrete_Concrete_Event )
          , local_size( local_size )
          , total_size( total_size )
    {
    }
    bool Concrete_Event::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Event::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Event->p_MemoryLayout_Concrete_Event = data::Ptr< data::MemoryLayout::Concrete_Event >( p_Concrete_Concrete_Event, this );
    }
    void Concrete_Event::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Event );
        loader.load( local_size );
        loader.load( total_size );
    }
    void Concrete_Event::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Event );
        storer.store( local_size );
        storer.store( total_size );
    }
    void Concrete_Event::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Event" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "local_size", local_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Object : public mega::io::Object
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Object( loader )
    {
    }
    Concrete_Object::Concrete_Object( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Object > p_Concrete_Concrete_Object, const std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& buffers)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Object( p_Concrete_Concrete_Object )
          , buffers( buffers )
    {
    }
    bool Concrete_Object::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Object::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Object->p_MemoryLayout_Concrete_Object = data::Ptr< data::MemoryLayout::Concrete_Object >( p_Concrete_Concrete_Object, this );
    }
    void Concrete_Object::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Object );
        loader.load( buffers );
    }
    void Concrete_Object::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Object );
        storer.store( buffers );
    }
    void Concrete_Object::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Object" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "buffers", buffers } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Link : public mega::io::Object
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Link( loader )
          , link_reference( loader )
    {
    }
    Concrete_Link::Concrete_Link( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Link > p_Concrete_Concrete_Link, const std::size_t& total_size, const data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& link_reference)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Link( p_Concrete_Concrete_Link )
          , total_size( total_size )
          , link_reference( link_reference )
    {
    }
    bool Concrete_Link::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Link::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Link->p_MemoryLayout_Concrete_Link = data::Ptr< data::MemoryLayout::Concrete_Link >( p_Concrete_Concrete_Link, this );
    }
    void Concrete_Link::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Link );
        loader.load( total_size );
        loader.load( link_reference );
    }
    void Concrete_Link::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Link );
        storer.store( total_size );
        storer.store( link_reference );
    }
    void Concrete_Link::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Link" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_reference", link_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Concrete_Buffer : public mega::io::Object
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Buffer( loader )
    {
    }
    Concrete_Buffer::Concrete_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, Ptr< Concrete::Concrete_Buffer > p_Concrete_Concrete_Buffer, const std::size_t& total_size)
        :   mega::io::Object( objectInfo )          , p_Concrete_Concrete_Buffer( p_Concrete_Concrete_Buffer )
          , total_size( total_size )
    {
    }
    bool Concrete_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return false;
    }
    void Concrete_Buffer::set_inheritance_pointer()
    {
        p_Concrete_Concrete_Buffer->p_MemoryLayout_Concrete_Buffer = data::Ptr< data::MemoryLayout::Concrete_Buffer >( p_Concrete_Concrete_Buffer, this );
    }
    void Concrete_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( p_Concrete_Concrete_Buffer );
        loader.load( total_size );
    }
    void Concrete_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Concrete_Concrete_Buffer );
        storer.store( total_size );
    }
    void Concrete_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Concrete_Buffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "total_size", total_size } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Allocators_Allocator : public mega::io::Object
    Allocators_Allocator::Allocators_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Allocator >( loader, this ) )          , allocated_context( loader )
    {
    }
    Allocators_Allocator::Allocators_Allocator( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Concrete::Concrete_Context > >& parent_context, const data::Ptr< data::Concrete::Concrete_Context >& allocated_context)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Allocator >( loader, this ) )          , parent_context( parent_context )
          , allocated_context( allocated_context )
    {
    }
    bool Allocators_Allocator::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Allocator >( loader, const_cast< Allocators_Allocator* >( this ) ) };
    }
    void Allocators_Allocator::set_inheritance_pointer()
    {
    }
    void Allocators_Allocator::load( mega::io::Loader& loader )
    {
        loader.load( parent_context );
        loader.load( allocated_context );
        loader.load( dimension );
    }
    void Allocators_Allocator::store( mega::io::Storer& storer ) const
    {
        storer.store( parent_context );
        storer.store( allocated_context );
        VERIFY_RTE_MSG( dimension.has_value(), "MemoryLayout::Allocators_Allocator.dimension has NOT been set" );
        storer.store( dimension );
    }
    void Allocators_Allocator::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Allocator" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent_context", parent_context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocated_context", allocated_context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Allocators_Nothing : public mega::io::Object
    Allocators_Nothing::Allocators_Nothing( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Nothing >( loader, this ) )          , p_MemoryLayout_Allocators_Allocator( loader )
    {
    }
    bool Allocators_Nothing::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Nothing >( loader, const_cast< Allocators_Nothing* >( this ) ) };
    }
    void Allocators_Nothing::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Allocator->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Nothing >( p_MemoryLayout_Allocators_Allocator, this );
    }
    void Allocators_Nothing::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Nothing::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Nothing::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Nothing" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Singleton : public mega::io::Object
    Allocators_Singleton::Allocators_Singleton( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Singleton >( loader, this ) )          , p_MemoryLayout_Allocators_Allocator( loader )
    {
    }
    bool Allocators_Singleton::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Singleton >( loader, const_cast< Allocators_Singleton* >( this ) ) };
    }
    void Allocators_Singleton::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Allocator->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Singleton >( p_MemoryLayout_Allocators_Allocator, this );
    }
    void Allocators_Singleton::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Singleton::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Singleton::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Singleton" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Range : public mega::io::Object
    Allocators_Range::Allocators_Range( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Range >( loader, this ) )          , p_MemoryLayout_Allocators_Allocator( loader )
    {
    }
    bool Allocators_Range::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Range >( loader, const_cast< Allocators_Range* >( this ) ) };
    }
    void Allocators_Range::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Allocator->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Range >( p_MemoryLayout_Allocators_Allocator, this );
    }
    void Allocators_Range::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Range::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Allocator );
    }
    void Allocators_Range::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Range" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Range32 : public mega::io::Object
    Allocators_Range32::Allocators_Range32( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Range32 >( loader, this ) )          , p_MemoryLayout_Allocators_Range( loader )
    {
    }
    bool Allocators_Range32::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Range32 >( loader, const_cast< Allocators_Range32* >( this ) ) };
    }
    void Allocators_Range32::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Range->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Range32 >( p_MemoryLayout_Allocators_Range, this );
    }
    void Allocators_Range32::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range32::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range32::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Range32" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_Range64 : public mega::io::Object
    Allocators_Range64::Allocators_Range64( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_Range64 >( loader, this ) )          , p_MemoryLayout_Allocators_Range( loader )
    {
    }
    bool Allocators_Range64::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_Range64 >( loader, const_cast< Allocators_Range64* >( this ) ) };
    }
    void Allocators_Range64::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Range->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_Range64 >( p_MemoryLayout_Allocators_Range, this );
    }
    void Allocators_Range64::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range64::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_Range64::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_Range64" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Allocators_RangeAny : public mega::io::Object
    Allocators_RangeAny::Allocators_RangeAny( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::Allocators_RangeAny >( loader, this ) )          , p_MemoryLayout_Allocators_Range( loader )
    {
    }
    bool Allocators_RangeAny::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >{ data::Ptr< data::MemoryLayout::Allocators_RangeAny >( loader, const_cast< Allocators_RangeAny* >( this ) ) };
    }
    void Allocators_RangeAny::set_inheritance_pointer()
    {
        p_MemoryLayout_Allocators_Range->m_inheritance = data::Ptr< data::MemoryLayout::Allocators_RangeAny >( p_MemoryLayout_Allocators_Range, this );
    }
    void Allocators_RangeAny::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_RangeAny::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_Allocators_Range );
    }
    void Allocators_RangeAny::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Allocators_RangeAny" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct MemoryLayout_Part : public mega::io::Object
    MemoryLayout_Part::MemoryLayout_Part( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Part >( loader, this ) )          , context( loader )
    {
    }
    MemoryLayout_Part::MemoryLayout_Part( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& context, const std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& user_dimensions, const std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& link_dimensions, const std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& allocation_dimensions)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Part >( loader, this ) )          , context( context )
          , user_dimensions( user_dimensions )
          , link_dimensions( link_dimensions )
          , allocation_dimensions( allocation_dimensions )
    {
    }
    bool MemoryLayout_Part::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >{ data::Ptr< data::MemoryLayout::MemoryLayout_Part >( loader, const_cast< MemoryLayout_Part* >( this ) ) };
    }
    void MemoryLayout_Part::set_inheritance_pointer()
    {
    }
    void MemoryLayout_Part::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( user_dimensions );
        loader.load( link_dimensions );
        loader.load( allocation_dimensions );
    }
    void MemoryLayout_Part::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( user_dimensions );
        storer.store( link_dimensions );
        storer.store( allocation_dimensions );
    }
    void MemoryLayout_Part::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_Part" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "user_dimensions", user_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "link_dimensions", link_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "allocation_dimensions", allocation_dimensions } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct MemoryLayout_Buffer : public mega::io::Object
    MemoryLayout_Buffer::MemoryLayout_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >( loader, this ) )    {
    }
    MemoryLayout_Buffer::MemoryLayout_Buffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& parts)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >( loader, this ) )          , parts( parts )
    {
    }
    bool MemoryLayout_Buffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >( loader, const_cast< MemoryLayout_Buffer* >( this ) ) };
    }
    void MemoryLayout_Buffer::set_inheritance_pointer()
    {
    }
    void MemoryLayout_Buffer::load( mega::io::Loader& loader )
    {
        loader.load( parts );
    }
    void MemoryLayout_Buffer::store( mega::io::Storer& storer ) const
    {
        storer.store( parts );
    }
    void MemoryLayout_Buffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_Buffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parts", parts } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct MemoryLayout_NonSimpleBuffer : public mega::io::Object
    MemoryLayout_NonSimpleBuffer::MemoryLayout_NonSimpleBuffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >( loader, this ) )          , p_MemoryLayout_MemoryLayout_Buffer( loader )
    {
    }
    bool MemoryLayout_NonSimpleBuffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >( loader, const_cast< MemoryLayout_NonSimpleBuffer* >( this ) ) };
    }
    void MemoryLayout_NonSimpleBuffer::set_inheritance_pointer()
    {
        p_MemoryLayout_MemoryLayout_Buffer->m_inheritance = data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >( p_MemoryLayout_MemoryLayout_Buffer, this );
    }
    void MemoryLayout_NonSimpleBuffer::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_NonSimpleBuffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_NonSimpleBuffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_NonSimpleBuffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct MemoryLayout_SimpleBuffer : public mega::io::Object
    MemoryLayout_SimpleBuffer::MemoryLayout_SimpleBuffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >( loader, this ) )          , p_MemoryLayout_MemoryLayout_Buffer( loader )
    {
    }
    bool MemoryLayout_SimpleBuffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >( loader, const_cast< MemoryLayout_SimpleBuffer* >( this ) ) };
    }
    void MemoryLayout_SimpleBuffer::set_inheritance_pointer()
    {
        p_MemoryLayout_MemoryLayout_Buffer->m_inheritance = data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >( p_MemoryLayout_MemoryLayout_Buffer, this );
    }
    void MemoryLayout_SimpleBuffer::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_SimpleBuffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_SimpleBuffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_SimpleBuffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct MemoryLayout_GPUBuffer : public mega::io::Object
    MemoryLayout_GPUBuffer::MemoryLayout_GPUBuffer( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >( loader, this ) )          , p_MemoryLayout_MemoryLayout_Buffer( loader )
    {
    }
    bool MemoryLayout_GPUBuffer::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >{ data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >( loader, const_cast< MemoryLayout_GPUBuffer* >( this ) ) };
    }
    void MemoryLayout_GPUBuffer::set_inheritance_pointer()
    {
        p_MemoryLayout_MemoryLayout_Buffer->m_inheritance = data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer >( p_MemoryLayout_MemoryLayout_Buffer, this );
    }
    void MemoryLayout_GPUBuffer::load( mega::io::Loader& loader )
    {
        loader.load( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_GPUBuffer::store( mega::io::Storer& storer ) const
    {
        storer.store( p_MemoryLayout_MemoryLayout_Buffer );
    }
    void MemoryLayout_GPUBuffer::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "MemoryLayout_GPUBuffer" },
                { "filetype" , "MemoryLayout" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
}
namespace Operations
{
    // struct Invocations_Variables_Variable : public mega::io::Object
    Invocations_Variables_Variable::Invocations_Variables_Variable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Variable >( loader, this ) )    {
    }
    Invocations_Variables_Variable::Invocations_Variables_Variable( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& parent)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Variable >( loader, this ) )          , parent( parent )
    {
    }
    bool Invocations_Variables_Variable::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Variable >( loader, const_cast< Invocations_Variables_Variable* >( this ) ) };
    }
    void Invocations_Variables_Variable::set_inheritance_pointer()
    {
    }
    void Invocations_Variables_Variable::load( mega::io::Loader& loader )
    {
        loader.load( parent );
    }
    void Invocations_Variables_Variable::store( mega::io::Storer& storer ) const
    {
        storer.store( parent );
    }
    void Invocations_Variables_Variable::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Variable" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "parent", parent } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Variables_Instance : public mega::io::Object
    Invocations_Variables_Instance::Invocations_Variables_Instance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Instance >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
          , concrete( loader )
    {
    }
    Invocations_Variables_Instance::Invocations_Variables_Instance( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Concrete::Concrete_Context >& concrete)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Instance >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
          , concrete( concrete )
    {
    }
    bool Invocations_Variables_Instance::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Instance >( loader, const_cast< Invocations_Variables_Instance* >( this ) ) };
    }
    void Invocations_Variables_Instance::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Variable->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Instance >( p_Operations_Invocations_Variables_Variable, this );
    }
    void Invocations_Variables_Instance::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Variable );
        loader.load( concrete );
    }
    void Invocations_Variables_Instance::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Variable );
        storer.store( concrete );
    }
    void Invocations_Variables_Instance::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Instance" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Variables_Reference : public mega::io::Object
    Invocations_Variables_Reference::Invocations_Variables_Reference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Reference >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
    {
    }
    Invocations_Variables_Reference::Invocations_Variables_Reference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Concrete::Concrete_Context > >& types)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Reference >( loader, this ) )          , p_Operations_Invocations_Variables_Variable( loader )
          , types( types )
    {
    }
    bool Invocations_Variables_Reference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Reference >( loader, const_cast< Invocations_Variables_Reference* >( this ) ) };
    }
    void Invocations_Variables_Reference::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Variable->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Reference >( p_Operations_Invocations_Variables_Variable, this );
    }
    void Invocations_Variables_Reference::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Variable );
        loader.load( types );
    }
    void Invocations_Variables_Reference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Variable );
        storer.store( types );
    }
    void Invocations_Variables_Reference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Reference" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "types", types } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Variables_Dimension : public mega::io::Object
    Invocations_Variables_Dimension::Invocations_Variables_Dimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Dimension >( loader, this ) )          , p_Operations_Invocations_Variables_Reference( loader )
    {
    }
    bool Invocations_Variables_Dimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Dimension >( loader, const_cast< Invocations_Variables_Dimension* >( this ) ) };
    }
    void Invocations_Variables_Dimension::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Reference->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Dimension >( p_Operations_Invocations_Variables_Reference, this );
    }
    void Invocations_Variables_Dimension::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Dimension::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Dimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Dimension" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Variables_Context : public mega::io::Object
    Invocations_Variables_Context::Invocations_Variables_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Variables_Context >( loader, this ) )          , p_Operations_Invocations_Variables_Reference( loader )
    {
    }
    bool Invocations_Variables_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >{ data::Ptr< data::Operations::Invocations_Variables_Context >( loader, const_cast< Invocations_Variables_Context* >( this ) ) };
    }
    void Invocations_Variables_Context::set_inheritance_pointer()
    {
        p_Operations_Invocations_Variables_Reference->m_inheritance = data::Ptr< data::Operations::Invocations_Variables_Context >( p_Operations_Invocations_Variables_Reference, this );
    }
    void Invocations_Variables_Context::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Variables_Reference );
    }
    void Invocations_Variables_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Variables_Context" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_Instruction : public mega::io::Object
    Invocations_Instructions_Instruction::Invocations_Instructions_Instruction( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Instruction >( loader, this ) )    {
    }
    bool Invocations_Instructions_Instruction::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Instruction >( loader, const_cast< Invocations_Instructions_Instruction* >( this ) ) };
    }
    void Invocations_Instructions_Instruction::set_inheritance_pointer()
    {
    }
    void Invocations_Instructions_Instruction::load( mega::io::Loader& loader )
    {
    }
    void Invocations_Instructions_Instruction::store( mega::io::Storer& storer ) const
    {
    }
    void Invocations_Instructions_Instruction::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Instruction" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_InstructionGroup : public mega::io::Object
    Invocations_Instructions_InstructionGroup::Invocations_Instructions_InstructionGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
    {
    }
    Invocations_Instructions_InstructionGroup::Invocations_Instructions_InstructionGroup( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
          , children( children )
    {
    }
    bool Invocations_Instructions_InstructionGroup::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( loader, const_cast< Invocations_Instructions_InstructionGroup* >( this ) ) };
    }
    void Invocations_Instructions_InstructionGroup::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_Instruction->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >( p_Operations_Invocations_Instructions_Instruction, this );
    }
    void Invocations_Instructions_InstructionGroup::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_Instruction );
        loader.load( children );
    }
    void Invocations_Instructions_InstructionGroup::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_Instruction );
        storer.store( children );
    }
    void Invocations_Instructions_InstructionGroup::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_InstructionGroup" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_Root : public mega::io::Object
    Invocations_Instructions_Root::Invocations_Instructions_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Root >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , context( loader )
    {
    }
    Invocations_Instructions_Root::Invocations_Instructions_Root( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Context >& context)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Root >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , context( context )
    {
    }
    bool Invocations_Instructions_Root::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Root >( loader, const_cast< Invocations_Instructions_Root* >( this ) ) };
    }
    void Invocations_Instructions_Root::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Root >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Root::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( context );
    }
    void Invocations_Instructions_Root::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( context );
    }
    void Invocations_Instructions_Root::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Root" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_ParentDerivation : public mega::io::Object
    Invocations_Instructions_ParentDerivation::Invocations_Instructions_ParentDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_ParentDerivation::Invocations_Instructions_ParentDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& from, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( from )
          , to( to )
    {
    }
    bool Invocations_Instructions_ParentDerivation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( loader, const_cast< Invocations_Instructions_ParentDerivation* >( this ) ) };
    }
    void Invocations_Instructions_ParentDerivation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_ParentDerivation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from );
        loader.load( to );
    }
    void Invocations_Instructions_ParentDerivation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from );
        storer.store( to );
    }
    void Invocations_Instructions_ParentDerivation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_ParentDerivation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from", from } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_ChildDerivation : public mega::io::Object
    Invocations_Instructions_ChildDerivation::Invocations_Instructions_ChildDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_ChildDerivation::Invocations_Instructions_ChildDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& from, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( from )
          , to( to )
    {
    }
    bool Invocations_Instructions_ChildDerivation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( loader, const_cast< Invocations_Instructions_ChildDerivation* >( this ) ) };
    }
    void Invocations_Instructions_ChildDerivation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_ChildDerivation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from );
        loader.load( to );
    }
    void Invocations_Instructions_ChildDerivation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from );
        storer.store( to );
    }
    void Invocations_Instructions_ChildDerivation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_ChildDerivation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from", from } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_EnumDerivation : public mega::io::Object
    Invocations_Instructions_EnumDerivation::Invocations_Instructions_EnumDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_EnumDerivation::Invocations_Instructions_EnumDerivation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& from, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from( from )
          , to( to )
    {
    }
    bool Invocations_Instructions_EnumDerivation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( loader, const_cast< Invocations_Instructions_EnumDerivation* >( this ) ) };
    }
    void Invocations_Instructions_EnumDerivation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_EnumDerivation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from );
        loader.load( to );
    }
    void Invocations_Instructions_EnumDerivation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from );
        storer.store( to );
    }
    void Invocations_Instructions_EnumDerivation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_EnumDerivation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from", from } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_Enumeration : public mega::io::Object
    Invocations_Instructions_Enumeration::Invocations_Instructions_Enumeration( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( loader )
    {
    }
    Invocations_Instructions_Enumeration::Invocations_Instructions_Enumeration( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( instance )
    {
    }
    bool Invocations_Instructions_Enumeration::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( loader, const_cast< Invocations_Instructions_Enumeration* >( this ) ) };
    }
    void Invocations_Instructions_Enumeration::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Enumeration >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Enumeration::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( instance );
    }
    void Invocations_Instructions_Enumeration::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( instance );
    }
    void Invocations_Instructions_Enumeration::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Enumeration" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_DimensionReferenceRead : public mega::io::Object
    Invocations_Instructions_DimensionReferenceRead::Invocations_Instructions_DimensionReferenceRead( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( loader )
          , dimension_reference( loader )
          , concrete( loader )
    {
    }
    Invocations_Instructions_DimensionReferenceRead::Invocations_Instructions_DimensionReferenceRead( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance, const data::Ptr< data::Operations::Invocations_Variables_Dimension >& dimension_reference, const data::Ptr< data::Concrete::Concrete_Dimensions_User >& concrete)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , instance( instance )
          , dimension_reference( dimension_reference )
          , concrete( concrete )
    {
    }
    bool Invocations_Instructions_DimensionReferenceRead::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( loader, const_cast< Invocations_Instructions_DimensionReferenceRead* >( this ) ) };
    }
    void Invocations_Instructions_DimensionReferenceRead::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_DimensionReferenceRead::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( instance );
        loader.load( dimension_reference );
        loader.load( concrete );
    }
    void Invocations_Instructions_DimensionReferenceRead::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( instance );
        storer.store( dimension_reference );
        storer.store( concrete );
    }
    void Invocations_Instructions_DimensionReferenceRead::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_DimensionReferenceRead" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_reference", dimension_reference } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_MonoReference : public mega::io::Object
    Invocations_Instructions_MonoReference::Invocations_Instructions_MonoReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( loader )
          , instance( loader )
    {
    }
    Invocations_Instructions_MonoReference::Invocations_Instructions_MonoReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Reference >& reference, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( reference )
          , instance( instance )
    {
    }
    bool Invocations_Instructions_MonoReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( loader, const_cast< Invocations_Instructions_MonoReference* >( this ) ) };
    }
    void Invocations_Instructions_MonoReference::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_MonoReference >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_MonoReference::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( reference );
        loader.load( instance );
    }
    void Invocations_Instructions_MonoReference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( reference );
        storer.store( instance );
    }
    void Invocations_Instructions_MonoReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_MonoReference" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "reference", reference } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_PolyReference : public mega::io::Object
    Invocations_Instructions_PolyReference::Invocations_Instructions_PolyReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from_reference( loader )
    {
    }
    Invocations_Instructions_PolyReference::Invocations_Instructions_PolyReference( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Reference >& from_reference)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , from_reference( from_reference )
    {
    }
    bool Invocations_Instructions_PolyReference::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( loader, const_cast< Invocations_Instructions_PolyReference* >( this ) ) };
    }
    void Invocations_Instructions_PolyReference::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_PolyReference >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_PolyReference::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( from_reference );
    }
    void Invocations_Instructions_PolyReference::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( from_reference );
    }
    void Invocations_Instructions_PolyReference::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_PolyReference" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "from_reference", from_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_PolyCase : public mega::io::Object
    Invocations_Instructions_PolyCase::Invocations_Instructions_PolyCase( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( loader )
          , to( loader )
    {
    }
    Invocations_Instructions_PolyCase::Invocations_Instructions_PolyCase( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Reference >& reference, const data::Ptr< data::Operations::Invocations_Variables_Instance >& to)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
          , reference( reference )
          , to( to )
    {
    }
    bool Invocations_Instructions_PolyCase::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( loader, const_cast< Invocations_Instructions_PolyCase* >( this ) ) };
    }
    void Invocations_Instructions_PolyCase::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_PolyCase >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_PolyCase::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
        loader.load( reference );
        loader.load( to );
    }
    void Invocations_Instructions_PolyCase::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
        storer.store( reference );
        storer.store( to );
    }
    void Invocations_Instructions_PolyCase::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_PolyCase" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "reference", reference } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "to", to } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Instructions_Failure : public mega::io::Object
    Invocations_Instructions_Failure::Invocations_Instructions_Failure( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Failure >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
    {
    }
    bool Invocations_Instructions_Failure::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Failure >( loader, const_cast< Invocations_Instructions_Failure* >( this ) ) };
    }
    void Invocations_Instructions_Failure::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Failure >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Failure::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Failure::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Failure::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Failure" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_Elimination : public mega::io::Object
    Invocations_Instructions_Elimination::Invocations_Instructions_Elimination( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Elimination >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
    {
    }
    bool Invocations_Instructions_Elimination::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Elimination >( loader, const_cast< Invocations_Instructions_Elimination* >( this ) ) };
    }
    void Invocations_Instructions_Elimination::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Elimination >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Elimination::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Elimination::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Elimination::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Elimination" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Instructions_Prune : public mega::io::Object
    Invocations_Instructions_Prune::Invocations_Instructions_Prune( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Instructions_Prune >( loader, this ) )          , p_Operations_Invocations_Instructions_InstructionGroup( loader )
    {
    }
    bool Invocations_Instructions_Prune::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Instructions_Prune >( loader, const_cast< Invocations_Instructions_Prune* >( this ) ) };
    }
    void Invocations_Instructions_Prune::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_InstructionGroup->m_inheritance = data::Ptr< data::Operations::Invocations_Instructions_Prune >( p_Operations_Invocations_Instructions_InstructionGroup, this );
    }
    void Invocations_Instructions_Prune::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Prune::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_InstructionGroup );
    }
    void Invocations_Instructions_Prune::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Instructions_Prune" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Operation : public mega::io::Object
    Invocations_Operations_Operation::Invocations_Operations_Operation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Operation >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
          , instance( loader )
    {
    }
    Invocations_Operations_Operation::Invocations_Operations_Operation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Instance >& instance, const std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& return_types, const std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& parameter_types)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Operation >( loader, this ) )          , p_Operations_Invocations_Instructions_Instruction( loader )
          , instance( instance )
          , return_types( return_types )
          , parameter_types( parameter_types )
    {
    }
    bool Invocations_Operations_Operation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Operation >( loader, const_cast< Invocations_Operations_Operation* >( this ) ) };
    }
    void Invocations_Operations_Operation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Instructions_Instruction->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Operation >( p_Operations_Invocations_Instructions_Instruction, this );
    }
    void Invocations_Operations_Operation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Instructions_Instruction );
        loader.load( instance );
        loader.load( return_types );
        loader.load( parameter_types );
    }
    void Invocations_Operations_Operation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Instructions_Instruction );
        storer.store( instance );
        storer.store( return_types );
        storer.store( parameter_types );
    }
    void Invocations_Operations_Operation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Operation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "instance", instance } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_types", return_types } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "parameter_types", parameter_types } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_BasicOperation : public mega::io::Object
    Invocations_Operations_BasicOperation::Invocations_Operations_BasicOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface( loader )
          , concrete_target( loader )
    {
    }
    Invocations_Operations_BasicOperation::Invocations_Operations_BasicOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_IContext >& interface, const data::Ptr< data::Concrete::Concrete_Context >& concrete_target)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface( interface )
          , concrete_target( concrete_target )
    {
    }
    bool Invocations_Operations_BasicOperation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( loader, const_cast< Invocations_Operations_BasicOperation* >( this ) ) };
    }
    void Invocations_Operations_BasicOperation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_Operation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_BasicOperation >( p_Operations_Invocations_Operations_Operation, this );
    }
    void Invocations_Operations_BasicOperation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_Operation );
        loader.load( interface );
        loader.load( concrete_target );
    }
    void Invocations_Operations_BasicOperation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_Operation );
        storer.store( interface );
        storer.store( concrete_target );
    }
    void Invocations_Operations_BasicOperation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_BasicOperation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface", interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_target", concrete_target } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_DimensionOperation : public mega::io::Object
    Invocations_Operations_DimensionOperation::Invocations_Operations_DimensionOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface_dimension( loader )
          , concrete_dimension( loader )
    {
    }
    Invocations_Operations_DimensionOperation::Invocations_Operations_DimensionOperation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Tree::Interface_DimensionTrait >& interface_dimension, const data::Ptr< data::Concrete::Concrete_Dimensions_User >& concrete_dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( loader, this ) )          , p_Operations_Invocations_Operations_Operation( loader )
          , interface_dimension( interface_dimension )
          , concrete_dimension( concrete_dimension )
    {
    }
    bool Invocations_Operations_DimensionOperation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( loader, const_cast< Invocations_Operations_DimensionOperation* >( this ) ) };
    }
    void Invocations_Operations_DimensionOperation::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_Operation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >( p_Operations_Invocations_Operations_Operation, this );
    }
    void Invocations_Operations_DimensionOperation::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_Operation );
        loader.load( interface_dimension );
        loader.load( concrete_dimension );
    }
    void Invocations_Operations_DimensionOperation::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_Operation );
        storer.store( interface_dimension );
        storer.store( concrete_dimension );
    }
    void Invocations_Operations_DimensionOperation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_DimensionOperation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface_dimension", interface_dimension } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete_dimension", concrete_dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_Allocate : public mega::io::Object
    Invocations_Operations_Allocate::Invocations_Operations_Allocate( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Allocate >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Allocate::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Allocate >( loader, const_cast< Invocations_Operations_Allocate* >( this ) ) };
    }
    void Invocations_Operations_Allocate::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Allocate >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Allocate::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Allocate::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Allocate::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Allocate" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Call : public mega::io::Object
    Invocations_Operations_Call::Invocations_Operations_Call( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Call >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Call::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Call >( loader, const_cast< Invocations_Operations_Call* >( this ) ) };
    }
    void Invocations_Operations_Call::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Call >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Call::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Call::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Call::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Call" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Start : public mega::io::Object
    Invocations_Operations_Start::Invocations_Operations_Start( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Start >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Start::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Start >( loader, const_cast< Invocations_Operations_Start* >( this ) ) };
    }
    void Invocations_Operations_Start::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Start >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Start::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Start::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Start::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Start" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Stop : public mega::io::Object
    Invocations_Operations_Stop::Invocations_Operations_Stop( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Stop >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Stop::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Stop >( loader, const_cast< Invocations_Operations_Stop* >( this ) ) };
    }
    void Invocations_Operations_Stop::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Stop >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Stop::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Stop::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Stop::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Stop" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Pause : public mega::io::Object
    Invocations_Operations_Pause::Invocations_Operations_Pause( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Pause >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Pause::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Pause >( loader, const_cast< Invocations_Operations_Pause* >( this ) ) };
    }
    void Invocations_Operations_Pause::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Pause >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Pause::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Pause::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Pause::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Pause" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Resume : public mega::io::Object
    Invocations_Operations_Resume::Invocations_Operations_Resume( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Resume >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Resume::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Resume >( loader, const_cast< Invocations_Operations_Resume* >( this ) ) };
    }
    void Invocations_Operations_Resume::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Resume >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Resume::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Resume::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Resume::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Resume" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Done : public mega::io::Object
    Invocations_Operations_Done::Invocations_Operations_Done( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Done >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Done::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Done >( loader, const_cast< Invocations_Operations_Done* >( this ) ) };
    }
    void Invocations_Operations_Done::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Done >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Done::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Done::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Done::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Done" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_WaitAction : public mega::io::Object
    Invocations_Operations_WaitAction::Invocations_Operations_WaitAction( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_WaitAction >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_WaitAction::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_WaitAction >( loader, const_cast< Invocations_Operations_WaitAction* >( this ) ) };
    }
    void Invocations_Operations_WaitAction::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_WaitAction >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_WaitAction::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_WaitAction::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_WaitAction::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_WaitAction" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_WaitDimension : public mega::io::Object
    Invocations_Operations_WaitDimension::Invocations_Operations_WaitDimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_WaitDimension >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_WaitDimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_WaitDimension >( loader, const_cast< Invocations_Operations_WaitDimension* >( this ) ) };
    }
    void Invocations_Operations_WaitDimension::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_WaitDimension >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_WaitDimension::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_WaitDimension::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_WaitDimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_WaitDimension" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_GetAction : public mega::io::Object
    Invocations_Operations_GetAction::Invocations_Operations_GetAction( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_GetAction >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_GetAction::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_GetAction >( loader, const_cast< Invocations_Operations_GetAction* >( this ) ) };
    }
    void Invocations_Operations_GetAction::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_GetAction >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_GetAction::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_GetAction::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_GetAction::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_GetAction" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_GetDimension : public mega::io::Object
    Invocations_Operations_GetDimension::Invocations_Operations_GetDimension( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_GetDimension >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_GetDimension::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_GetDimension >( loader, const_cast< Invocations_Operations_GetDimension* >( this ) ) };
    }
    void Invocations_Operations_GetDimension::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_GetDimension >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_GetDimension::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_GetDimension::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_GetDimension::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_GetDimension" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Read : public mega::io::Object
    Invocations_Operations_Read::Invocations_Operations_Read( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Read >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_Read::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Read >( loader, const_cast< Invocations_Operations_Read* >( this ) ) };
    }
    void Invocations_Operations_Read::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Read >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_Read::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Read::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Read::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Read" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_Write : public mega::io::Object
    Invocations_Operations_Write::Invocations_Operations_Write( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Write >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
    {
    }
    bool Invocations_Operations_Write::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Write >( loader, const_cast< Invocations_Operations_Write* >( this ) ) };
    }
    void Invocations_Operations_Write::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Write >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_Write::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Write::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
    }
    void Invocations_Operations_Write::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Write" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Invocations_Operations_WriteLink : public mega::io::Object
    Invocations_Operations_WriteLink::Invocations_Operations_WriteLink( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_WriteLink >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
          , dimension_reference( loader )
    {
    }
    Invocations_Operations_WriteLink::Invocations_Operations_WriteLink( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Invocations_Variables_Dimension >& dimension_reference)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_WriteLink >( loader, this ) )          , p_Operations_Invocations_Operations_DimensionOperation( loader )
          , dimension_reference( dimension_reference )
    {
    }
    bool Invocations_Operations_WriteLink::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_WriteLink >( loader, const_cast< Invocations_Operations_WriteLink* >( this ) ) };
    }
    void Invocations_Operations_WriteLink::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_DimensionOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_WriteLink >( p_Operations_Invocations_Operations_DimensionOperation, this );
    }
    void Invocations_Operations_WriteLink::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_DimensionOperation );
        loader.load( dimension_reference );
    }
    void Invocations_Operations_WriteLink::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_DimensionOperation );
        storer.store( dimension_reference );
    }
    void Invocations_Operations_WriteLink::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_WriteLink" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension_reference", dimension_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Invocations_Operations_Range : public mega::io::Object
    Invocations_Operations_Range::Invocations_Operations_Range( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Invocations_Operations_Range >( loader, this ) )          , p_Operations_Invocations_Operations_BasicOperation( loader )
    {
    }
    bool Invocations_Operations_Range::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >{ data::Ptr< data::Operations::Invocations_Operations_Range >( loader, const_cast< Invocations_Operations_Range* >( this ) ) };
    }
    void Invocations_Operations_Range::set_inheritance_pointer()
    {
        p_Operations_Invocations_Operations_BasicOperation->m_inheritance = data::Ptr< data::Operations::Invocations_Operations_Range >( p_Operations_Invocations_Operations_BasicOperation, this );
    }
    void Invocations_Operations_Range::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Range::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Invocations_Operations_BasicOperation );
    }
    void Invocations_Operations_Range::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Invocations_Operations_Range" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
    }
        
    // struct Operations_InterfaceVariant : public mega::io::Object
    Operations_InterfaceVariant::Operations_InterfaceVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_InterfaceVariant >( loader, this ) )    {
    }
    Operations_InterfaceVariant::Operations_InterfaceVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Tree::Interface_IContext > >& context, const std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_InterfaceVariant >( loader, this ) )          , context( context )
          , dimension( dimension )
    {
    }
    bool Operations_InterfaceVariant::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >{ data::Ptr< data::Operations::Operations_InterfaceVariant >( loader, const_cast< Operations_InterfaceVariant* >( this ) ) };
    }
    void Operations_InterfaceVariant::set_inheritance_pointer()
    {
    }
    void Operations_InterfaceVariant::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( dimension );
    }
    void Operations_InterfaceVariant::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( dimension );
    }
    void Operations_InterfaceVariant::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_InterfaceVariant" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_ConcreteVariant : public mega::io::Object
    Operations_ConcreteVariant::Operations_ConcreteVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ConcreteVariant >( loader, this ) )    {
    }
    Operations_ConcreteVariant::Operations_ConcreteVariant( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::optional< data::Ptr< data::Concrete::Concrete_Context > >& context, const std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& dimension)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ConcreteVariant >( loader, this ) )          , context( context )
          , dimension( dimension )
    {
    }
    bool Operations_ConcreteVariant::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >{ data::Ptr< data::Operations::Operations_ConcreteVariant >( loader, const_cast< Operations_ConcreteVariant* >( this ) ) };
    }
    void Operations_ConcreteVariant::set_inheritance_pointer()
    {
    }
    void Operations_ConcreteVariant::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( dimension );
    }
    void Operations_ConcreteVariant::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( dimension );
    }
    void Operations_ConcreteVariant::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_ConcreteVariant" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "dimension", dimension } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Element : public mega::io::Object
    Operations_Element::Operations_Element( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Element >( loader, this ) )          , interface( loader )
          , concrete( loader )
    {
    }
    Operations_Element::Operations_Element( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_InterfaceVariant >& interface, const data::Ptr< data::Operations::Operations_ConcreteVariant >& concrete)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Element >( loader, this ) )          , interface( interface )
          , concrete( concrete )
    {
    }
    bool Operations_Element::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Element > >{ data::Ptr< data::Operations::Operations_Element >( loader, const_cast< Operations_Element* >( this ) ) };
    }
    void Operations_Element::set_inheritance_pointer()
    {
    }
    void Operations_Element::load( mega::io::Loader& loader )
    {
        loader.load( interface );
        loader.load( concrete );
    }
    void Operations_Element::store( mega::io::Storer& storer ) const
    {
        storer.store( interface );
        storer.store( concrete );
    }
    void Operations_Element::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Element" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "interface", interface } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "concrete", concrete } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_ElementVector : public mega::io::Object
    Operations_ElementVector::Operations_ElementVector( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ElementVector >( loader, this ) )    {
    }
    Operations_ElementVector::Operations_ElementVector( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_Element > >& elements)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_ElementVector >( loader, this ) )          , elements( elements )
    {
    }
    bool Operations_ElementVector::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_ElementVector > >{ data::Ptr< data::Operations::Operations_ElementVector >( loader, const_cast< Operations_ElementVector* >( this ) ) };
    }
    void Operations_ElementVector::set_inheritance_pointer()
    {
    }
    void Operations_ElementVector::load( mega::io::Loader& loader )
    {
        loader.load( elements );
    }
    void Operations_ElementVector::store( mega::io::Storer& storer ) const
    {
        storer.store( elements );
    }
    void Operations_ElementVector::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_ElementVector" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "elements", elements } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Context : public mega::io::Object
    Operations_Context::Operations_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Context >( loader, this ) )    {
    }
    Operations_Context::Operations_Context( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& vectors)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Context >( loader, this ) )          , vectors( vectors )
    {
    }
    bool Operations_Context::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Context > >{ data::Ptr< data::Operations::Operations_Context >( loader, const_cast< Operations_Context* >( this ) ) };
    }
    void Operations_Context::set_inheritance_pointer()
    {
    }
    void Operations_Context::load( mega::io::Loader& loader )
    {
        loader.load( vectors );
    }
    void Operations_Context::store( mega::io::Storer& storer ) const
    {
        storer.store( vectors );
    }
    void Operations_Context::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Context" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "vectors", vectors } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_TypePath : public mega::io::Object
    Operations_TypePath::Operations_TypePath( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_TypePath >( loader, this ) )    {
    }
    Operations_TypePath::Operations_TypePath( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& vectors)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_TypePath >( loader, this ) )          , vectors( vectors )
    {
    }
    bool Operations_TypePath::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_TypePath > >{ data::Ptr< data::Operations::Operations_TypePath >( loader, const_cast< Operations_TypePath* >( this ) ) };
    }
    void Operations_TypePath::set_inheritance_pointer()
    {
    }
    void Operations_TypePath::load( mega::io::Loader& loader )
    {
        loader.load( vectors );
    }
    void Operations_TypePath::store( mega::io::Storer& storer ) const
    {
        storer.store( vectors );
    }
    void Operations_TypePath::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_TypePath" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "vectors", vectors } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_NameRoot : public mega::io::Object
    Operations_NameRoot::Operations_NameRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameRoot >( loader, this ) )    {
    }
    Operations_NameRoot::Operations_NameRoot( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::vector< data::Ptr< data::Operations::Operations_Name > >& children)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameRoot >( loader, this ) )          , children( children )
    {
    }
    bool Operations_NameRoot::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >{ data::Ptr< data::Operations::Operations_NameRoot >( loader, const_cast< Operations_NameRoot* >( this ) ) };
    }
    void Operations_NameRoot::set_inheritance_pointer()
    {
    }
    void Operations_NameRoot::load( mega::io::Loader& loader )
    {
        loader.load( children );
    }
    void Operations_NameRoot::store( mega::io::Storer& storer ) const
    {
        storer.store( children );
    }
    void Operations_NameRoot::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_NameRoot" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "children", children } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Name : public mega::io::Object
    Operations_Name::Operations_Name( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Name >( loader, this ) )          , p_Operations_Operations_NameRoot( loader )
          , element( loader )
    {
    }
    Operations_Name::Operations_Name( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_Element >& element, const bool& is_member, const bool& is_reference)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Name >( loader, this ) )          , p_Operations_Operations_NameRoot( loader )
          , element( element )
          , is_member( is_member )
          , is_reference( is_reference )
    {
    }
    bool Operations_Name::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >{ data::Ptr< data::Operations::Operations_Name >( loader, const_cast< Operations_Name* >( this ) ) };
    }
    void Operations_Name::set_inheritance_pointer()
    {
        p_Operations_Operations_NameRoot->m_inheritance = data::Ptr< data::Operations::Operations_Name >( p_Operations_Operations_NameRoot, this );
    }
    void Operations_Name::load( mega::io::Loader& loader )
    {
        loader.load( p_Operations_Operations_NameRoot );
        loader.load( element );
        loader.load( is_member );
        loader.load( is_reference );
    }
    void Operations_Name::store( mega::io::Storer& storer ) const
    {
        storer.store( p_Operations_Operations_NameRoot );
        storer.store( element );
        storer.store( is_member );
        storer.store( is_reference );
    }
    void Operations_Name::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Name" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "element", element } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_member", is_member } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_reference", is_reference } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_NameResolution : public mega::io::Object
    Operations_NameResolution::Operations_NameResolution( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameResolution >( loader, this ) )          , root_name( loader )
    {
    }
    Operations_NameResolution::Operations_NameResolution( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_NameRoot >& root_name)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_NameResolution >( loader, this ) )          , root_name( root_name )
    {
    }
    bool Operations_NameResolution::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_NameResolution > >{ data::Ptr< data::Operations::Operations_NameResolution >( loader, const_cast< Operations_NameResolution* >( this ) ) };
    }
    void Operations_NameResolution::set_inheritance_pointer()
    {
    }
    void Operations_NameResolution::load( mega::io::Loader& loader )
    {
        loader.load( root_name );
    }
    void Operations_NameResolution::store( mega::io::Storer& storer ) const
    {
        storer.store( root_name );
    }
    void Operations_NameResolution::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_NameResolution" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "root_name", root_name } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Invocation : public mega::io::Object
    Operations_Invocation::Operations_Invocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocation >( loader, this ) )          , context( loader )
          , type_path( loader )
          , name_resolution( loader )
          , root_variable( loader )
          , root_instruction( loader )
    {
    }
    Operations_Invocation::Operations_Invocation( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const data::Ptr< data::Operations::Operations_Context >& context, const data::Ptr< data::Operations::Operations_TypePath >& type_path, const mega::OperationID& operation, const std::string& name, const std::string& context_str, const std::string& type_path_str)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocation >( loader, this ) )          , context( context )
          , type_path( type_path )
          , operation( operation )
          , name( name )
          , context_str( context_str )
          , type_path_str( type_path_str )
    {
    }
    bool Operations_Invocation::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Invocation > >{ data::Ptr< data::Operations::Operations_Invocation >( loader, const_cast< Operations_Invocation* >( this ) ) };
    }
    void Operations_Invocation::set_inheritance_pointer()
    {
    }
    void Operations_Invocation::load( mega::io::Loader& loader )
    {
        loader.load( context );
        loader.load( type_path );
        loader.load( operation );
        loader.load( name );
        loader.load( context_str );
        loader.load( type_path_str );
        loader.load( explicit_operation );
        loader.load( return_type_str );
        loader.load( runtime_return_type_str );
        loader.load( name_resolution );
        loader.load( root_variable );
        loader.load( root_instruction );
        loader.load( variables );
        loader.load( return_types_context );
        loader.load( return_types_dimension );
        loader.load( homogeneous );
        loader.load( is_function_call );
    }
    void Operations_Invocation::store( mega::io::Storer& storer ) const
    {
        storer.store( context );
        storer.store( type_path );
        storer.store( operation );
        storer.store( name );
        storer.store( context_str );
        storer.store( type_path_str );
        VERIFY_RTE_MSG( explicit_operation.has_value(), "Operations::Operations_Invocation.explicit_operation has NOT been set" );
        storer.store( explicit_operation );
        VERIFY_RTE_MSG( return_type_str.has_value(), "Operations::Operations_Invocation.return_type_str has NOT been set" );
        storer.store( return_type_str );
        VERIFY_RTE_MSG( runtime_return_type_str.has_value(), "Operations::Operations_Invocation.runtime_return_type_str has NOT been set" );
        storer.store( runtime_return_type_str );
        VERIFY_RTE_MSG( name_resolution.has_value(), "Operations::Operations_Invocation.name_resolution has NOT been set" );
        storer.store( name_resolution );
        VERIFY_RTE_MSG( root_variable.has_value(), "Operations::Operations_Invocation.root_variable has NOT been set" );
        storer.store( root_variable );
        VERIFY_RTE_MSG( root_instruction.has_value(), "Operations::Operations_Invocation.root_instruction has NOT been set" );
        storer.store( root_instruction );
        VERIFY_RTE_MSG( variables.has_value(), "Operations::Operations_Invocation.variables has NOT been set" );
        storer.store( variables );
        VERIFY_RTE_MSG( return_types_context.has_value(), "Operations::Operations_Invocation.return_types_context has NOT been set" );
        storer.store( return_types_context );
        VERIFY_RTE_MSG( return_types_dimension.has_value(), "Operations::Operations_Invocation.return_types_dimension has NOT been set" );
        storer.store( return_types_dimension );
        VERIFY_RTE_MSG( homogeneous.has_value(), "Operations::Operations_Invocation.homogeneous has NOT been set" );
        storer.store( homogeneous );
        VERIFY_RTE_MSG( is_function_call.has_value(), "Operations::Operations_Invocation.is_function_call has NOT been set" );
        storer.store( is_function_call );
    }
    void Operations_Invocation::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Invocation" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "context", context } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type_path", type_path } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "operation", operation } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "name", name } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "context_str", context_str } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "type_path_str", type_path_str } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "explicit_operation", explicit_operation.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_type_str", return_type_str.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "runtime_return_type_str", runtime_return_type_str.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "name_resolution", name_resolution.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "root_variable", root_variable.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "root_instruction", root_instruction.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "variables", variables.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_types_context", return_types_context.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "return_types_dimension", return_types_dimension.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "homogeneous", homogeneous.value() } } );
            _part__[ "properties" ].push_back( property );
        }
        {
            nlohmann::json property = nlohmann::json::object({
                { "is_function_call", is_function_call.value() } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
    // struct Operations_Invocations : public mega::io::Object
    Operations_Invocations::Operations_Invocations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocations >( loader, this ) )    {
    }
    Operations_Invocations::Operations_Invocations( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo, const std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& invocations)
        :   mega::io::Object( objectInfo ), m_inheritance( data::Ptr< data::Operations::Operations_Invocations >( loader, this ) )          , invocations( invocations )
    {
    }
    bool Operations_Invocations::test_inheritance_pointer( ObjectPartLoader &loader ) const
    {
        return m_inheritance == std::variant< data::Ptr< data::Operations::Operations_Invocations > >{ data::Ptr< data::Operations::Operations_Invocations >( loader, const_cast< Operations_Invocations* >( this ) ) };
    }
    void Operations_Invocations::set_inheritance_pointer()
    {
    }
    void Operations_Invocations::load( mega::io::Loader& loader )
    {
        loader.load( invocations );
    }
    void Operations_Invocations::store( mega::io::Storer& storer ) const
    {
        storer.store( invocations );
    }
    void Operations_Invocations::to_json( nlohmann::json& _part__ ) const
    {
        _part__ = nlohmann::json::object(
            { 
                { "partname", "Operations_Invocations" },
                { "filetype" , "Operations" },
                { "typeID", Object_Part_Type_ID },
                { "fileID", getFileID() },
                { "index", getIndex() }, 
                { "properties", nlohmann::json::array() }
            });
        {
            nlohmann::json property = nlohmann::json::object({
                { "invocations", invocations } } );
            _part__[ "properties" ].push_back( property );
        }
    }
        
}


std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& get_abstract_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_AbstractDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_abstract_defs" );
                return part->abstract_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_abstract_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ActionDef > >& get_action_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ActionDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_action_defs" );
                return part->action_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_action_defs" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_allocated_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Nothing > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Singleton > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range32 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range64 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocated_context" );
                return part->allocated_context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_allocated_context" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& get_allocation_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_allocation_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& get_allocation_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_allocation_dimensions" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& get_allocator(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::Allocators_Allocator >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else
            {
                THROW_RTE( "Invalid call to get_allocator" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& get_allocator(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::Allocators_Allocator >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_allocator" );
                return part->allocator;
            }
            else
            {
                THROW_RTE( "Invalid call to get_allocator" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ArgumentList >& get_argumentList(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ArgumentList >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_FunctionDef > part = 
                    data::convert< data::AST::Parser_FunctionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_argumentList" );
                return part->argumentList;
            }
            else
            {
                THROW_RTE( "Invalid call to get_argumentList" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& get_arguments_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_arguments_trait" );
                return part->arguments_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to get_arguments_trait" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ContextDef >& get_ast(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ContextDef >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ast" );
                return part->ast;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_IncludeRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ast" );
                return part->ast;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectSourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ast" );
                return part->ast;
            }
            else
            {
                THROW_RTE( "Invalid call to get_ast" );
            }
        }
        , m_data );
}
std::string& get_body(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_body" );
                return part->body;
            }
            else
            {
                THROW_RTE( "Invalid call to get_body" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_BufferDef > >& get_buffer_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_BufferDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_Buffer > part = 
                    data::convert< data::Tree::Interface_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_buffer_defs" );
                return part->buffer_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_buffer_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& get_buffers(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Object > part = 
                    data::convert< data::MemoryLayout::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_buffers" );
                return part->buffers;
            }
            else
            {
                THROW_RTE( "Invalid call to get_buffers" );
            }
        }
        , m_data );
}
boost::filesystem::path& get_build_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_build_dir" );
                return part->build_dir;
            }
            else
            {
                THROW_RTE( "Invalid call to get_build_dir" );
            }
        }
        , m_data );
}
std::string& get_canonical_type(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_canonical_type" );
                return part->canonical_type;
            }
            else
            {
                THROW_RTE( "Invalid call to get_canonical_type" );
            }
        }
        , m_data );
}
std::string& get_canonical_type(std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >)
            {
                data::Ptr< data::Clang::Interface_ReturnTypeTrait > part = 
                    data::convert< data::Clang::Interface_ReturnTypeTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_canonical_type" );
                return part->canonical_type;
            }
            else
            {
                THROW_RTE( "Invalid call to get_canonical_type" );
            }
        }
        , m_data );
}
std::vector< std::string >& get_canonical_types(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ArgumentListTrait > >)
            {
                data::Ptr< data::Clang::Interface_ArgumentListTrait > part = 
                    data::convert< data::Clang::Interface_ArgumentListTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_canonical_types" );
                return part->canonical_types;
            }
            else
            {
                THROW_RTE( "Invalid call to get_canonical_types" );
            }
        }
        , m_data );
}
mega::CardinalityRange& get_cardinality(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::CardinalityRange&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cardinality" );
                return part->cardinality;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cardinality" );
            }
        }
        , m_data );
}
mega::CardinalityRange& get_cardinality(std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::CardinalityRange&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cardinality" );
                return part->cardinality;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkTrait > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cardinality" );
                return part->cardinality;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cardinality" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& get_children(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ContextDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to get_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& get_children(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_ContextGroup > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Root > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to get_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& get_children(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Root > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Enumeration > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Failure > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Elimination > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Prune > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to get_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Name > >& get_children(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_Name > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_NameRoot > >)
            {
                data::Ptr< data::Operations::Operations_NameRoot > part = 
                    data::convert< data::Operations::Operations_NameRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_NameRoot > part = 
                    data::convert< data::Operations::Operations_NameRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to get_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_children(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ContextGroup > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Root > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to get_children" );
            }
        }
        , m_data );
}
data::Ptr< data::Components::Components_Component >& get_component(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Components::Components_Component >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_component" );
                return part->component;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_IncludeRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_component" );
                return part->component;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectSourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_component" );
                return part->component;
            }
            else
            {
                THROW_RTE( "Invalid call to get_component" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_concrete(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceDerivations::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& get_concrete(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Dimensions_User >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                    data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_concrete(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Instance > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Instance > part = 
                    data::convert< data::Operations::Invocations_Variables_Instance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_ConcreteVariant >& get_concrete(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_ConcreteVariant >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Element > >)
            {
                data::Ptr< data::Operations::Operations_Element > part = 
                    data::convert< data::Operations::Operations_Element >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& get_concrete(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >& get_concrete_context_map(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_context_map" );
                return part->concrete_context_map;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_context_map" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& get_concrete_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Dimensions_User >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_dimension" );
                return part->concrete_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_dimension" );
            }
        }
        , m_data );
}
std::size_t& get_concrete_hash_code(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_hash_code" );
                return part->concrete_hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_hash_code" );
            }
        }
        , m_data );
}
std::int32_t& get_concrete_id(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_id" );
                return part->concrete_id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_id" );
            }
        }
        , m_data );
}
std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& get_concrete_symbol_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_symbol_ids" );
                return part->concrete_symbol_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_symbol_ids" );
            }
        }
        , m_data );
}
std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& get_concrete_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_symbols" );
                return part->concrete_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_symbols" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& get_concrete_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_symbols" );
                return part->concrete_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_symbols" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_concrete_target(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_concrete_target" );
                return part->concrete_target;
            }
            else
            {
                THROW_RTE( "Invalid call to get_concrete_target" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_context(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > part = 
                    data::convert< data::ConcreteTable::Symbols_ConcreteSymbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_context(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Context >& get_context(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Root > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_Root > part = 
                    data::convert< data::Operations::Invocations_Instructions_Root >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& get_context(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ConcreteVariant > >)
            {
                data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                    data::convert< data::Operations::Operations_ConcreteVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_IContext > >& get_context(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_InterfaceVariant > >)
            {
                data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                    data::convert< data::Operations::Operations_InterfaceVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_Context >& get_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >& get_context_concrete_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context_concrete_ids" );
                return part->context_concrete_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context_concrete_ids" );
            }
        }
        , m_data );
}
std::string& get_context_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context_str" );
                return part->context_str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context_str" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& get_context_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context_symbols" );
                return part->context_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context_symbols" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >& get_context_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context_type_ids" );
                return part->context_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context_type_ids" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >& get_context_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_context_type_ids" );
                return part->context_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_context_type_ids" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_contexts(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_InheritanceTrait > >)
            {
                data::Ptr< data::Clang::Interface_InheritanceTrait > part = 
                    data::convert< data::Clang::Interface_InheritanceTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_contexts" );
                return part->contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to get_contexts" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_contexts(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_contexts" );
                return part->contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to get_contexts" );
            }
        }
        , m_data );
}
boost::filesystem::path& get_cppSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_CPPInclude > >)
            {
                data::Ptr< data::AST::Parser_CPPInclude > part = 
                    data::convert< data::AST::Parser_CPPInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cppSourceFilePath" );
                return part->cppSourceFilePath;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cppSourceFilePath" );
            }
        }
        , m_data );
}
std::vector< std::string >& get_cpp_defines(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cpp_defines" );
                return part->cpp_defines;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cpp_defines" );
            }
        }
        , m_data );
}
std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& get_cpp_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cpp_dependencies" );
                return part->cpp_dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cpp_dependencies" );
            }
        }
        , m_data );
}
std::vector< std::string >& get_cpp_flags(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cpp_flags" );
                return part->cpp_flags;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cpp_flags" );
            }
        }
        , m_data );
}
std::vector< mega::io::cppFilePath >& get_cpp_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::cppFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_cpp_source_files" );
                return part->cpp_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to get_cpp_source_files" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dependency > >& get_dependencies(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Dependency > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dependencies" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& get_dependencies(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dependencies" );
                return part->dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dependencies" );
            }
        }
        , m_data );
}
mega::DerivationDirection& get_derivation(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::DerivationDirection&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_derivation" );
                return part->derivation;
            }
            else
            {
                THROW_RTE( "Invalid call to get_derivation" );
            }
        }
        , m_data );
}
mega::DerivationDirection& get_derivation(std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::DerivationDirection&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_derivation" );
                return part->derivation;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkTrait > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_derivation" );
                return part->derivation;
            }
            else
            {
                THROW_RTE( "Invalid call to get_derivation" );
            }
        }
        , m_data );
}
std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& get_dimension(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Nothing > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Singleton > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range32 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range64 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_dimension(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ConcreteVariant > >)
            {
                data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                    data::convert< data::Operations::Operations_ConcreteVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& get_dimension(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_InterfaceVariant > >)
            {
                data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                    data::convert< data::Operations::Operations_InterfaceVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension" );
                return part->dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Dimension >& get_dimension_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Dimension >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                    data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_reference" );
                return part->dimension_reference;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_WriteLink > part = 
                    data::convert< data::Operations::Invocations_Operations_WriteLink >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_reference" );
                return part->dimension_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension_reference" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& get_dimension_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_symbols" );
                return part->dimension_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension_symbols" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& get_dimension_traits(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_Buffer > part = 
                    data::convert< data::Tree::Interface_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_traits" );
                return part->dimension_traits;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension_traits" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >& get_dimension_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_type_ids" );
                return part->dimension_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension_type_ids" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >& get_dimension_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimension_type_ids" );
                return part->dimension_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimension_type_ids" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dimension > >& get_dimensions(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Dimension > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Namespace > part = 
                    data::convert< data::Concrete::Concrete_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Action > part = 
                    data::convert< data::Concrete::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Event > part = 
                    data::convert< data::Concrete::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Object > part = 
                    data::convert< data::Concrete::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Buffer > part = 
                    data::convert< data::Concrete::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& get_dimensions(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_dimensions" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_Element >& get_element(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_Element >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_Name > part = 
                    data::convert< data::Operations::Operations_Name >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_element" );
                return part->element;
            }
            else
            {
                THROW_RTE( "Invalid call to get_element" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Element > >& get_elements(std::variant< data::Ptr< data::Operations::Operations_ElementVector > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_Element > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ElementVector > >)
            {
                data::Ptr< data::Operations::Operations_ElementVector > part = 
                    data::convert< data::Operations::Operations_ElementVector >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_elements" );
                return part->elements;
            }
            else
            {
                THROW_RTE( "Invalid call to get_elements" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_EventDef > >& get_event_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_EventDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_event_defs" );
                return part->event_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_event_defs" );
            }
        }
        , m_data );
}
std::optional< mega::ExplicitOperationID >& get_explicit_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< mega::ExplicitOperationID >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_explicit_operation" );
                return part->explicit_operation;
            }
            else
            {
                THROW_RTE( "Invalid call to get_explicit_operation" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& get_from(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Instance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_from" );
                return part->from;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_from" );
                return part->from;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_from" );
                return part->from;
            }
            else
            {
                THROW_RTE( "Invalid call to get_from" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& get_from_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Reference >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_PolyReference > part = 
                    data::convert< data::Operations::Invocations_Instructions_PolyReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_from_reference" );
                return part->from_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to get_from_reference" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& get_function_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_FunctionDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_function_defs" );
                return part->function_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_function_defs" );
            }
        }
        , m_data );
}
std::string& get_glob(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Glob > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                    data::convert< data::DPGraph::Dependencies_Glob >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_glob" );
                return part->glob;
            }
            else
            {
                THROW_RTE( "Invalid call to get_glob" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& get_globs(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_globs" );
                return part->globs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_globs" );
            }
        }
        , m_data );
}
std::size_t& get_hash_code(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to get_hash_code" );
            }
        }
        , m_data );
}
std::size_t& get_hash_code(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to get_hash_code" );
            }
        }
        , m_data );
}
std::size_t& get_hash_code(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to get_hash_code" );
            }
        }
        , m_data );
}
std::size_t& get_hash_code(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to get_hash_code" );
            }
        }
        , m_data );
}
std::optional< bool >& get_homogeneous(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< bool >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_homogeneous" );
                return part->homogeneous;
            }
            else
            {
                THROW_RTE( "Invalid call to get_homogeneous" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& get_id(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ScopedIdentifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Identifier >& get_id(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Identifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Identifier >& get_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Identifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& get_id(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ScopedIdentifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeNested > >)
            {
                data::Ptr< data::AST::Parser_MegaIncludeNested > part = 
                    data::convert< data::AST::Parser_MegaIncludeNested >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id" );
            }
        }
        , m_data );
}
std::int32_t& get_id(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > part = 
                    data::convert< data::ConcreteTable::Symbols_ConcreteSymbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id" );
            }
        }
        , m_data );
}
std::int32_t& get_id(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id" );
            }
        }
        , m_data );
}
std::vector< std::int32_t >& get_id_sequence(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > part = 
                    data::convert< data::ConcreteTable::Symbols_ConcreteSymbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_id_sequence" );
                return part->id_sequence;
            }
            else
            {
                THROW_RTE( "Invalid call to get_id_sequence" );
            }
        }
        , m_data );
}
std::string& get_identifier(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_identifier" );
                return part->identifier;
            }
            else
            {
                THROW_RTE( "Invalid call to get_identifier" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Identifier > >& get_ids(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Identifier > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ids" );
                return part->ids;
            }
            else
            {
                THROW_RTE( "Invalid call to get_ids" );
            }
        }
        , m_data );
}
std::vector< boost::filesystem::path >& get_include_directories(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< boost::filesystem::path >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_include_directories" );
                return part->include_directories;
            }
            else
            {
                THROW_RTE( "Invalid call to get_include_directories" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Include > >& get_includes(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Include > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_includes" );
                return part->includes;
            }
            else
            {
                THROW_RTE( "Invalid call to get_includes" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& get_inheritance(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Inheritance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_AbstractDef > part = 
                    data::convert< data::AST::Parser_AbstractDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ActionDef > part = 
                    data::convert< data::AST::Parser_ActionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_EventDef > part = 
                    data::convert< data::AST::Parser_EventDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ObjectDef > part = 
                    data::convert< data::AST::Parser_ObjectDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& get_inheritance(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance" );
                return part->inheritance;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& get_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_contexts" );
                return part->inheritance_contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance_contexts" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& get_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_contexts" );
                return part->inheritance_contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance_contexts" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_dimensions" );
                return part->inheritance_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance_dimensions" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_dimensions" );
                return part->inheritance_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance_dimensions" );
            }
        }
        , m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& get_inheritance_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_trait" );
                return part->inheritance_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_trait" );
                return part->inheritance_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_trait" );
                return part->inheritance_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_inheritance_trait" );
                return part->inheritance_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to get_inheritance_trait" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& get_instance(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Instance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Enumeration > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_Enumeration > part = 
                    data::convert< data::Operations::Invocations_Instructions_Enumeration >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                    data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                    data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_instance" );
                return part->instance;
            }
            else
            {
                THROW_RTE( "Invalid call to get_instance" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_IContext >& get_interface(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_IContext >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_IContext >& get_interface(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_IContext >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_InterfaceVariant >& get_interface(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_InterfaceVariant >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Element > >)
            {
                data::Ptr< data::Operations::Operations_Element > part = 
                    data::convert< data::Operations::Operations_Element >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface" );
                return part->interface;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Action >& get_interface_action(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Action >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Action > part = 
                    data::convert< data::Concrete::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_action" );
                return part->interface_action;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_action" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Buffer >& get_interface_buffer(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Buffer >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Buffer > part = 
                    data::convert< data::Concrete::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_buffer" );
                return part->interface_buffer;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_buffer" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& get_interface_dimension(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_DimensionTrait >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Dimensions_User > >)
            {
                data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                    data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_dimension" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& get_interface_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_DimensionTrait >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_dimension" );
                return part->interface_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_dimension" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Event >& get_interface_event(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Event >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Event > part = 
                    data::convert< data::Concrete::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_event" );
                return part->interface_event;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_event" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Function >& get_interface_function(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Function >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Function > part = 
                    data::convert< data::Concrete::Concrete_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_function" );
                return part->interface_function;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_function" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Namespace >& get_interface_namespace(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Namespace >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Namespace > part = 
                    data::convert< data::Concrete::Concrete_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_namespace" );
                return part->interface_namespace;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_namespace" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Object >& get_interface_object(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Object >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Object > part = 
                    data::convert< data::Concrete::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_object" );
                return part->interface_object;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_object" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Root >& get_interface_root(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Root >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Root > >)
            {
                data::Ptr< data::Concrete::Concrete_Root > part = 
                    data::convert< data::Concrete::Concrete_Root >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_interface_root" );
                return part->interface_root;
            }
            else
            {
                THROW_RTE( "Invalid call to get_interface_root" );
            }
        }
        , m_data );
}
std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& get_invocations(std::variant< data::Ptr< data::Operations::Operations_Invocations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocations > >)
            {
                data::Ptr< data::Operations::Operations_Invocations > part = 
                    data::convert< data::Operations::Operations_Invocations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_invocations" );
                return part->invocations;
            }
            else
            {
                THROW_RTE( "Invalid call to get_invocations" );
            }
        }
        , m_data );
}
bool& get_isConst(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_isConst" );
                return part->isConst;
            }
            else
            {
                THROW_RTE( "Invalid call to get_isConst" );
            }
        }
        , m_data );
}
bool& get_isConst(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_isConst" );
                return part->isConst;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_isConst" );
                return part->isConst;
            }
            else
            {
                THROW_RTE( "Invalid call to get_isConst" );
            }
        }
        , m_data );
}
std::optional< bool >& get_is_function_call(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< bool >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_is_function_call" );
                return part->is_function_call;
            }
            else
            {
                THROW_RTE( "Invalid call to get_is_function_call" );
            }
        }
        , m_data );
}
bool& get_is_global(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_is_global" );
                return part->is_global;
            }
            else
            {
                THROW_RTE( "Invalid call to get_is_global" );
            }
        }
        , m_data );
}
bool& get_is_member(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_Name > part = 
                    data::convert< data::Operations::Operations_Name >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_is_member" );
                return part->is_member;
            }
            else
            {
                THROW_RTE( "Invalid call to get_is_member" );
            }
        }
        , m_data );
}
bool& get_is_reference(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_Name > part = 
                    data::convert< data::Operations::Operations_Name >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_is_reference" );
                return part->is_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to get_is_reference" );
            }
        }
        , m_data );
}
std::size_t& get_line_number(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_line_number" );
                return part->line_number;
            }
            else
            {
                THROW_RTE( "Invalid call to get_line_number" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Link >& get_link(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Link > part = 
                    data::convert< data::Concrete::Concrete_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link" );
                return part->link;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Link >& get_link(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link" );
                return part->link;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link" );
                return part->link;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link" );
                return part->link;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_LinkDef > >& get_link_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_LinkDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_defs" );
                return part->link_defs;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_defs" );
                return part->link_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& get_link_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_dimensions" );
                return part->link_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link_dimensions" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_LinkInterface >& get_link_interface(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_LinkInterface >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_LinkInterfaceDef > part = 
                    data::convert< data::AST::Parser_LinkInterfaceDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_interface" );
                return part->link_interface;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& get_link_reference(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                    data::convert< data::MemoryLayout::Concrete_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_reference" );
                return part->link_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link_reference" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& get_link_target(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_target" );
                return part->link_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_target" );
                return part->link_target;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link_target" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& get_link_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_LinkInterface > part = 
                    data::convert< data::Tree::Interface_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_link_trait" );
                return part->link_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to get_link_trait" );
            }
        }
        , m_data );
}
std::size_t& get_local_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                    data::convert< data::MemoryLayout::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_local_size" );
                return part->local_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                    data::convert< data::MemoryLayout::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_local_size" );
                return part->local_size;
            }
            else
            {
                THROW_RTE( "Invalid call to get_local_size" );
            }
        }
        , m_data );
}
boost::filesystem::path& get_location(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Glob > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                    data::convert< data::DPGraph::Dependencies_Glob >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_location" );
                return part->location;
            }
            else
            {
                THROW_RTE( "Invalid call to get_location" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& get_mappings(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_mappings" );
                return part->mappings;
            }
            else
            {
                THROW_RTE( "Invalid call to get_mappings" );
            }
        }
        , m_data );
}
boost::filesystem::path& get_megaSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaInclude > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_megaSourceFilePath" );
                return part->megaSourceFilePath;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeInline > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_megaSourceFilePath" );
                return part->megaSourceFilePath;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeNested > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_megaSourceFilePath" );
                return part->megaSourceFilePath;
            }
            else
            {
                THROW_RTE( "Invalid call to get_megaSourceFilePath" );
            }
        }
        , m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& get_mega_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_mega_dependencies" );
                return part->mega_dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to get_mega_dependencies" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& get_mega_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_mega_source_files" );
                return part->mega_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to get_mega_source_files" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& get_mega_source_files(std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_TransitiveDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_mega_source_files" );
                return part->mega_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to get_mega_source_files" );
            }
        }
        , m_data );
}
std::string& get_name(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_name" );
                return part->name;
            }
            else
            {
                THROW_RTE( "Invalid call to get_name" );
            }
        }
        , m_data );
}
std::string& get_name(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_name" );
                return part->name;
            }
            else
            {
                THROW_RTE( "Invalid call to get_name" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Operations_NameResolution > >& get_name_resolution(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Operations_NameResolution > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_name_resolution" );
                return part->name_resolution;
            }
            else
            {
                THROW_RTE( "Invalid call to get_name_resolution" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& get_namespace_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ContextDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_namespace_defs" );
                return part->namespace_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_namespace_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& get_object_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ObjectDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_object_defs" );
                return part->object_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to get_object_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& get_objects(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_objects" );
                return part->objects;
            }
            else
            {
                THROW_RTE( "Invalid call to get_objects" );
            }
        }
        , m_data );
}
mega::OperationID& get_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::OperationID&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_operation" );
                return part->operation;
            }
            else
            {
                THROW_RTE( "Invalid call to get_operation" );
            }
        }
        , m_data );
}
mega::Ownership& get_ownership(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::Ownership&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ownership" );
                return part->ownership;
            }
            else
            {
                THROW_RTE( "Invalid call to get_ownership" );
            }
        }
        , m_data );
}
mega::Ownership& get_ownership(std::variant< data::Ptr< data::AST::Parser_LinkInterface >, data::Ptr< data::Tree::Interface_LinkTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::Ownership&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ownership" );
                return part->ownership;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkTrait > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_ownership" );
                return part->ownership;
            }
            else
            {
                THROW_RTE( "Invalid call to get_ownership" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& get_parameter_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parameter_types" );
                return part->parameter_types;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parameter_types" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_IContext >& get_parent(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_IContext >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Tree::Interface_DimensionTrait > part = 
                    data::convert< data::Tree::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_ContextGroup >& get_parent(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_ContextGroup >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_parent(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Dimensions_User > >)
            {
                data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                    data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& get_parent(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& get_parent(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Variable > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Instance > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Reference > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Dimension > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Context > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_ContextGroup >& get_parent(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_ContextGroup >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& get_parent_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Nothing > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Singleton > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range32 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range64 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parent_context" );
                return part->parent_context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parent_context" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::MemoryLayout_Part >& get_part(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::MemoryLayout_Part >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Dimensions_User > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_User > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_User >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_part" );
                return part->part;
            }
            else
            {
                THROW_RTE( "Invalid call to get_part" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& get_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_part" );
                return part->part;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_part" );
                return part->part;
            }
            else
            {
                THROW_RTE( "Invalid call to get_part" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& get_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_part" );
                return part->part;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_part" );
                return part->part;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_part" );
                return part->part;
            }
            else
            {
                THROW_RTE( "Invalid call to get_part" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& get_parts(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_parts" );
                return part->parts;
            }
            else
            {
                THROW_RTE( "Invalid call to get_parts" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& get_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Reference >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                    data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_reference" );
                return part->reference;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                    data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_reference" );
                return part->reference;
            }
            else
            {
                THROW_RTE( "Invalid call to get_reference" );
            }
        }
        , m_data );
}
data::Ptr< data::Model::HyperGraph_Relation >& get_relation(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Model::HyperGraph_Relation >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceModel::Interface_Link > part = 
                    data::convert< data::PerSourceModel::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_relation" );
                return part->relation;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceModel::Interface_Link > part = 
                    data::convert< data::PerSourceModel::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_relation" );
                return part->relation;
            }
            else
            {
                THROW_RTE( "Invalid call to get_relation" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& get_relations(std::variant< data::Ptr< data::Model::HyperGraph_Graph > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Model::HyperGraph_Relations > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Graph > >)
            {
                data::Ptr< data::Model::HyperGraph_Graph > part = 
                    data::convert< data::Model::HyperGraph_Graph >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_relations" );
                return part->relations;
            }
            else
            {
                THROW_RTE( "Invalid call to get_relations" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& get_relations(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_relations" );
                return part->relations;
            }
            else
            {
                THROW_RTE( "Invalid call to get_relations" );
            }
        }
        , m_data );
}
std::vector< boost::filesystem::path >& get_resolution(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< boost::filesystem::path >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_resolution" );
                return part->resolution;
            }
            else
            {
                THROW_RTE( "Invalid call to get_resolution" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ReturnType >& get_returnType(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ReturnType >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_FunctionDef > part = 
                    data::convert< data::AST::Parser_FunctionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_returnType" );
                return part->returnType;
            }
            else
            {
                THROW_RTE( "Invalid call to get_returnType" );
            }
        }
        , m_data );
}
std::optional< std::string >& get_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_type_str" );
                return part->return_type_str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_return_type_str" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& get_return_type_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_type_trait" );
                return part->return_type_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to get_return_type_trait" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& get_return_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types" );
                return part->return_types;
            }
            else
            {
                THROW_RTE( "Invalid call to get_return_types" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& get_return_types_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types_context" );
                return part->return_types_context;
            }
            else
            {
                THROW_RTE( "Invalid call to get_return_types_context" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& get_return_types_dimension(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_return_types_dimension" );
                return part->return_types_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to get_return_types_dimension" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& get_root(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaInclude > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root" );
                return part->root;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeInline > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root" );
                return part->root;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeNested > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root" );
                return part->root;
            }
            else
            {
                THROW_RTE( "Invalid call to get_root" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ObjectSourceRoot >& get_root(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ObjectSourceRoot >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Root > >)
            {
                data::Ptr< data::Tree::Interface_Root > part = 
                    data::convert< data::Tree::Interface_Root >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root" );
                return part->root;
            }
            else
            {
                THROW_RTE( "Invalid call to get_root" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >& get_root_instruction(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root_instruction" );
                return part->root_instruction;
            }
            else
            {
                THROW_RTE( "Invalid call to get_root_instruction" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_NameRoot >& get_root_name(std::variant< data::Ptr< data::Operations::Operations_NameResolution > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_NameRoot >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_NameResolution > >)
            {
                data::Ptr< data::Operations::Operations_NameResolution > part = 
                    data::convert< data::Operations::Operations_NameResolution >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root_name" );
                return part->root_name;
            }
            else
            {
                THROW_RTE( "Invalid call to get_root_name" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Variables_Context > >& get_root_variable(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Invocations_Variables_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_root_variable" );
                return part->root_variable;
            }
            else
            {
                THROW_RTE( "Invalid call to get_root_variable" );
            }
        }
        , m_data );
}
std::optional< std::string >& get_runtime_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_runtime_return_type_str" );
                return part->runtime_return_type_str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_runtime_return_type_str" );
            }
        }
        , m_data );
}
bool& get_simple(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_simple" );
                return part->simple;
            }
            else
            {
                THROW_RTE( "Invalid call to get_simple" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Size >& get_size(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Size >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ActionDef > part = 
                    data::convert< data::AST::Parser_ActionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_size" );
                return part->size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_EventDef > part = 
                    data::convert< data::AST::Parser_EventDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_size" );
                return part->size;
            }
            else
            {
                THROW_RTE( "Invalid call to get_size" );
            }
        }
        , m_data );
}
std::size_t& get_size(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_size" );
                return part->size;
            }
            else
            {
                THROW_RTE( "Invalid call to get_size" );
            }
        }
        , m_data );
}
std::size_t& get_size(std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_SizeTrait > >)
            {
                data::Ptr< data::Clang::Interface_SizeTrait > part = 
                    data::convert< data::Clang::Interface_SizeTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_size" );
                return part->size;
            }
            else
            {
                THROW_RTE( "Invalid call to get_size" );
            }
        }
        , m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& get_size_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_size_trait" );
                return part->size_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_size_trait" );
                return part->size_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to get_size_trait" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Link >& get_source(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source" );
                return part->source;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source" );
            }
        }
        , m_data );
}
boost::filesystem::path& get_sourceFile(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_sourceFile" );
                return part->sourceFile;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_IncludeRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_sourceFile" );
                return part->sourceFile;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectSourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_sourceFile" );
                return part->sourceFile;
            }
            else
            {
                THROW_RTE( "Invalid call to get_sourceFile" );
            }
        }
        , m_data );
}
std::string& get_source_file(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& get_source_file(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source_file" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& get_source_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_LinkInterface >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_source_interface" );
                return part->source_interface;
            }
            else
            {
                THROW_RTE( "Invalid call to get_source_interface" );
            }
        }
        , m_data );
}
boost::filesystem::path& get_src_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_src_dir" );
                return part->src_dir;
            }
            else
            {
                THROW_RTE( "Invalid call to get_src_dir" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ArgumentList > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ArgumentList > >)
            {
                data::Ptr< data::AST::Parser_ArgumentList > part = 
                    data::convert< data::AST::Parser_ArgumentList >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ArgumentList > >)
            {
                data::Ptr< data::AST::Parser_ArgumentList > part = 
                    data::convert< data::AST::Parser_ArgumentList >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ArgumentListTrait > >)
            {
                data::Ptr< data::AST::Parser_ArgumentList > part = 
                    data::convert< data::AST::Parser_ArgumentList >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Dependency > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dependency > >)
            {
                data::Ptr< data::AST::Parser_Dependency > part = 
                    data::convert< data::AST::Parser_Dependency >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Identifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Identifier > >)
            {
                data::Ptr< data::AST::Parser_Identifier > part = 
                    data::convert< data::AST::Parser_Identifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SystemInclude > >)
            {
                data::Ptr< data::AST::Parser_SystemInclude > part = 
                    data::convert< data::AST::Parser_SystemInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ReturnType > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ReturnType > >)
            {
                data::Ptr< data::AST::Parser_ReturnType > part = 
                    data::convert< data::AST::Parser_ReturnType >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ReturnType > >)
            {
                data::Ptr< data::AST::Parser_ReturnType > part = 
                    data::convert< data::AST::Parser_ReturnType >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >)
            {
                data::Ptr< data::AST::Parser_ReturnType > part = 
                    data::convert< data::AST::Parser_ReturnType >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Size > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Size > >)
            {
                data::Ptr< data::AST::Parser_Size > part = 
                    data::convert< data::AST::Parser_Size >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::string& get_str(std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Size > >)
            {
                data::Ptr< data::AST::Parser_Size > part = 
                    data::convert< data::AST::Parser_Size >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_SizeTrait > >)
            {
                data::Ptr< data::AST::Parser_Size > part = 
                    data::convert< data::AST::Parser_Size >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_str" );
            }
        }
        , m_data );
}
std::vector< std::string >& get_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Inheritance > >)
            {
                data::Ptr< data::AST::Parser_Inheritance > part = 
                    data::convert< data::AST::Parser_Inheritance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_strings" );
                return part->strings;
            }
            else
            {
                THROW_RTE( "Invalid call to get_strings" );
            }
        }
        , m_data );
}
std::vector< std::string >& get_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Inheritance > >)
            {
                data::Ptr< data::AST::Parser_Inheritance > part = 
                    data::convert< data::AST::Parser_Inheritance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_strings" );
                return part->strings;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_InheritanceTrait > >)
            {
                data::Ptr< data::AST::Parser_Inheritance > part = 
                    data::convert< data::AST::Parser_Inheritance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_strings" );
                return part->strings;
            }
            else
            {
                THROW_RTE( "Invalid call to get_strings" );
            }
        }
        , m_data );
}
std::int32_t& get_symbol(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbol" );
            }
        }
        , m_data );
}
std::string& get_symbol(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbol" );
            }
        }
        , m_data );
}
std::int32_t& get_symbol(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol" );
                return part->symbol;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbol" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >& get_symbol_id_map(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol_id_map" );
                return part->symbol_id_map;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbol_id_map" );
            }
        }
        , m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& get_symbol_sets(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbol_sets" );
                return part->symbol_sets;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbol_sets" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >& get_symbols(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbols" );
            }
        }
        , m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& get_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbols" );
            }
        }
        , m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& get_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to get_symbols" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& get_target(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Inheritance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_LinkDef > part = 
                    data::convert< data::AST::Parser_LinkDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_target" );
                return part->target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_LinkDef > part = 
                    data::convert< data::AST::Parser_LinkDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_target" );
                return part->target;
            }
            else
            {
                THROW_RTE( "Invalid call to get_target" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Link >& get_target(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_target" );
                return part->target;
            }
            else
            {
                THROW_RTE( "Invalid call to get_target" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& get_target_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_LinkInterface >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_target_interface" );
                return part->target_interface;
            }
            else
            {
                THROW_RTE( "Invalid call to get_target_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& get_to(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Instance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_to" );
                return part->to;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_to" );
                return part->to;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_to" );
                return part->to;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                    data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_to" );
                return part->to;
            }
            else
            {
                THROW_RTE( "Invalid call to get_to" );
            }
        }
        , m_data );
}
std::size_t& get_total_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                    data::convert< data::MemoryLayout::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_total_size" );
                return part->total_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                    data::convert< data::MemoryLayout::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_total_size" );
                return part->total_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                    data::convert< data::MemoryLayout::Concrete_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_total_size" );
                return part->total_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Buffer > part = 
                    data::convert< data::MemoryLayout::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_total_size" );
                return part->total_size;
            }
            else
            {
                THROW_RTE( "Invalid call to get_total_size" );
            }
        }
        , m_data );
}
std::string& get_type(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type" );
                return part->type;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type" );
            }
        }
        , m_data );
}
std::string& get_type(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type" );
                return part->type;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type" );
                return part->type;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type" );
            }
        }
        , m_data );
}
mega::ComponentType& get_type(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::ComponentType&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type" );
                return part->type;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type" );
            }
        }
        , m_data );
}
std::optional< std::int32_t >& get_type_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type_id" );
            }
        }
        , m_data );
}
std::optional< std::int32_t >& get_type_id(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_id" );
                return part->type_id;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type_id" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_TypePath >& get_type_path(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_TypePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_path" );
                return part->type_path;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type_path" );
            }
        }
        , m_data );
}
std::string& get_type_path_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_type_path_str" );
                return part->type_path_str;
            }
            else
            {
                THROW_RTE( "Invalid call to get_type_path_str" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& get_types(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Reference > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_types" );
                return part->types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Dimension > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_types" );
                return part->types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Context > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_types" );
                return part->types;
            }
            else
            {
                THROW_RTE( "Invalid call to get_types" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& get_user_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_user_dimensions" );
                return part->user_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to get_user_dimensions" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > > >& get_variables(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_variables" );
                return part->variables;
            }
            else
            {
                THROW_RTE( "Invalid call to get_variables" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& get_vectors(std::variant< data::Ptr< data::Operations::Operations_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_ElementVector > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Context > >)
            {
                data::Ptr< data::Operations::Operations_Context > part = 
                    data::convert< data::Operations::Operations_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_vectors" );
                return part->vectors;
            }
            else
            {
                THROW_RTE( "Invalid call to get_vectors" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& get_vectors(std::variant< data::Ptr< data::Operations::Operations_TypePath > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_ElementVector > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_TypePath > >)
            {
                data::Ptr< data::Operations::Operations_TypePath > part = 
                    data::convert< data::Operations::Operations_TypePath >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: get_vectors" );
                return part->vectors;
            }
            else
            {
                THROW_RTE( "Invalid call to get_vectors" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >& insert_concrete_context_map(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_concrete_context_map" );
                return part->concrete_context_map;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_concrete_context_map" );
            }
        }
        , m_data );
}
std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& insert_concrete_symbol_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_concrete_symbol_ids" );
                return part->concrete_symbol_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_concrete_symbol_ids" );
            }
        }
        , m_data );
}
std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& insert_concrete_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_concrete_symbols" );
                return part->concrete_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_concrete_symbols" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& insert_concrete_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_concrete_symbols" );
                return part->concrete_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_concrete_symbols" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >& insert_context_concrete_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_context_concrete_ids" );
                return part->context_concrete_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_context_concrete_ids" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& insert_context_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_context_symbols" );
                return part->context_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_context_symbols" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >& insert_context_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_context_type_ids" );
                return part->context_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_context_type_ids" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >& insert_context_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_context_type_ids" );
                return part->context_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_context_type_ids" );
            }
        }
        , m_data );
}
std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& insert_cpp_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_cpp_dependencies" );
                return part->cpp_dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_cpp_dependencies" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& insert_dimension_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_dimension_symbols" );
                return part->dimension_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_dimension_symbols" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >& insert_dimension_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_dimension_type_ids" );
                return part->dimension_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_dimension_type_ids" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >& insert_dimension_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_dimension_type_ids" );
                return part->dimension_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_dimension_type_ids" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& insert_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_inheritance_contexts" );
                return part->inheritance_contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_inheritance_contexts" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& insert_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_inheritance_contexts" );
                return part->inheritance_contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_inheritance_contexts" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& insert_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_inheritance_dimensions" );
                return part->inheritance_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_inheritance_dimensions" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& insert_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_inheritance_dimensions" );
                return part->inheritance_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_inheritance_dimensions" );
            }
        }
        , m_data );
}
std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& insert_invocations(std::variant< data::Ptr< data::Operations::Operations_Invocations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocations > >)
            {
                data::Ptr< data::Operations::Operations_Invocations > part = 
                    data::convert< data::Operations::Operations_Invocations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_invocations" );
                return part->invocations;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_invocations" );
            }
        }
        , m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& insert_mega_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_mega_dependencies" );
                return part->mega_dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_mega_dependencies" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& insert_relations(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_relations" );
                return part->relations;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_relations" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >& insert_symbol_id_map(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_symbol_id_map" );
                return part->symbol_id_map;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_symbol_id_map" );
            }
        }
        , m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& insert_symbol_sets(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_symbol_sets" );
                return part->symbol_sets;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_symbol_sets" );
            }
        }
        , m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& insert_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_symbols" );
            }
        }
        , m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& insert_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: insert_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to insert_symbols" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& push_back_abstract_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_AbstractDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_abstract_defs" );
                return part->abstract_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_abstract_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ActionDef > >& push_back_action_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ActionDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_action_defs" );
                return part->action_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_action_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& push_back_allocation_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_allocation_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& push_back_allocation_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_allocation_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_BufferDef > >& push_back_buffer_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_BufferDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_Buffer > part = 
                    data::convert< data::Tree::Interface_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_buffer_defs" );
                return part->buffer_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_buffer_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& push_back_buffers(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Object > part = 
                    data::convert< data::MemoryLayout::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_buffers" );
                return part->buffers;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_buffers" );
            }
        }
        , m_data );
}
std::vector< std::string >& push_back_canonical_types(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ArgumentListTrait > >)
            {
                data::Ptr< data::Clang::Interface_ArgumentListTrait > part = 
                    data::convert< data::Clang::Interface_ArgumentListTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_canonical_types" );
                return part->canonical_types;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_canonical_types" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& push_back_children(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ContextDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& push_back_children(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_ContextGroup > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Root > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& push_back_children(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Root > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Enumeration > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Failure > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Elimination > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Prune > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Name > >& push_back_children(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_Name > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_NameRoot > >)
            {
                data::Ptr< data::Operations::Operations_NameRoot > part = 
                    data::convert< data::Operations::Operations_NameRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_NameRoot > part = 
                    data::convert< data::Operations::Operations_NameRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_children(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ContextGroup > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Root > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& push_back_concrete(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceDerivations::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_concrete" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& push_back_concrete(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_concrete" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_contexts(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_InheritanceTrait > >)
            {
                data::Ptr< data::Clang::Interface_InheritanceTrait > part = 
                    data::convert< data::Clang::Interface_InheritanceTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_contexts" );
                return part->contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_contexts" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_contexts(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_contexts" );
                return part->contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_contexts" );
            }
        }
        , m_data );
}
std::vector< std::string >& push_back_cpp_defines(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_cpp_defines" );
                return part->cpp_defines;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_cpp_defines" );
            }
        }
        , m_data );
}
std::vector< std::string >& push_back_cpp_flags(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_cpp_flags" );
                return part->cpp_flags;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_cpp_flags" );
            }
        }
        , m_data );
}
std::vector< mega::io::cppFilePath >& push_back_cpp_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::cppFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_cpp_source_files" );
                return part->cpp_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_cpp_source_files" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dependency > >& push_back_dependencies(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Dependency > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_dependencies" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& push_back_dependencies(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dependencies" );
                return part->dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_dependencies" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& push_back_dimension_traits(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_Buffer > part = 
                    data::convert< data::Tree::Interface_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimension_traits" );
                return part->dimension_traits;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_dimension_traits" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dimension > >& push_back_dimensions(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Dimension > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& push_back_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Namespace > part = 
                    data::convert< data::Concrete::Concrete_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Action > part = 
                    data::convert< data::Concrete::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Event > part = 
                    data::convert< data::Concrete::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Object > part = 
                    data::convert< data::Concrete::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Buffer > part = 
                    data::convert< data::Concrete::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& push_back_dimensions(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Element > >& push_back_elements(std::variant< data::Ptr< data::Operations::Operations_ElementVector > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_Element > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ElementVector > >)
            {
                data::Ptr< data::Operations::Operations_ElementVector > part = 
                    data::convert< data::Operations::Operations_ElementVector >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_elements" );
                return part->elements;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_elements" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_EventDef > >& push_back_event_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_EventDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_event_defs" );
                return part->event_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_event_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& push_back_function_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_FunctionDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_function_defs" );
                return part->function_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_function_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& push_back_globs(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_globs" );
                return part->globs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_globs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Identifier > >& push_back_ids(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Identifier > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_ids" );
                return part->ids;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_ids" );
            }
        }
        , m_data );
}
std::vector< boost::filesystem::path >& push_back_include_directories(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< boost::filesystem::path >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_include_directories" );
                return part->include_directories;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_include_directories" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Include > >& push_back_includes(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Include > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_includes" );
                return part->includes;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_includes" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& push_back_inheritance(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_inheritance" );
                return part->inheritance;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_inheritance" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_LinkDef > >& push_back_link_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_LinkDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_link_defs" );
                return part->link_defs;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_link_defs" );
                return part->link_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_link_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& push_back_link_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_link_dimensions" );
                return part->link_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_link_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& push_back_mappings(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_mappings" );
                return part->mappings;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_mappings" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& push_back_mega_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_mega_source_files" );
                return part->mega_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_mega_source_files" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& push_back_mega_source_files(std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_TransitiveDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_mega_source_files" );
                return part->mega_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_mega_source_files" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& push_back_namespace_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ContextDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_namespace_defs" );
                return part->namespace_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_namespace_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& push_back_object_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ObjectDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_object_defs" );
                return part->object_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_object_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& push_back_objects(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_objects" );
                return part->objects;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_objects" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& push_back_parameter_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parameter_types" );
                return part->parameter_types;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_parameter_types" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& push_back_parts(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_parts" );
                return part->parts;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_parts" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& push_back_relations(std::variant< data::Ptr< data::Model::HyperGraph_Graph > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Model::HyperGraph_Relations > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Graph > >)
            {
                data::Ptr< data::Model::HyperGraph_Graph > part = 
                    data::convert< data::Model::HyperGraph_Graph >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_relations" );
                return part->relations;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_relations" );
            }
        }
        , m_data );
}
std::vector< boost::filesystem::path >& push_back_resolution(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< boost::filesystem::path >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_resolution" );
                return part->resolution;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_resolution" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& push_back_return_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types" );
                return part->return_types;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_return_types" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& push_back_return_types_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types_context" );
                return part->return_types_context;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_return_types_context" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& push_back_return_types_dimension(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_return_types_dimension" );
                return part->return_types_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_return_types_dimension" );
            }
        }
        , m_data );
}
std::vector< std::string >& push_back_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Inheritance > >)
            {
                data::Ptr< data::AST::Parser_Inheritance > part = 
                    data::convert< data::AST::Parser_Inheritance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_strings" );
                return part->strings;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_strings" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >& push_back_symbols(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_symbols" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& push_back_types(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Reference > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_types" );
                return part->types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Dimension > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_types" );
                return part->types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Context > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_types" );
                return part->types;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_types" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& push_back_user_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_user_dimensions" );
                return part->user_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_user_dimensions" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > > >& push_back_variables(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_variables" );
                return part->variables;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_variables" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& push_back_vectors(std::variant< data::Ptr< data::Operations::Operations_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_ElementVector > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Context > >)
            {
                data::Ptr< data::Operations::Operations_Context > part = 
                    data::convert< data::Operations::Operations_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_vectors" );
                return part->vectors;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_vectors" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& push_back_vectors(std::variant< data::Ptr< data::Operations::Operations_TypePath > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_ElementVector > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_TypePath > >)
            {
                data::Ptr< data::Operations::Operations_TypePath > part = 
                    data::convert< data::Operations::Operations_TypePath >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: push_back_vectors" );
                return part->vectors;
            }
            else
            {
                THROW_RTE( "Invalid call to push_back_vectors" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_AbstractDef > >& set_abstract_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_AbstractDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_abstract_defs" );
                return part->abstract_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_abstract_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ActionDef > >& set_action_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ActionDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_action_defs" );
                return part->action_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_action_defs" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_allocated_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Nothing > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Singleton > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range32 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range64 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocated_context" );
                return part->allocated_context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_allocated_context" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& set_allocation_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_allocation_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >& set_allocation_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocation_dimensions" );
                return part->allocation_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_allocation_dimensions" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& set_allocator(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::Allocators_Allocator >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Context > part = 
                    data::convert< data::MemoryLayout::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else
            {
                THROW_RTE( "Invalid call to set_allocator" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::Allocators_Allocator >& set_allocator(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::Allocators_Allocator >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_allocator" );
                return part->allocator;
            }
            else
            {
                THROW_RTE( "Invalid call to set_allocator" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ArgumentList >& set_argumentList(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ArgumentList >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_FunctionDef > part = 
                    data::convert< data::AST::Parser_FunctionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_argumentList" );
                return part->argumentList;
            }
            else
            {
                THROW_RTE( "Invalid call to set_argumentList" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >& set_arguments_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_ArgumentListTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_arguments_trait" );
                return part->arguments_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to set_arguments_trait" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ContextDef >& set_ast(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ContextDef >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_ast" );
                return part->ast;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_IncludeRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_ast" );
                return part->ast;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectSourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_ast" );
                return part->ast;
            }
            else
            {
                THROW_RTE( "Invalid call to set_ast" );
            }
        }
        , m_data );
}
std::string& set_body(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::Body::Parser_ContextDef > part = 
                    data::convert< data::Body::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_body" );
                return part->body;
            }
            else
            {
                THROW_RTE( "Invalid call to set_body" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_BufferDef > >& set_buffer_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_BufferDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_Buffer > part = 
                    data::convert< data::Tree::Interface_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_buffer_defs" );
                return part->buffer_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_buffer_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >& set_buffers(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Object > part = 
                    data::convert< data::MemoryLayout::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_buffers" );
                return part->buffers;
            }
            else
            {
                THROW_RTE( "Invalid call to set_buffers" );
            }
        }
        , m_data );
}
boost::filesystem::path& set_build_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_build_dir" );
                return part->build_dir;
            }
            else
            {
                THROW_RTE( "Invalid call to set_build_dir" );
            }
        }
        , m_data );
}
std::string& set_canonical_type(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_canonical_type" );
                return part->canonical_type;
            }
            else
            {
                THROW_RTE( "Invalid call to set_canonical_type" );
            }
        }
        , m_data );
}
std::string& set_canonical_type(std::variant< data::Ptr< data::AST::Parser_ReturnType >, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ReturnTypeTrait > >)
            {
                data::Ptr< data::Clang::Interface_ReturnTypeTrait > part = 
                    data::convert< data::Clang::Interface_ReturnTypeTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_canonical_type" );
                return part->canonical_type;
            }
            else
            {
                THROW_RTE( "Invalid call to set_canonical_type" );
            }
        }
        , m_data );
}
std::vector< std::string >& set_canonical_types(std::variant< data::Ptr< data::AST::Parser_ArgumentList >, data::Ptr< data::Tree::Interface_ArgumentListTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ArgumentListTrait > >)
            {
                data::Ptr< data::Clang::Interface_ArgumentListTrait > part = 
                    data::convert< data::Clang::Interface_ArgumentListTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_canonical_types" );
                return part->canonical_types;
            }
            else
            {
                THROW_RTE( "Invalid call to set_canonical_types" );
            }
        }
        , m_data );
}
mega::CardinalityRange& set_cardinality(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::CardinalityRange&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_cardinality" );
                return part->cardinality;
            }
            else
            {
                THROW_RTE( "Invalid call to set_cardinality" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& set_children(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ContextDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to set_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& set_children(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_ContextGroup > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Root > >)
            {
                data::Ptr< data::Concrete::Concrete_ContextGroup > part = 
                    data::convert< data::Concrete::Concrete_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to set_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >& set_children(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Invocations_Instructions_Instruction > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Root > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Enumeration > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Failure > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Elimination > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Prune > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup > part = 
                    data::convert< data::Operations::Invocations_Instructions_InstructionGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to set_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Name > >& set_children(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_Name > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_NameRoot > >)
            {
                data::Ptr< data::Operations::Operations_NameRoot > part = 
                    data::convert< data::Operations::Operations_NameRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_NameRoot > part = 
                    data::convert< data::Operations::Operations_NameRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to set_children" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_children(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_ContextGroup > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Root > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_ContextGroup > part = 
                    data::convert< data::Tree::Interface_ContextGroup >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_children" );
                return part->children;
            }
            else
            {
                THROW_RTE( "Invalid call to set_children" );
            }
        }
        , m_data );
}
data::Ptr< data::Components::Components_Component >& set_component(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Components::Components_Component >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_component" );
                return part->component;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_IncludeRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_component" );
                return part->component;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectSourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_component" );
                return part->component;
            }
            else
            {
                THROW_RTE( "Invalid call to set_component" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_concrete(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceDerivations::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& set_concrete(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Dimensions_User >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                    data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_concrete(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Instance > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Instance > part = 
                    data::convert< data::Operations::Invocations_Variables_Instance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_ConcreteVariant >& set_concrete(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_ConcreteVariant >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Element > >)
            {
                data::Ptr< data::Operations::Operations_Element > part = 
                    data::convert< data::Operations::Operations_Element >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& set_concrete(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceDerivations::Interface_IContext > part = 
                    data::convert< data::PerSourceDerivations::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete" );
                return part->concrete;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >& set_concrete_context_map(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_context_map" );
                return part->concrete_context_map;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_context_map" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Dimensions_User >& set_concrete_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Dimensions_User >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_dimension" );
                return part->concrete_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_dimension" );
                return part->concrete_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_dimension" );
            }
        }
        , m_data );
}
std::size_t& set_concrete_hash_code(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_hash_code" );
                return part->concrete_hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_hash_code" );
            }
        }
        , m_data );
}
std::int32_t& set_concrete_id(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::PerSourceConcreteTable::Concrete_Context > part = 
                    data::convert< data::PerSourceConcreteTable::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_id" );
                return part->concrete_id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_id" );
            }
        }
        , m_data );
}
std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& set_concrete_symbol_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_symbol_ids" );
                return part->concrete_symbol_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_symbol_ids" );
            }
        }
        , m_data );
}
std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& set_concrete_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::vector< std::int32_t >, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_symbols" );
                return part->concrete_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_symbols" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& set_concrete_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolTable > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_symbols" );
                return part->concrete_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_symbols" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_concrete_target(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_concrete_target" );
                return part->concrete_target;
            }
            else
            {
                THROW_RTE( "Invalid call to set_concrete_target" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_context(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > part = 
                    data::convert< data::ConcreteTable::Symbols_ConcreteSymbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_context(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Context >& set_context(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Root > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_Root > part = 
                    data::convert< data::Operations::Invocations_Instructions_Root >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& set_context(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ConcreteVariant > >)
            {
                data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                    data::convert< data::Operations::Operations_ConcreteVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_IContext > >& set_context(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_InterfaceVariant > >)
            {
                data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                    data::convert< data::Operations::Operations_InterfaceVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_Context >& set_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context" );
                return part->context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >& set_context_concrete_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Concrete::Concrete_Context >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_SymbolSet > part = 
                    data::convert< data::ConcreteTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context_concrete_ids" );
                return part->context_concrete_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context_concrete_ids" );
            }
        }
        , m_data );
}
std::string& set_context_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context_str" );
                return part->context_str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context_str" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& set_context_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context_symbols" );
                return part->context_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context_symbols" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >& set_context_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_IContext >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context_type_ids" );
                return part->context_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context_type_ids" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >& set_context_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_context_type_ids" );
                return part->context_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_context_type_ids" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_contexts(std::variant< data::Ptr< data::AST::Parser_Inheritance >, data::Ptr< data::Tree::Interface_InheritanceTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_InheritanceTrait > >)
            {
                data::Ptr< data::Clang::Interface_InheritanceTrait > part = 
                    data::convert< data::Clang::Interface_InheritanceTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_contexts" );
                return part->contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to set_contexts" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_contexts(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_contexts" );
                return part->contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to set_contexts" );
            }
        }
        , m_data );
}
boost::filesystem::path& set_cppSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_CPPInclude > >)
            {
                data::Ptr< data::AST::Parser_CPPInclude > part = 
                    data::convert< data::AST::Parser_CPPInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_cppSourceFilePath" );
                return part->cppSourceFilePath;
            }
            else
            {
                THROW_RTE( "Invalid call to set_cppSourceFilePath" );
            }
        }
        , m_data );
}
std::vector< std::string >& set_cpp_defines(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_cpp_defines" );
                return part->cpp_defines;
            }
            else
            {
                THROW_RTE( "Invalid call to set_cpp_defines" );
            }
        }
        , m_data );
}
std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& set_cpp_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::cppFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_cpp_dependencies" );
                return part->cpp_dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to set_cpp_dependencies" );
            }
        }
        , m_data );
}
std::vector< std::string >& set_cpp_flags(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_cpp_flags" );
                return part->cpp_flags;
            }
            else
            {
                THROW_RTE( "Invalid call to set_cpp_flags" );
            }
        }
        , m_data );
}
std::vector< mega::io::cppFilePath >& set_cpp_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::cppFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_cpp_source_files" );
                return part->cpp_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to set_cpp_source_files" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dependency > >& set_dependencies(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Dependency > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dependencies" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& set_dependencies(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dependencies" );
                return part->dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dependencies" );
            }
        }
        , m_data );
}
mega::DerivationDirection& set_derivation(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::DerivationDirection&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_derivation" );
                return part->derivation;
            }
            else
            {
                THROW_RTE( "Invalid call to set_derivation" );
            }
        }
        , m_data );
}
std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >& set_dimension(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::optional< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Nothing > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Singleton > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range32 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range64 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_dimension(std::variant< data::Ptr< data::Operations::Operations_ConcreteVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ConcreteVariant > >)
            {
                data::Ptr< data::Operations::Operations_ConcreteVariant > part = 
                    data::convert< data::Operations::Operations_ConcreteVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >& set_dimension(std::variant< data::Ptr< data::Operations::Operations_InterfaceVariant > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_InterfaceVariant > >)
            {
                data::Ptr< data::Operations::Operations_InterfaceVariant > part = 
                    data::convert< data::Operations::Operations_InterfaceVariant >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension" );
                return part->dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Dimension >& set_dimension_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Dimension >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                    data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_reference" );
                return part->dimension_reference;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_WriteLink > part = 
                    data::convert< data::Operations::Invocations_Operations_WriteLink >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_reference" );
                return part->dimension_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension_reference" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >& set_dimension_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_symbols" );
                return part->dimension_symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension_symbols" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& set_dimension_traits(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_traits" );
                return part->dimension_traits;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_Buffer > part = 
                    data::convert< data::Tree::Interface_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_traits" );
                return part->dimension_traits;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension_traits" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >& set_dimension_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_DimensionTrait >, int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_type_ids" );
                return part->dimension_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension_type_ids" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >& set_dimension_type_ids(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimension_type_ids" );
                return part->dimension_type_ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimension_type_ids" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Dimension > >& set_dimensions(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Dimension > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_dimensions(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Namespace > part = 
                    data::convert< data::Concrete::Concrete_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Action > part = 
                    data::convert< data::Concrete::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Event > part = 
                    data::convert< data::Concrete::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Object > part = 
                    data::convert< data::Concrete::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Buffer > part = 
                    data::convert< data::Concrete::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimensions" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >& set_dimensions(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_dimensions" );
                return part->dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_dimensions" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_Element >& set_element(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_Element >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_Name > part = 
                    data::convert< data::Operations::Operations_Name >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_element" );
                return part->element;
            }
            else
            {
                THROW_RTE( "Invalid call to set_element" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_Element > >& set_elements(std::variant< data::Ptr< data::Operations::Operations_ElementVector > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_Element > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_ElementVector > >)
            {
                data::Ptr< data::Operations::Operations_ElementVector > part = 
                    data::convert< data::Operations::Operations_ElementVector >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_elements" );
                return part->elements;
            }
            else
            {
                THROW_RTE( "Invalid call to set_elements" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_EventDef > >& set_event_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_EventDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_event_defs" );
                return part->event_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_event_defs" );
            }
        }
        , m_data );
}
std::optional< mega::ExplicitOperationID >& set_explicit_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< mega::ExplicitOperationID >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_explicit_operation" );
                return part->explicit_operation;
            }
            else
            {
                THROW_RTE( "Invalid call to set_explicit_operation" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& set_from(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Instance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_from" );
                return part->from;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_from" );
                return part->from;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_from" );
                return part->from;
            }
            else
            {
                THROW_RTE( "Invalid call to set_from" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& set_from_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Reference >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_PolyReference > part = 
                    data::convert< data::Operations::Invocations_Instructions_PolyReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_from_reference" );
                return part->from_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to set_from_reference" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_FunctionDef > >& set_function_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_FunctionDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_function_defs" );
                return part->function_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_function_defs" );
            }
        }
        , m_data );
}
std::string& set_glob(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Glob > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                    data::convert< data::DPGraph::Dependencies_Glob >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_glob" );
                return part->glob;
            }
            else
            {
                THROW_RTE( "Invalid call to set_glob" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >& set_globs(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::DPGraph::Dependencies_Glob > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_globs" );
                return part->globs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_globs" );
            }
        }
        , m_data );
}
std::size_t& set_hash_code(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to set_hash_code" );
            }
        }
        , m_data );
}
std::size_t& set_hash_code(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to set_hash_code" );
            }
        }
        , m_data );
}
std::size_t& set_hash_code(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to set_hash_code" );
            }
        }
        , m_data );
}
std::size_t& set_hash_code(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_hash_code" );
                return part->hash_code;
            }
            else
            {
                THROW_RTE( "Invalid call to set_hash_code" );
            }
        }
        , m_data );
}
std::optional< bool >& set_homogeneous(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< bool >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_homogeneous" );
                return part->homogeneous;
            }
            else
            {
                THROW_RTE( "Invalid call to set_homogeneous" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& set_id(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ScopedIdentifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_id" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Identifier >& set_id(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Identifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_id" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ScopedIdentifier >& set_id(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ScopedIdentifier >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeNested > >)
            {
                data::Ptr< data::AST::Parser_MegaIncludeNested > part = 
                    data::convert< data::AST::Parser_MegaIncludeNested >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_id" );
            }
        }
        , m_data );
}
std::int32_t& set_id(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > part = 
                    data::convert< data::ConcreteTable::Symbols_ConcreteSymbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_id" );
            }
        }
        , m_data );
}
std::int32_t& set_id(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id" );
                return part->id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_id" );
            }
        }
        , m_data );
}
std::vector< std::int32_t >& set_id_sequence(std::variant< data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > >)
            {
                data::Ptr< data::ConcreteTable::Symbols_ConcreteSymbol > part = 
                    data::convert< data::ConcreteTable::Symbols_ConcreteSymbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_id_sequence" );
                return part->id_sequence;
            }
            else
            {
                THROW_RTE( "Invalid call to set_id_sequence" );
            }
        }
        , m_data );
}
std::string& set_identifier(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_identifier" );
                return part->identifier;
            }
            else
            {
                THROW_RTE( "Invalid call to set_identifier" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Identifier > >& set_ids(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Identifier > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_ids" );
                return part->ids;
            }
            else
            {
                THROW_RTE( "Invalid call to set_ids" );
            }
        }
        , m_data );
}
std::vector< boost::filesystem::path >& set_include_directories(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< boost::filesystem::path >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_include_directories" );
                return part->include_directories;
            }
            else
            {
                THROW_RTE( "Invalid call to set_include_directories" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_Include > >& set_includes(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_Include > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ContextDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_NamespaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_BufferDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MetaDef > >)
            {
                data::Ptr< data::AST::Parser_ContextDef > part = 
                    data::convert< data::AST::Parser_ContextDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_includes" );
                return part->includes;
            }
            else
            {
                THROW_RTE( "Invalid call to set_includes" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& set_inheritance(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Inheritance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_AbstractDef > >)
            {
                data::Ptr< data::AST::Parser_AbstractDef > part = 
                    data::convert< data::AST::Parser_AbstractDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ActionDef > part = 
                    data::convert< data::AST::Parser_ActionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_EventDef > part = 
                    data::convert< data::AST::Parser_EventDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectDef > >)
            {
                data::Ptr< data::AST::Parser_ObjectDef > part = 
                    data::convert< data::AST::Parser_ObjectDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Tree::Interface_IContext > >& set_inheritance(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Tree::Interface_IContext > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance" );
                return part->inheritance;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& set_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_contexts" );
                return part->inheritance_contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance_contexts" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >& set_inheritance_contexts(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_contexts" );
                return part->inheritance_contexts;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance_contexts" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_dimensions" );
                return part->inheritance_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance_dimensions" );
            }
        }
        , m_data );
}
std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_inheritance_dimensions(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::multimap< data::Ptr< data::Tree::Interface_DimensionTrait >, data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_dimensions" );
                return part->inheritance_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance_dimensions" );
            }
        }
        , m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >& set_inheritance_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_Abstract > part = 
                    data::convert< data::Tree::Interface_Abstract >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_trait" );
                return part->inheritance_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_trait" );
                return part->inheritance_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_trait" );
                return part->inheritance_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_inheritance_trait" );
                return part->inheritance_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to set_inheritance_trait" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& set_instance(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Instance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_Enumeration > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_Enumeration > part = 
                    data::convert< data::Operations::Invocations_Instructions_Enumeration >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead > part = 
                    data::convert< data::Operations::Invocations_Instructions_DimensionReferenceRead >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                    data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_instance" );
                return part->instance;
            }
            else
            {
                THROW_RTE( "Invalid call to set_instance" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_IContext >& set_interface(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_IContext >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_IContext >& set_interface(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_IContext >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_BasicOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_BasicOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_InterfaceVariant >& set_interface(std::variant< data::Ptr< data::Operations::Operations_Element > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_InterfaceVariant >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Element > >)
            {
                data::Ptr< data::Operations::Operations_Element > part = 
                    data::convert< data::Operations::Operations_Element >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface" );
                return part->interface;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Action >& set_interface_action(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Action >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Action > part = 
                    data::convert< data::Concrete::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_action" );
                return part->interface_action;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_action" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Buffer >& set_interface_buffer(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Buffer >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Buffer > part = 
                    data::convert< data::Concrete::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_buffer" );
                return part->interface_buffer;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_buffer" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& set_interface_dimension(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_DimensionTrait >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Dimensions_User > >)
            {
                data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                    data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_dimension" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_DimensionTrait >& set_interface_dimension(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_DimensionTrait >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > part = 
                    data::convert< data::Operations::Invocations_Operations_DimensionOperation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_dimension" );
                return part->interface_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_dimension" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Event >& set_interface_event(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Event >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Event > part = 
                    data::convert< data::Concrete::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_event" );
                return part->interface_event;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_event" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Function >& set_interface_function(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Function >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Function > part = 
                    data::convert< data::Concrete::Concrete_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_function" );
                return part->interface_function;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_function" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Namespace >& set_interface_namespace(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Namespace >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Namespace > part = 
                    data::convert< data::Concrete::Concrete_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_namespace" );
                return part->interface_namespace;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_namespace" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Object >& set_interface_object(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Object >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Object > part = 
                    data::convert< data::Concrete::Concrete_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_object" );
                return part->interface_object;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_object" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Root >& set_interface_root(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Root >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Root > >)
            {
                data::Ptr< data::Concrete::Concrete_Root > part = 
                    data::convert< data::Concrete::Concrete_Root >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_interface_root" );
                return part->interface_root;
            }
            else
            {
                THROW_RTE( "Invalid call to set_interface_root" );
            }
        }
        , m_data );
}
std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >& set_invocations(std::variant< data::Ptr< data::Operations::Operations_Invocations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::InvocationID, data::Ptr< data::Operations::Operations_Invocation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocations > >)
            {
                data::Ptr< data::Operations::Operations_Invocations > part = 
                    data::convert< data::Operations::Operations_Invocations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_invocations" );
                return part->invocations;
            }
            else
            {
                THROW_RTE( "Invalid call to set_invocations" );
            }
        }
        , m_data );
}
bool& set_isConst(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_isConst" );
                return part->isConst;
            }
            else
            {
                THROW_RTE( "Invalid call to set_isConst" );
            }
        }
        , m_data );
}
std::optional< bool >& set_is_function_call(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< bool >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_is_function_call" );
                return part->is_function_call;
            }
            else
            {
                THROW_RTE( "Invalid call to set_is_function_call" );
            }
        }
        , m_data );
}
bool& set_is_global(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_is_global" );
                return part->is_global;
            }
            else
            {
                THROW_RTE( "Invalid call to set_is_global" );
            }
        }
        , m_data );
}
bool& set_is_member(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_Name > part = 
                    data::convert< data::Operations::Operations_Name >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_is_member" );
                return part->is_member;
            }
            else
            {
                THROW_RTE( "Invalid call to set_is_member" );
            }
        }
        , m_data );
}
bool& set_is_reference(std::variant< data::Ptr< data::Operations::Operations_NameRoot >, data::Ptr< data::Operations::Operations_Name > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Name > >)
            {
                data::Ptr< data::Operations::Operations_Name > part = 
                    data::convert< data::Operations::Operations_Name >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_is_reference" );
                return part->is_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to set_is_reference" );
            }
        }
        , m_data );
}
std::size_t& set_line_number(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_line_number" );
                return part->line_number;
            }
            else
            {
                THROW_RTE( "Invalid call to set_line_number" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Link >& set_link(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Link > part = 
                    data::convert< data::Concrete::Concrete_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link" );
                return part->link;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Link >& set_link(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link" );
                return part->link;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link" );
                return part->link;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link" );
                return part->link;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_LinkDef > >& set_link_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_LinkDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_defs" );
                return part->link_defs;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_defs" );
                return part->link_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >& set_link_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_dimensions" );
                return part->link_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link_dimensions" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_LinkInterface >& set_link_interface(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_LinkInterface >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_LinkInterfaceDef > part = 
                    data::convert< data::AST::Parser_LinkInterfaceDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_interface" );
                return part->link_interface;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >& set_link_reference(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                    data::convert< data::MemoryLayout::Concrete_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_reference" );
                return part->link_reference;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link_reference" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >& set_link_target(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_InheritanceTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_target" );
                return part->link_target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_Link > part = 
                    data::convert< data::Tree::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_target" );
                return part->link_target;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link_target" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >& set_link_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_LinkTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_LinkInterface > part = 
                    data::convert< data::Tree::Interface_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_link_trait" );
                return part->link_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to set_link_trait" );
            }
        }
        , m_data );
}
std::size_t& set_local_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                    data::convert< data::MemoryLayout::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_local_size" );
                return part->local_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                    data::convert< data::MemoryLayout::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_local_size" );
                return part->local_size;
            }
            else
            {
                THROW_RTE( "Invalid call to set_local_size" );
            }
        }
        , m_data );
}
boost::filesystem::path& set_location(std::variant< data::Ptr< data::DPGraph::Dependencies_Glob > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Glob > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Glob > part = 
                    data::convert< data::DPGraph::Dependencies_Glob >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_location" );
                return part->location;
            }
            else
            {
                THROW_RTE( "Invalid call to set_location" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& set_mappings(std::variant< data::Ptr< data::Derivations::Derivation_Mapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Derivations::Derivation_ObjectMapping > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_Mapping > >)
            {
                data::Ptr< data::Derivations::Derivation_Mapping > part = 
                    data::convert< data::Derivations::Derivation_Mapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_mappings" );
                return part->mappings;
            }
            else
            {
                THROW_RTE( "Invalid call to set_mappings" );
            }
        }
        , m_data );
}
boost::filesystem::path& set_megaSourceFilePath(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaInclude > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_megaSourceFilePath" );
                return part->megaSourceFilePath;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeInline > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_megaSourceFilePath" );
                return part->megaSourceFilePath;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeNested > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_megaSourceFilePath" );
                return part->megaSourceFilePath;
            }
            else
            {
                THROW_RTE( "Invalid call to set_megaSourceFilePath" );
            }
        }
        , m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& set_mega_dependencies(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::megaFilePath, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_mega_dependencies" );
                return part->mega_dependencies;
            }
            else
            {
                THROW_RTE( "Invalid call to set_mega_dependencies" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& set_mega_source_files(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_mega_source_files" );
                return part->mega_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to set_mega_source_files" );
            }
        }
        , m_data );
}
std::vector< mega::io::megaFilePath >& set_mega_source_files(std::variant< data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< mega::io::megaFilePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_TransitiveDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_TransitiveDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_mega_source_files" );
                return part->mega_source_files;
            }
            else
            {
                THROW_RTE( "Invalid call to set_mega_source_files" );
            }
        }
        , m_data );
}
std::string& set_name(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_name" );
                return part->name;
            }
            else
            {
                THROW_RTE( "Invalid call to set_name" );
            }
        }
        , m_data );
}
std::string& set_name(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_name" );
                return part->name;
            }
            else
            {
                THROW_RTE( "Invalid call to set_name" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Operations_NameResolution > >& set_name_resolution(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Operations_NameResolution > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_name_resolution" );
                return part->name_resolution;
            }
            else
            {
                THROW_RTE( "Invalid call to set_name_resolution" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ContextDef > >& set_namespace_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ContextDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_Namespace > part = 
                    data::convert< data::Tree::Interface_Namespace >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_namespace_defs" );
                return part->namespace_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_namespace_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::AST::Parser_ObjectDef > >& set_object_defs(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::AST::Parser_ObjectDef > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_Object > part = 
                    data::convert< data::Tree::Interface_Object >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_object_defs" );
                return part->object_defs;
            }
            else
            {
                THROW_RTE( "Invalid call to set_object_defs" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& set_objects(std::variant< data::Ptr< data::DPGraph::Dependencies_Analysis > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_Analysis > >)
            {
                data::Ptr< data::DPGraph::Dependencies_Analysis > part = 
                    data::convert< data::DPGraph::Dependencies_Analysis >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_objects" );
                return part->objects;
            }
            else
            {
                THROW_RTE( "Invalid call to set_objects" );
            }
        }
        , m_data );
}
mega::OperationID& set_operation(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::OperationID&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_operation" );
                return part->operation;
            }
            else
            {
                THROW_RTE( "Invalid call to set_operation" );
            }
        }
        , m_data );
}
mega::Ownership& set_ownership(std::variant< data::Ptr< data::AST::Parser_LinkInterface > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::Ownership&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterface > >)
            {
                data::Ptr< data::AST::Parser_LinkInterface > part = 
                    data::convert< data::AST::Parser_LinkInterface >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_ownership" );
                return part->ownership;
            }
            else
            {
                THROW_RTE( "Invalid call to set_ownership" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& set_parameter_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parameter_types" );
                return part->parameter_types;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parameter_types" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_IContext >& set_parent(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_IContext >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Tree::Interface_DimensionTrait > part = 
                    data::convert< data::Tree::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_ContextGroup >& set_parent(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_ContextGroup >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Context > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Namespace > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Function > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Object > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::Concrete::Concrete_Context > part = 
                    data::convert< data::Concrete::Concrete_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_parent(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Dimensions_User > >)
            {
                data::Ptr< data::Concrete::Concrete_Dimensions_User > part = 
                    data::convert< data::Concrete::Concrete_Dimensions_User >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Concrete::Concrete_Context >& set_parent(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Concrete::Concrete_Context >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >& set_parent(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Invocations_Variables_Variable > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Variable > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Instance > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Reference > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Dimension > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Context > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Variable > part = 
                    data::convert< data::Operations::Invocations_Variables_Variable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_ContextGroup >& set_parent(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_ContextGroup >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::Tree::Interface_IContext > part = 
                    data::convert< data::Tree::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent" );
                return part->parent;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Concrete::Concrete_Context > >& set_parent_context(std::variant< data::Ptr< data::MemoryLayout::Allocators_Allocator >, data::Ptr< data::MemoryLayout::Allocators_Nothing >, data::Ptr< data::MemoryLayout::Allocators_Singleton >, data::Ptr< data::MemoryLayout::Allocators_Range >, data::Ptr< data::MemoryLayout::Allocators_Range32 >, data::Ptr< data::MemoryLayout::Allocators_Range64 >, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Nothing > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Singleton > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range32 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_Range64 > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Allocators_RangeAny > >)
            {
                data::Ptr< data::MemoryLayout::Allocators_Allocator > part = 
                    data::convert< data::MemoryLayout::Allocators_Allocator >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parent_context" );
                return part->parent_context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parent_context" );
            }
        }
        , m_data );
}
data::Ptr< data::MemoryLayout::MemoryLayout_Part >& set_part(std::variant< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::MemoryLayout::MemoryLayout_Part >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Dimensions_User > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_User > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_User >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_part" );
                return part->part;
            }
            else
            {
                THROW_RTE( "Invalid call to set_part" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& set_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_part" );
                return part->part;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocator > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_Allocation > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_Allocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_part" );
                return part->part;
            }
            else
            {
                THROW_RTE( "Invalid call to set_part" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& set_part(std::variant< data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle >, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_part" );
                return part->part;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkSingle > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_part" );
                return part->part;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkMany > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Dimensions_LinkReference > part = 
                    data::convert< data::MemoryLayout::Concrete_Dimensions_LinkReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_part" );
                return part->part;
            }
            else
            {
                THROW_RTE( "Invalid call to set_part" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& set_parts(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Buffer >, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer >, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_NonSimpleBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_SimpleBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parts" );
                return part->parts;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_GPUBuffer > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Buffer > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_parts" );
                return part->parts;
            }
            else
            {
                THROW_RTE( "Invalid call to set_parts" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Reference >& set_reference(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Reference >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_MonoReference > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_MonoReference > part = 
                    data::convert< data::Operations::Invocations_Instructions_MonoReference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_reference" );
                return part->reference;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                    data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_reference" );
                return part->reference;
            }
            else
            {
                THROW_RTE( "Invalid call to set_reference" );
            }
        }
        , m_data );
}
data::Ptr< data::Model::HyperGraph_Relation >& set_relation(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Model::HyperGraph_Relation >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceModel::Interface_Link > part = 
                    data::convert< data::PerSourceModel::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_relation" );
                return part->relation;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceModel::Interface_Link > part = 
                    data::convert< data::PerSourceModel::Interface_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_relation" );
                return part->relation;
            }
            else
            {
                THROW_RTE( "Invalid call to set_relation" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Model::HyperGraph_Relations > >& set_relations(std::variant< data::Ptr< data::Model::HyperGraph_Graph > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Model::HyperGraph_Relations > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Graph > >)
            {
                data::Ptr< data::Model::HyperGraph_Graph > part = 
                    data::convert< data::Model::HyperGraph_Graph >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_relations" );
                return part->relations;
            }
            else
            {
                THROW_RTE( "Invalid call to set_relations" );
            }
        }
        , m_data );
}
std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >& set_relations(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Model::HyperGraph_Relation > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_relations" );
                return part->relations;
            }
            else
            {
                THROW_RTE( "Invalid call to set_relations" );
            }
        }
        , m_data );
}
std::vector< boost::filesystem::path >& set_resolution(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< boost::filesystem::path >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_resolution" );
                return part->resolution;
            }
            else
            {
                THROW_RTE( "Invalid call to set_resolution" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ReturnType >& set_returnType(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ReturnType >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_FunctionDef > >)
            {
                data::Ptr< data::AST::Parser_FunctionDef > part = 
                    data::convert< data::AST::Parser_FunctionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_returnType" );
                return part->returnType;
            }
            else
            {
                THROW_RTE( "Invalid call to set_returnType" );
            }
        }
        , m_data );
}
std::optional< std::string >& set_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_type_str" );
                return part->return_type_str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_return_type_str" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >& set_return_type_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Tree::Interface_ReturnTypeTrait > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::Tree::Interface_Function > part = 
                    data::convert< data::Tree::Interface_Function >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_type_trait" );
                return part->return_type_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to set_return_type_trait" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >& set_return_types(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_InterfaceVariant > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Operation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_BasicOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Allocate > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Call > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Start > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Stop > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Pause > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Resume > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Done > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WaitDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetAction > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_GetDimension > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Read > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Write > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_WriteLink > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Operations_Range > >)
            {
                data::Ptr< data::Operations::Invocations_Operations_Operation > part = 
                    data::convert< data::Operations::Invocations_Operations_Operation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types" );
                return part->return_types;
            }
            else
            {
                THROW_RTE( "Invalid call to set_return_types" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >& set_return_types_context(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_IContext > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types_context" );
                return part->return_types_context;
            }
            else
            {
                THROW_RTE( "Invalid call to set_return_types_context" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >& set_return_types_dimension(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Tree::Interface_DimensionTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_return_types_dimension" );
                return part->return_types_dimension;
            }
            else
            {
                THROW_RTE( "Invalid call to set_return_types_dimension" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >& set_root(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::AST::Parser_IncludeRoot > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaInclude > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root" );
                return part->root;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeInline > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root" );
                return part->root;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_MegaIncludeNested > >)
            {
                data::Ptr< data::AST::Parser_MegaInclude > part = 
                    data::convert< data::AST::Parser_MegaInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root" );
                return part->root;
            }
            else
            {
                THROW_RTE( "Invalid call to set_root" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_ObjectSourceRoot >& set_root(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_ObjectSourceRoot >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Root > >)
            {
                data::Ptr< data::Tree::Interface_Root > part = 
                    data::convert< data::Tree::Interface_Root >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root" );
                return part->root;
            }
            else
            {
                THROW_RTE( "Invalid call to set_root" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >& set_root_instruction(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Invocations_Instructions_Root > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root_instruction" );
                return part->root_instruction;
            }
            else
            {
                THROW_RTE( "Invalid call to set_root_instruction" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_NameRoot >& set_root_name(std::variant< data::Ptr< data::Operations::Operations_NameResolution > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_NameRoot >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_NameResolution > >)
            {
                data::Ptr< data::Operations::Operations_NameResolution > part = 
                    data::convert< data::Operations::Operations_NameResolution >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root_name" );
                return part->root_name;
            }
            else
            {
                THROW_RTE( "Invalid call to set_root_name" );
            }
        }
        , m_data );
}
std::optional< data::Ptr< data::Operations::Invocations_Variables_Context > >& set_root_variable(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< data::Ptr< data::Operations::Invocations_Variables_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_root_variable" );
                return part->root_variable;
            }
            else
            {
                THROW_RTE( "Invalid call to set_root_variable" );
            }
        }
        , m_data );
}
std::optional< std::string >& set_runtime_return_type_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_runtime_return_type_str" );
                return part->runtime_return_type_str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_runtime_return_type_str" );
            }
        }
        , m_data );
}
bool& set_simple(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> bool&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_simple" );
                return part->simple;
            }
            else
            {
                THROW_RTE( "Invalid call to set_simple" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Size >& set_size(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Size >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ActionDef > >)
            {
                data::Ptr< data::AST::Parser_ActionDef > part = 
                    data::convert< data::AST::Parser_ActionDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_size" );
                return part->size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_EventDef > >)
            {
                data::Ptr< data::AST::Parser_EventDef > part = 
                    data::convert< data::AST::Parser_EventDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_size" );
                return part->size;
            }
            else
            {
                THROW_RTE( "Invalid call to set_size" );
            }
        }
        , m_data );
}
std::size_t& set_size(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_size" );
                return part->size;
            }
            else
            {
                THROW_RTE( "Invalid call to set_size" );
            }
        }
        , m_data );
}
std::size_t& set_size(std::variant< data::Ptr< data::AST::Parser_Size >, data::Ptr< data::Tree::Interface_SizeTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_SizeTrait > >)
            {
                data::Ptr< data::Clang::Interface_SizeTrait > part = 
                    data::convert< data::Clang::Interface_SizeTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_size" );
                return part->size;
            }
            else
            {
                THROW_RTE( "Invalid call to set_size" );
            }
        }
        , m_data );
}
std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >& set_size_trait(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::optional< data::Ptr< data::Tree::Interface_SizeTrait > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::Tree::Interface_Action > part = 
                    data::convert< data::Tree::Interface_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_size_trait" );
                return part->size_trait;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::Tree::Interface_Event > part = 
                    data::convert< data::Tree::Interface_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_size_trait" );
                return part->size_trait;
            }
            else
            {
                THROW_RTE( "Invalid call to set_size_trait" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Link >& set_source(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source" );
                return part->source;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source" );
            }
        }
        , m_data );
}
boost::filesystem::path& set_sourceFile(std::variant< data::Ptr< data::AST::Parser_SourceRoot >, data::Ptr< data::AST::Parser_IncludeRoot >, data::Ptr< data::AST::Parser_ObjectSourceRoot > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_sourceFile" );
                return part->sourceFile;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_IncludeRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_sourceFile" );
                return part->sourceFile;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ObjectSourceRoot > >)
            {
                data::Ptr< data::AST::Parser_SourceRoot > part = 
                    data::convert< data::AST::Parser_SourceRoot >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_sourceFile" );
                return part->sourceFile;
            }
            else
            {
                THROW_RTE( "Invalid call to set_sourceFile" );
            }
        }
        , m_data );
}
std::string& set_source_file(std::variant< data::Ptr< data::AST::Parser_ScopedIdentifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ScopedIdentifier > >)
            {
                data::Ptr< data::AST::Parser_ScopedIdentifier > part = 
                    data::convert< data::AST::Parser_ScopedIdentifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > >)
            {
                data::Ptr< data::DPGraph::Dependencies_SourceFileDependencies > part = 
                    data::convert< data::DPGraph::Dependencies_SourceFileDependencies >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::Derivations::Derivation_ObjectMapping > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Derivations::Derivation_ObjectMapping > >)
            {
                data::Ptr< data::Derivations::Derivation_ObjectMapping > part = 
                    data::convert< data::Derivations::Derivation_ObjectMapping >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::Model::HyperGraph_Relations > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relations > >)
            {
                data::Ptr< data::Model::HyperGraph_Relations > part = 
                    data::convert< data::Model::HyperGraph_Relations >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source_file" );
            }
        }
        , m_data );
}
mega::io::megaFilePath& set_source_file(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::io::megaFilePath&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source_file" );
                return part->source_file;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source_file" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& set_source_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_LinkInterface >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_source_interface" );
                return part->source_interface;
            }
            else
            {
                THROW_RTE( "Invalid call to set_source_interface" );
            }
        }
        , m_data );
}
boost::filesystem::path& set_src_dir(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> boost::filesystem::path&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_src_dir" );
                return part->src_dir;
            }
            else
            {
                THROW_RTE( "Invalid call to set_src_dir" );
            }
        }
        , m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_ArgumentList > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ArgumentList > >)
            {
                data::Ptr< data::AST::Parser_ArgumentList > part = 
                    data::convert< data::AST::Parser_ArgumentList >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_str" );
            }
        }
        , m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Dependency > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dependency > >)
            {
                data::Ptr< data::AST::Parser_Dependency > part = 
                    data::convert< data::AST::Parser_Dependency >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_str" );
            }
        }
        , m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Identifier > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Identifier > >)
            {
                data::Ptr< data::AST::Parser_Identifier > part = 
                    data::convert< data::AST::Parser_Identifier >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_str" );
            }
        }
        , m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Include >, data::Ptr< data::AST::Parser_SystemInclude >, data::Ptr< data::AST::Parser_MegaInclude >, data::Ptr< data::AST::Parser_MegaIncludeInline >, data::Ptr< data::AST::Parser_MegaIncludeNested >, data::Ptr< data::AST::Parser_CPPInclude > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_SystemInclude > >)
            {
                data::Ptr< data::AST::Parser_SystemInclude > part = 
                    data::convert< data::AST::Parser_SystemInclude >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_str" );
            }
        }
        , m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_ReturnType > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_ReturnType > >)
            {
                data::Ptr< data::AST::Parser_ReturnType > part = 
                    data::convert< data::AST::Parser_ReturnType >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_str" );
            }
        }
        , m_data );
}
std::string& set_str(std::variant< data::Ptr< data::AST::Parser_Size > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Size > >)
            {
                data::Ptr< data::AST::Parser_Size > part = 
                    data::convert< data::AST::Parser_Size >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_str" );
                return part->str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_str" );
            }
        }
        , m_data );
}
std::vector< std::string >& set_strings(std::variant< data::Ptr< data::AST::Parser_Inheritance > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< std::string >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Inheritance > >)
            {
                data::Ptr< data::AST::Parser_Inheritance > part = 
                    data::convert< data::AST::Parser_Inheritance >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_strings" );
                return part->strings;
            }
            else
            {
                THROW_RTE( "Invalid call to set_strings" );
            }
        }
        , m_data );
}
std::int32_t& set_symbol(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbol" );
            }
        }
        , m_data );
}
std::string& set_symbol(std::variant< data::Ptr< data::SymbolTable::Symbols_Symbol > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_Symbol > >)
            {
                data::Ptr< data::SymbolTable::Symbols_Symbol > part = 
                    data::convert< data::SymbolTable::Symbols_Symbol >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbol" );
            }
        }
        , m_data );
}
std::int32_t& set_symbol(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::int32_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol" );
                return part->symbol;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbol" );
            }
        }
        , m_data );
}
std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >& set_symbol_id_map(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::int32_t, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol_id_map" );
                return part->symbol_id_map;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbol_id_map" );
            }
        }
        , m_data );
}
std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& set_symbol_sets(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< mega::io::megaFilePath, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbol_sets" );
                return part->symbol_sets;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbol_sets" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >& set_symbols(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::Clang::Interface_DimensionTrait > part = 
                    data::convert< data::Clang::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbols" );
            }
        }
        , m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& set_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolSet > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolSet > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolSet > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolSet >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbols" );
            }
        }
        , m_data );
}
std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >& set_symbols(std::variant< data::Ptr< data::SymbolTable::Symbols_SymbolTable > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::map< std::string, data::Ptr< data::SymbolTable::Symbols_Symbol > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::SymbolTable::Symbols_SymbolTable > >)
            {
                data::Ptr< data::SymbolTable::Symbols_SymbolTable > part = 
                    data::convert< data::SymbolTable::Symbols_SymbolTable >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_symbols" );
                return part->symbols;
            }
            else
            {
                THROW_RTE( "Invalid call to set_symbols" );
            }
        }
        , m_data );
}
data::Ptr< data::AST::Parser_Inheritance >& set_target(std::variant< data::Ptr< data::AST::Parser_ContextDef >, data::Ptr< data::AST::Parser_NamespaceDef >, data::Ptr< data::AST::Parser_AbstractDef >, data::Ptr< data::AST::Parser_ActionDef >, data::Ptr< data::AST::Parser_EventDef >, data::Ptr< data::AST::Parser_FunctionDef >, data::Ptr< data::AST::Parser_ObjectDef >, data::Ptr< data::AST::Parser_LinkDef >, data::Ptr< data::AST::Parser_LinkInterfaceDef >, data::Ptr< data::AST::Parser_BufferDef >, data::Ptr< data::AST::Parser_MetaDef > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::AST::Parser_Inheritance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkDef > >)
            {
                data::Ptr< data::AST::Parser_LinkDef > part = 
                    data::convert< data::AST::Parser_LinkDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_target" );
                return part->target;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_LinkInterfaceDef > >)
            {
                data::Ptr< data::AST::Parser_LinkDef > part = 
                    data::convert< data::AST::Parser_LinkDef >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_target" );
                return part->target;
            }
            else
            {
                THROW_RTE( "Invalid call to set_target" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_Link >& set_target(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_Link >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_target" );
                return part->target;
            }
            else
            {
                THROW_RTE( "Invalid call to set_target" );
            }
        }
        , m_data );
}
data::Ptr< data::Tree::Interface_LinkInterface >& set_target_interface(std::variant< data::Ptr< data::Model::HyperGraph_Relation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Tree::Interface_LinkInterface >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Model::HyperGraph_Relation > >)
            {
                data::Ptr< data::Model::HyperGraph_Relation > part = 
                    data::convert< data::Model::HyperGraph_Relation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_target_interface" );
                return part->target_interface;
            }
            else
            {
                THROW_RTE( "Invalid call to set_target_interface" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Invocations_Variables_Instance >& set_to(std::variant< data::Ptr< data::Operations::Invocations_Instructions_Instruction >, data::Ptr< data::Operations::Invocations_Instructions_InstructionGroup >, data::Ptr< data::Operations::Invocations_Instructions_Root >, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation >, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation >, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation >, data::Ptr< data::Operations::Invocations_Instructions_Enumeration >, data::Ptr< data::Operations::Invocations_Instructions_DimensionReferenceRead >, data::Ptr< data::Operations::Invocations_Instructions_MonoReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyReference >, data::Ptr< data::Operations::Invocations_Instructions_PolyCase >, data::Ptr< data::Operations::Invocations_Instructions_Failure >, data::Ptr< data::Operations::Invocations_Instructions_Elimination >, data::Ptr< data::Operations::Invocations_Instructions_Prune >, data::Ptr< data::Operations::Invocations_Operations_Operation >, data::Ptr< data::Operations::Invocations_Operations_BasicOperation >, data::Ptr< data::Operations::Invocations_Operations_DimensionOperation >, data::Ptr< data::Operations::Invocations_Operations_Allocate >, data::Ptr< data::Operations::Invocations_Operations_Call >, data::Ptr< data::Operations::Invocations_Operations_Start >, data::Ptr< data::Operations::Invocations_Operations_Stop >, data::Ptr< data::Operations::Invocations_Operations_Pause >, data::Ptr< data::Operations::Invocations_Operations_Resume >, data::Ptr< data::Operations::Invocations_Operations_Done >, data::Ptr< data::Operations::Invocations_Operations_WaitAction >, data::Ptr< data::Operations::Invocations_Operations_WaitDimension >, data::Ptr< data::Operations::Invocations_Operations_GetAction >, data::Ptr< data::Operations::Invocations_Operations_GetDimension >, data::Ptr< data::Operations::Invocations_Operations_Read >, data::Ptr< data::Operations::Invocations_Operations_Write >, data::Ptr< data::Operations::Invocations_Operations_WriteLink >, data::Ptr< data::Operations::Invocations_Operations_Range > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Invocations_Variables_Instance >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ParentDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ParentDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_to" );
                return part->to;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_ChildDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_ChildDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_to" );
                return part->to;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_EnumDerivation > part = 
                    data::convert< data::Operations::Invocations_Instructions_EnumDerivation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_to" );
                return part->to;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Instructions_PolyCase > >)
            {
                data::Ptr< data::Operations::Invocations_Instructions_PolyCase > part = 
                    data::convert< data::Operations::Invocations_Instructions_PolyCase >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_to" );
                return part->to;
            }
            else
            {
                THROW_RTE( "Invalid call to set_to" );
            }
        }
        , m_data );
}
std::size_t& set_total_size(std::variant< data::Ptr< data::Concrete::Concrete_ContextGroup >, data::Ptr< data::Concrete::Concrete_Context >, data::Ptr< data::Concrete::Concrete_Namespace >, data::Ptr< data::Concrete::Concrete_Action >, data::Ptr< data::Concrete::Concrete_Event >, data::Ptr< data::Concrete::Concrete_Function >, data::Ptr< data::Concrete::Concrete_Object >, data::Ptr< data::Concrete::Concrete_Link >, data::Ptr< data::Concrete::Concrete_Buffer >, data::Ptr< data::Concrete::Concrete_Root > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::size_t&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Action > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Action > part = 
                    data::convert< data::MemoryLayout::Concrete_Action >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_total_size" );
                return part->total_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Event > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Event > part = 
                    data::convert< data::MemoryLayout::Concrete_Event >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_total_size" );
                return part->total_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Link > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Link > part = 
                    data::convert< data::MemoryLayout::Concrete_Link >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_total_size" );
                return part->total_size;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Concrete::Concrete_Buffer > >)
            {
                data::Ptr< data::MemoryLayout::Concrete_Buffer > part = 
                    data::convert< data::MemoryLayout::Concrete_Buffer >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_total_size" );
                return part->total_size;
            }
            else
            {
                THROW_RTE( "Invalid call to set_total_size" );
            }
        }
        , m_data );
}
std::string& set_type(std::variant< data::Ptr< data::AST::Parser_Dimension > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::AST::Parser_Dimension > >)
            {
                data::Ptr< data::AST::Parser_Dimension > part = 
                    data::convert< data::AST::Parser_Dimension >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type" );
                return part->type;
            }
            else
            {
                THROW_RTE( "Invalid call to set_type" );
            }
        }
        , m_data );
}
mega::ComponentType& set_type(std::variant< data::Ptr< data::Components::Components_Component > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> mega::ComponentType&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Components::Components_Component > >)
            {
                data::Ptr< data::Components::Components_Component > part = 
                    data::convert< data::Components::Components_Component >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type" );
                return part->type;
            }
            else
            {
                THROW_RTE( "Invalid call to set_type" );
            }
        }
        , m_data );
}
std::optional< std::int32_t >& set_type_id(std::variant< data::Ptr< data::AST::Parser_Dimension >, data::Ptr< data::Tree::Interface_DimensionTrait > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_DimensionTrait > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_DimensionTrait > part = 
                    data::convert< data::PerSourceSymbols::Interface_DimensionTrait >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_type_id" );
            }
        }
        , m_data );
}
std::optional< std::int32_t >& set_type_id(std::variant< data::Ptr< data::Tree::Interface_ContextGroup >, data::Ptr< data::Tree::Interface_Root >, data::Ptr< data::Tree::Interface_IContext >, data::Ptr< data::Tree::Interface_Namespace >, data::Ptr< data::Tree::Interface_Abstract >, data::Ptr< data::Tree::Interface_Action >, data::Ptr< data::Tree::Interface_Event >, data::Ptr< data::Tree::Interface_Function >, data::Ptr< data::Tree::Interface_Object >, data::Ptr< data::Tree::Interface_Link >, data::Ptr< data::Tree::Interface_LinkInterface >, data::Ptr< data::Tree::Interface_Buffer > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::int32_t >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_IContext > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Namespace > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Abstract > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Action > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Event > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Function > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Object > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Link > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_LinkInterface > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Tree::Interface_Buffer > >)
            {
                data::Ptr< data::PerSourceSymbols::Interface_IContext > part = 
                    data::convert< data::PerSourceSymbols::Interface_IContext >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_id" );
                return part->type_id;
            }
            else
            {
                THROW_RTE( "Invalid call to set_type_id" );
            }
        }
        , m_data );
}
data::Ptr< data::Operations::Operations_TypePath >& set_type_path(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> data::Ptr< data::Operations::Operations_TypePath >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_path" );
                return part->type_path;
            }
            else
            {
                THROW_RTE( "Invalid call to set_type_path" );
            }
        }
        , m_data );
}
std::string& set_type_path_str(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::string&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_type_path_str" );
                return part->type_path_str;
            }
            else
            {
                THROW_RTE( "Invalid call to set_type_path_str" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Context > >& set_types(std::variant< data::Ptr< data::Operations::Invocations_Variables_Variable >, data::Ptr< data::Operations::Invocations_Variables_Instance >, data::Ptr< data::Operations::Invocations_Variables_Reference >, data::Ptr< data::Operations::Invocations_Variables_Dimension >, data::Ptr< data::Operations::Invocations_Variables_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Context > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Reference > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_types" );
                return part->types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Dimension > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_types" );
                return part->types;
            }
            else if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Invocations_Variables_Context > >)
            {
                data::Ptr< data::Operations::Invocations_Variables_Reference > part = 
                    data::convert< data::Operations::Invocations_Variables_Reference >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_types" );
                return part->types;
            }
            else
            {
                THROW_RTE( "Invalid call to set_types" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >& set_user_dimensions(std::variant< data::Ptr< data::MemoryLayout::MemoryLayout_Part > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Concrete::Concrete_Dimensions_User > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::MemoryLayout::MemoryLayout_Part > >)
            {
                data::Ptr< data::MemoryLayout::MemoryLayout_Part > part = 
                    data::convert< data::MemoryLayout::MemoryLayout_Part >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_user_dimensions" );
                return part->user_dimensions;
            }
            else
            {
                THROW_RTE( "Invalid call to set_user_dimensions" );
            }
        }
        , m_data );
}
std::optional< std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > > >& set_variables(std::variant< data::Ptr< data::Operations::Operations_Invocation > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::optional< std::vector< data::Ptr< data::Operations::Invocations_Variables_Variable > > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Invocation > >)
            {
                data::Ptr< data::Operations::Operations_Invocation > part = 
                    data::convert< data::Operations::Operations_Invocation >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_variables" );
                return part->variables;
            }
            else
            {
                THROW_RTE( "Invalid call to set_variables" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& set_vectors(std::variant< data::Ptr< data::Operations::Operations_Context > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_ElementVector > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_Context > >)
            {
                data::Ptr< data::Operations::Operations_Context > part = 
                    data::convert< data::Operations::Operations_Context >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_vectors" );
                return part->vectors;
            }
            else
            {
                THROW_RTE( "Invalid call to set_vectors" );
            }
        }
        , m_data );
}
std::vector< data::Ptr< data::Operations::Operations_ElementVector > >& set_vectors(std::variant< data::Ptr< data::Operations::Operations_TypePath > >& m_data)
{
    return std::visit( 
        []( auto& arg ) -> std::vector< data::Ptr< data::Operations::Operations_ElementVector > >&
        {
            using T = std::decay_t< decltype( arg ) >;
            if constexpr( std::is_same_v< T, data::Ptr< data::Operations::Operations_TypePath > >)
            {
                data::Ptr< data::Operations::Operations_TypePath > part = 
                    data::convert< data::Operations::Operations_TypePath >( arg );
                VERIFY_RTE_MSG( part.getObjectInfo().getIndex() != mega::io::ObjectInfo::NO_INDEX,
                    "Invalid data reference in: set_vectors" );
                return part->vectors;
            }
            else
            {
                THROW_RTE( "Invalid call to set_vectors" );
            }
        }
        , m_data );
}

mega::io::Object* Factory::create( ObjectPartLoader& loader, const mega::io::ObjectInfo& objectInfo )
{
    switch( objectInfo.getType() )
    {
        case 0: return new Components::Components_Component( loader, objectInfo );
        case 1: return new AST::Parser_Identifier( loader, objectInfo );
        case 2: return new AST::Parser_ScopedIdentifier( loader, objectInfo );
        case 3: return new AST::Parser_ArgumentList( loader, objectInfo );
        case 4: return new AST::Parser_ReturnType( loader, objectInfo );
        case 5: return new AST::Parser_Inheritance( loader, objectInfo );
        case 6: return new AST::Parser_Size( loader, objectInfo );
        case 7: return new AST::Parser_LinkInterface( loader, objectInfo );
        case 8: return new AST::Parser_Dimension( loader, objectInfo );
        case 9: return new AST::Parser_Include( loader, objectInfo );
        case 10: return new AST::Parser_SystemInclude( loader, objectInfo );
        case 11: return new AST::Parser_MegaInclude( loader, objectInfo );
        case 12: return new AST::Parser_MegaIncludeInline( loader, objectInfo );
        case 13: return new AST::Parser_MegaIncludeNested( loader, objectInfo );
        case 14: return new AST::Parser_CPPInclude( loader, objectInfo );
        case 15: return new AST::Parser_Dependency( loader, objectInfo );
        case 16: return new AST::Parser_ContextDef( loader, objectInfo );
        case 18: return new AST::Parser_NamespaceDef( loader, objectInfo );
        case 19: return new AST::Parser_AbstractDef( loader, objectInfo );
        case 20: return new AST::Parser_ActionDef( loader, objectInfo );
        case 21: return new AST::Parser_EventDef( loader, objectInfo );
        case 22: return new AST::Parser_FunctionDef( loader, objectInfo );
        case 23: return new AST::Parser_ObjectDef( loader, objectInfo );
        case 24: return new AST::Parser_LinkDef( loader, objectInfo );
        case 25: return new AST::Parser_LinkInterfaceDef( loader, objectInfo );
        case 26: return new AST::Parser_BufferDef( loader, objectInfo );
        case 27: return new AST::Parser_MetaDef( loader, objectInfo );
        case 28: return new AST::Parser_SourceRoot( loader, objectInfo );
        case 29: return new AST::Parser_IncludeRoot( loader, objectInfo );
        case 30: return new AST::Parser_ObjectSourceRoot( loader, objectInfo );
        case 17: return new Body::Parser_ContextDef( loader, objectInfo );
        case 31: return new Tree::Interface_DimensionTrait( loader, objectInfo );
        case 35: return new Tree::Interface_InheritanceTrait( loader, objectInfo );
        case 37: return new Tree::Interface_LinkTrait( loader, objectInfo );
        case 38: return new Tree::Interface_ReturnTypeTrait( loader, objectInfo );
        case 40: return new Tree::Interface_ArgumentListTrait( loader, objectInfo );
        case 42: return new Tree::Interface_SizeTrait( loader, objectInfo );
        case 44: return new Tree::Interface_ContextGroup( loader, objectInfo );
        case 45: return new Tree::Interface_Root( loader, objectInfo );
        case 46: return new Tree::Interface_IContext( loader, objectInfo );
        case 49: return new Tree::Interface_Namespace( loader, objectInfo );
        case 50: return new Tree::Interface_Abstract( loader, objectInfo );
        case 51: return new Tree::Interface_Action( loader, objectInfo );
        case 52: return new Tree::Interface_Event( loader, objectInfo );
        case 53: return new Tree::Interface_Function( loader, objectInfo );
        case 54: return new Tree::Interface_Object( loader, objectInfo );
        case 55: return new Tree::Interface_Link( loader, objectInfo );
        case 57: return new Tree::Interface_LinkInterface( loader, objectInfo );
        case 58: return new Tree::Interface_Buffer( loader, objectInfo );
        case 131: return new DPGraph::Dependencies_Glob( loader, objectInfo );
        case 132: return new DPGraph::Dependencies_SourceFileDependencies( loader, objectInfo );
        case 133: return new DPGraph::Dependencies_TransitiveDependencies( loader, objectInfo );
        case 134: return new DPGraph::Dependencies_Analysis( loader, objectInfo );
        case 135: return new SymbolTable::Symbols_Symbol( loader, objectInfo );
        case 137: return new SymbolTable::Symbols_SymbolSet( loader, objectInfo );
        case 139: return new SymbolTable::Symbols_SymbolTable( loader, objectInfo );
        case 32: return new PerSourceSymbols::Interface_DimensionTrait( loader, objectInfo );
        case 47: return new PerSourceSymbols::Interface_IContext( loader, objectInfo );
        case 34: return new Clang::Interface_DimensionTrait( loader, objectInfo );
        case 36: return new Clang::Interface_InheritanceTrait( loader, objectInfo );
        case 39: return new Clang::Interface_ReturnTypeTrait( loader, objectInfo );
        case 41: return new Clang::Interface_ArgumentListTrait( loader, objectInfo );
        case 43: return new Clang::Interface_SizeTrait( loader, objectInfo );
        case 96: return new Concrete::Concrete_Dimensions_User( loader, objectInfo );
        case 103: return new Concrete::Concrete_ContextGroup( loader, objectInfo );
        case 104: return new Concrete::Concrete_Context( loader, objectInfo );
        case 107: return new Concrete::Concrete_Namespace( loader, objectInfo );
        case 108: return new Concrete::Concrete_Action( loader, objectInfo );
        case 110: return new Concrete::Concrete_Event( loader, objectInfo );
        case 112: return new Concrete::Concrete_Function( loader, objectInfo );
        case 113: return new Concrete::Concrete_Object( loader, objectInfo );
        case 115: return new Concrete::Concrete_Link( loader, objectInfo );
        case 117: return new Concrete::Concrete_Buffer( loader, objectInfo );
        case 119: return new Concrete::Concrete_Root( loader, objectInfo );
        case 136: return new ConcreteTable::Symbols_ConcreteSymbol( loader, objectInfo );
        case 138: return new ConcreteTable::Symbols_SymbolSet( loader, objectInfo );
        case 140: return new ConcreteTable::Symbols_SymbolTable( loader, objectInfo );
        case 105: return new PerSourceConcreteTable::Concrete_Context( loader, objectInfo );
        case 141: return new Derivations::Derivation_ObjectMapping( loader, objectInfo );
        case 142: return new Derivations::Derivation_Mapping( loader, objectInfo );
        case 33: return new PerSourceDerivations::Interface_DimensionTrait( loader, objectInfo );
        case 48: return new PerSourceDerivations::Interface_IContext( loader, objectInfo );
        case 143: return new Model::HyperGraph_Relation( loader, objectInfo );
        case 144: return new Model::HyperGraph_Relations( loader, objectInfo );
        case 145: return new Model::HyperGraph_Graph( loader, objectInfo );
        case 56: return new PerSourceModel::Interface_Link( loader, objectInfo );
        case 97: return new MemoryLayout::Concrete_Dimensions_User( loader, objectInfo );
        case 98: return new MemoryLayout::Concrete_Dimensions_LinkReference( loader, objectInfo );
        case 99: return new MemoryLayout::Concrete_Dimensions_LinkSingle( loader, objectInfo );
        case 100: return new MemoryLayout::Concrete_Dimensions_LinkMany( loader, objectInfo );
        case 101: return new MemoryLayout::Concrete_Dimensions_Allocation( loader, objectInfo );
        case 102: return new MemoryLayout::Concrete_Dimensions_Allocator( loader, objectInfo );
        case 106: return new MemoryLayout::Concrete_Context( loader, objectInfo );
        case 109: return new MemoryLayout::Concrete_Action( loader, objectInfo );
        case 111: return new MemoryLayout::Concrete_Event( loader, objectInfo );
        case 114: return new MemoryLayout::Concrete_Object( loader, objectInfo );
        case 116: return new MemoryLayout::Concrete_Link( loader, objectInfo );
        case 118: return new MemoryLayout::Concrete_Buffer( loader, objectInfo );
        case 146: return new MemoryLayout::Allocators_Allocator( loader, objectInfo );
        case 147: return new MemoryLayout::Allocators_Nothing( loader, objectInfo );
        case 148: return new MemoryLayout::Allocators_Singleton( loader, objectInfo );
        case 149: return new MemoryLayout::Allocators_Range( loader, objectInfo );
        case 150: return new MemoryLayout::Allocators_Range32( loader, objectInfo );
        case 151: return new MemoryLayout::Allocators_Range64( loader, objectInfo );
        case 152: return new MemoryLayout::Allocators_RangeAny( loader, objectInfo );
        case 153: return new MemoryLayout::MemoryLayout_Part( loader, objectInfo );
        case 154: return new MemoryLayout::MemoryLayout_Buffer( loader, objectInfo );
        case 155: return new MemoryLayout::MemoryLayout_NonSimpleBuffer( loader, objectInfo );
        case 156: return new MemoryLayout::MemoryLayout_SimpleBuffer( loader, objectInfo );
        case 157: return new MemoryLayout::MemoryLayout_GPUBuffer( loader, objectInfo );
        case 59: return new Operations::Invocations_Variables_Variable( loader, objectInfo );
        case 60: return new Operations::Invocations_Variables_Instance( loader, objectInfo );
        case 61: return new Operations::Invocations_Variables_Reference( loader, objectInfo );
        case 62: return new Operations::Invocations_Variables_Dimension( loader, objectInfo );
        case 63: return new Operations::Invocations_Variables_Context( loader, objectInfo );
        case 64: return new Operations::Invocations_Instructions_Instruction( loader, objectInfo );
        case 65: return new Operations::Invocations_Instructions_InstructionGroup( loader, objectInfo );
        case 66: return new Operations::Invocations_Instructions_Root( loader, objectInfo );
        case 67: return new Operations::Invocations_Instructions_ParentDerivation( loader, objectInfo );
        case 68: return new Operations::Invocations_Instructions_ChildDerivation( loader, objectInfo );
        case 69: return new Operations::Invocations_Instructions_EnumDerivation( loader, objectInfo );
        case 70: return new Operations::Invocations_Instructions_Enumeration( loader, objectInfo );
        case 71: return new Operations::Invocations_Instructions_DimensionReferenceRead( loader, objectInfo );
        case 72: return new Operations::Invocations_Instructions_MonoReference( loader, objectInfo );
        case 73: return new Operations::Invocations_Instructions_PolyReference( loader, objectInfo );
        case 74: return new Operations::Invocations_Instructions_PolyCase( loader, objectInfo );
        case 75: return new Operations::Invocations_Instructions_Failure( loader, objectInfo );
        case 76: return new Operations::Invocations_Instructions_Elimination( loader, objectInfo );
        case 77: return new Operations::Invocations_Instructions_Prune( loader, objectInfo );
        case 78: return new Operations::Invocations_Operations_Operation( loader, objectInfo );
        case 79: return new Operations::Invocations_Operations_BasicOperation( loader, objectInfo );
        case 80: return new Operations::Invocations_Operations_DimensionOperation( loader, objectInfo );
        case 81: return new Operations::Invocations_Operations_Allocate( loader, objectInfo );
        case 82: return new Operations::Invocations_Operations_Call( loader, objectInfo );
        case 83: return new Operations::Invocations_Operations_Start( loader, objectInfo );
        case 84: return new Operations::Invocations_Operations_Stop( loader, objectInfo );
        case 85: return new Operations::Invocations_Operations_Pause( loader, objectInfo );
        case 86: return new Operations::Invocations_Operations_Resume( loader, objectInfo );
        case 87: return new Operations::Invocations_Operations_Done( loader, objectInfo );
        case 88: return new Operations::Invocations_Operations_WaitAction( loader, objectInfo );
        case 89: return new Operations::Invocations_Operations_WaitDimension( loader, objectInfo );
        case 90: return new Operations::Invocations_Operations_GetAction( loader, objectInfo );
        case 91: return new Operations::Invocations_Operations_GetDimension( loader, objectInfo );
        case 92: return new Operations::Invocations_Operations_Read( loader, objectInfo );
        case 93: return new Operations::Invocations_Operations_Write( loader, objectInfo );
        case 94: return new Operations::Invocations_Operations_WriteLink( loader, objectInfo );
        case 95: return new Operations::Invocations_Operations_Range( loader, objectInfo );
        case 120: return new Operations::Operations_InterfaceVariant( loader, objectInfo );
        case 121: return new Operations::Operations_ConcreteVariant( loader, objectInfo );
        case 122: return new Operations::Operations_Element( loader, objectInfo );
        case 123: return new Operations::Operations_ElementVector( loader, objectInfo );
        case 124: return new Operations::Operations_Context( loader, objectInfo );
        case 125: return new Operations::Operations_TypePath( loader, objectInfo );
        case 126: return new Operations::Operations_NameRoot( loader, objectInfo );
        case 127: return new Operations::Operations_Name( loader, objectInfo );
        case 128: return new Operations::Operations_NameResolution( loader, objectInfo );
        case 129: return new Operations::Operations_Invocation( loader, objectInfo );
        case 130: return new Operations::Operations_Invocations( loader, objectInfo );
        default:
            THROW_RTE( "Unrecognised object type ID" );
    }
}

}
