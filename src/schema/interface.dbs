//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.

namespace Interface
{
    // context traits
    /*
    object DimensionTrait -> InterfaceStage::Tree
    {
        ref< IContext > parent;
        
        array< ref< Concrete::Dimensions::User > > concrete -> InheritanceAnalysisRollout::PerSourceDerivations;

        // value< std::string >                    canonical_type  -> InterfaceAnalysisStage::Clang;
        // value< std::string >                    mangled_name    -> InterfaceAnalysisStage::Clang;
        // ref< MegaMangle::Mangle >               mangle          -> InterfaceAnalysisStage::Clang;
        // value< std::string >                    erased_type     -> InterfaceAnalysisStage::Clang;
        // value< mega::U64 >                      size            -> InterfaceAnalysisStage::Clang;
        // value< mega::U64 >                      alignment       -> InterfaceAnalysisStage::Clang;
        // value< bool >                           simple          -> InterfaceAnalysisStage::Clang;
        // array< ref< Symbols::SymbolTypeID > >   symbols         -> InterfaceAnalysisStage::Clang;
    }

    object UserDimensionTrait : DimensionTrait -> InterfaceStage::Tree
    {
        ref< Parser::Dimension > parser_dimension;
    }

    object CompilerDimensionTrait : DimensionTrait -> InterfaceStage::Tree
    {
        value< std::string > identifier;
    }

    object LinkTrait -> InterfaceStage::Tree
    {
        ref< IContext > parent;

        array< ref< Concrete::Dimensions::Link > > concrete -> InheritanceAnalysisRollout::PerSourceDerivations;

        ref< HyperGraph::Relation > relation -> HyperGraphAnalysisRollout::PerSourceModel;
    }

    object UserLinkTrait : LinkTrait  -> InterfaceStage::Tree
    {
        ref< Parser::Link > parser_link;
        // array< ref< SymbolVariantSequence > > symbol_variant_sequences -> InterfaceAnalysisStage::Clang;
    }

    object OwnershipLinkTrait : LinkTrait  -> InterfaceStage::Tree
    {
    }

    object InheritanceTrait : Parser::TypeDecl::Inheritance -> InterfaceStage::Tree
    {
        // array< ref< IContext > > contexts -> InterfaceAnalysisStage::Clang;
    }

    object ReturnTypeTrait : Parser::TypeDecl::Return -> InterfaceStage::Tree
    {
        // value< std::string > canonical_type  -> InterfaceAnalysisStage::Clang;
    }

    object ArgumentListTrait : Parser::TypeDecl::Arguments -> InterfaceStage::Tree
    {
        // array< value< std::string > > canonical_types -> InterfaceAnalysisStage::Clang;
    }

    object EventTypeTrait : Parser::TypeDecl::Events -> InterfaceStage::Tree
    {
        ref< InvocationContext > parent_invocation_context;

        // each argument may be a variant of type paths
        // array< ref< SymbolVariantSequence > > symbol_variant_sequences -> InterfaceAnalysisStage::Clang;
    }

    object TransitionTypeTrait : Parser::TypeDecl::Transitions -> InterfaceStage::Tree
    {
        ref< InvocationContext > parent_invocation_context;
        
        array< ref< SymbolVariantSequence > > symbol_variant_sequences -> InterfaceAnalysisStage::Clang;
    }

    object PartTrait : Parser::Part -> InterfaceStage::Tree
    {
        ref< IContext > parent;
    }

    object SizeTrait : Parser::Size -> InterfaceStage::Tree
    {
        // value< mega::U64 > size -> InterfaceAnalysisStage::Clang;
    }
    */

    // object InvocationInstance -> OperationsLocs::Locations
    // {
    //     // ref< Operations::Invocation > invocation;
    //     // value< mega::SourceLocation > source_location;
    // }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    // Tree Nodes
    object NodeGroup -> InterfaceStage::Tree
    {
        array< ref< Node > > children;
    }

    object Root : NodeGroup -> InterfaceStage::Tree
    {
    }

    object Node : NodeGroup -> InterfaceStage::Tree
    {
        ref< Parser::Symbol >                   symbol;
        ref< NodeGroup >                        parent;
        opt< ref< Components::Component > >     component_opt;
        late< value< std::string > >            kind;

        ref< Symbols::InterfaceTypeID > interface_id -> SymbolAnalysis::SymbolTable;

        array< ref< Concrete::Node > >  inheritors -> ConcreteStage::Concrete;
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    // Aggregates
    object Aggregate : Node -> InterfaceStage::Tree
    {
    }

    object ParsedAggregate : Aggregate -> InterfaceStage::Tree
    {
        ref< Parser::Aggregate > aggregate;
    }

    object UserDimension : ParsedAggregate -> InterfaceStage::Tree
    {
        ref< Parser::Dimension > dimension;
    }

    object UserAlias : ParsedAggregate -> InterfaceStage::Tree
    {
        ref< Parser::Alias > alias;
    }

    object UserUsing : ParsedAggregate -> InterfaceStage::Tree
    {
        ref< Parser::Using > cpp_using;
    }

    object UserLink : ParsedAggregate -> InterfaceStage::Tree
    {
        ref< Parser::Link > link;

        ref< Node > type -> HyperGraphAnalysis::Model;
    }

    object NonOwningLink : UserLink -> HyperGraphAnalysis::Model
    {
        late< ref< NonOwningLink > > counterpart;
    }

    object OwningLink : UserLink -> HyperGraphAnalysis::Model
    {
        ref< OwnershipLink > owned;
    }

    object GeneratedAggregate : Aggregate -> InterfaceStage::Tree
    {
    }

    object OwnershipLink : GeneratedAggregate -> InterfaceStage::Tree
    {
        array< ref< OwningLink > > owners -> HyperGraphAnalysis::Model;
    }

    object ActivationBitSet : GeneratedAggregate -> InterfaceStage::Tree
    {
    }

    ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////
    // Contexts
    object IContext : Node -> InterfaceStage::Tree
    {
        array< ref< Parser::Container > >   containers;

        late< opt< ref< Parser::TypeDecl::Inheritance > > > inheritance_opt;
        late< opt< ref< Parser::Size > > >                  size_opt;
        late< value< mega::U64 > >                          size;
        late< value< bool > >                               singular;

        value< mega::IContextFlags > flags -> ConcreteStage::Concrete;
    }

    object Namespace : IContext -> InterfaceStage::Tree
    {
        value< bool > is_global;
    }

    object Abstract : IContext -> InterfaceStage::Tree
    {
    }

    object Event : IContext -> InterfaceStage::Tree
    {
    }

    object Object : IContext -> InterfaceStage::Tree
    {
        late< ref< OwnershipLink > >    ownership_link;
        late< ref< ActivationBitSet > > activation_bitset;
    }

    object InvocationContext : IContext -> InterfaceStage::Tree
    {
        // array< ref< InvocationInstance > >          invocation_instances    -> OperationsLocs::Locations;
        // value< mega::SourceLocation > source_location -> OperationsLocs::Locations;
        late< opt< ref< Parser::TypeDecl::Body > > > body_opt;
    }

    object Interupt : InvocationContext -> InterfaceStage::Tree
    {
        late< opt< ref< Parser::TypeDecl::Events > > >      events_opt;
        late< opt< ref< Parser::TypeDecl::Transitions > > > transition_opt;
    }

    object Requirement : InvocationContext -> InterfaceStage::Tree
    {
        late< ref< Parser::TypeDecl::Events > >         events;
        late< ref< Parser::TypeDecl::Transitions > >    transition;
    }

    object Decider : InvocationContext -> InterfaceStage::Tree
    {
        late< ref< Parser::TypeDecl::Events > > events;
    }

    object Function : InvocationContext -> InterfaceStage::Tree
    {
        late< ref< Parser::TypeDecl::Return > >         return_type;
        late< ref< Parser::TypeDecl::Arguments > >      arguments;
    }

    object State : InvocationContext -> InterfaceStage::Tree
    {
        late< opt< ref< Parser::TypeDecl::Transitions > > > transition_opt;
        late< array< ref< Parser::Part > > >                parts;
    }

    object Action : State -> InterfaceStage::Tree
    {
    }

    object Component : State -> InterfaceStage::Tree
    {
    }
}
