#ifndef {{ guard }}
#define {{ guard }}

#include "database/io/environment.hpp"

#include <boost/filesystem/path.hpp>

#include <string>
#include <vector>
#include <optional>
#include <memory>
#include <variant>

namespace {{ stage.name }}
{
    // forward declarations
{% for interface in stage.interfaces %}
{% for namespace in interface.namespaces %}
    namespace {{ namespace }}
    { 
{% endfor %}{#interface.namespaces#}
        class {{ interface.name }};
{% for namespace in interface.namespaces %}
    } //{{ namespace }}
{% endfor %}{#interface.namespaces#}
{% endfor %}{# stage.interfaces #}
    
    // Definitions

{% for interface in stage.interfaces %}
{% for namespace in interface.namespaces %}
    namespace {{ namespace }}
    { 
{% endfor %}{#interface.namespaces#}
        class {{ interface.name }}{% if interface.has_base %} : public virtual {{ interface.base }}{% endif %}

        {
        protected:
            {{ interface.name }}();
            {{ interface.name }}( const {{ interface.name }}& ) = delete;
            {{ interface.name }}& operator=( const {{ interface.name }}& ) = delete;
            virtual ~{{ interface.name }}() = 0;
        public:
{% if interface.readwrite %}
            struct Args
            {
{% for ctor in interface.args_ctors %}
                Args({% for param in ctor.params %}{{ param.type }} {{ param.name }}{% if not loop.is_last %}, {% endif %}{% endfor %})
{% for param in ctor.params %}
                    {% if loop.is_first %}:{% else %},{% endif %} {{ param.value }}( {{ param.name }} )
{% endfor %}{# ctor.params #}
                {
                }
{% endfor %}{# interface.ctors #}
{% for value in interface.args_values %}
                {{ value.type }} {{ value.name }};
{% endfor %}{# interface.values #}
            };
{% endif %}

{% for function in interface.functions %}
            virtual {{ function.returntype }} {{ function.name }}({{ function.params }}) = 0;
{% endfor %}{#interface.functions#}
        };
{% for namespace in interface.namespaces %}
    } //{{ namespace }}
{% endfor %}{#interface.namespaces#}
{% endfor %}{# stage.interfaces #}

    class Database
    {
    public:
        struct Pimpl;
{% if not stage.perobject %}
        Database( const mega::io::Environment& environment );
{% endif %}
{% if stage.perobject %}
        Database( const mega::io::Environment& environment, const boost::filesystem::path& objectFile );
{% endif %}
        template< typename T >
        inline std::vector< T* > many() const;

        template< typename T >
        inline T* one() const;

        template< typename T >
        inline T* oneOpt() const;

        template< typename T >
        inline T* construct( const typename T::Args& arguments );

        void store();

    private:
{% for many_accessor in stage.many_accessors %}
        std::vector< {{ many_accessor.type }}* > many_{{ many_accessor.longname }}() const;
{% endfor %}{# stage.accessors #}
{% for one_accessor in stage.one_accessors %}
        {{ one_accessor.type }}* one_{{ one_accessor.longname }}() const;
{% endfor %}{# stage.accessors #}
{% for one_opt_accessor in stage.one_opt_accessors %}
        {{ one_opt_accessor.type }}* > oneOpt_{{ one_opt_accessor.longname }}() const;
{% endfor %}{# stage.accessors #}
{% for constructor in stage.constructors %}
        {{ constructor.return_type }}* {{ constructor.function_name }}( const {{ constructor.return_type }}::Args& arguments );
{% endfor %}{# stage.constructors #}

    private:
        std::shared_ptr< Pimpl > m_pimpl;
    };

{% for constructor in stage.constructors %}
    template<>
    inline {{ constructor.return_type }}* Database::construct< {{ constructor.return_type }} >( const {{ constructor.return_type }}::Args& arguments )
    {
        return {{ constructor.function_name }}( arguments );
    }
{% endfor %}{# stage.constructors #}
{% for many_accessor in stage.many_accessors %}
    template<>
    inline std::vector< {{ many_accessor.type }}* > Database::many< {{ many_accessor.type }} >() const
    {
        return many_{{ many_accessor.longname }}();
    }
{% endfor %}{# stage.accessors #}
{% for one_accessor in stage.one_accessors %}
    template<>
    inline {{ one_accessor.type }}* Database::one< {{ one_accessor.type }} >() const
    {
        return one_{{ one_accessor.longname }}();
    }
{% endfor %}{# stage.accessors #}
{% for one_opt_accessor in stage.one_opt_accessors %}
    template<>
    inline {{ one_opt_accessor.type }}* > Database::oneOpt< {{ one_opt_accessor.type }} >() const
    {
        return oneOpt_{{ one_opt_accessor.longname }}();
    }
{% endfor %}{# stage.accessors #}
}

#endif //{{ guard }}
