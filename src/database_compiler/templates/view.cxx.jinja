
#include "database/model/{{ stage.name }}.hxx"

#include "database/io/object_info.hpp"
#include "database/io/file_info.hpp"
#include "database/io/file.hpp"
#include "database/io/manifest.hpp"
#include "database/io/data_pointer.hpp"

#include "database/model/data.hxx"

#include "common/hash.hpp"

#include <variant>
#include <memory>
#include <unordered_map>

namespace {{ stage.name }}
{
{% for interface in stage.interfaces %}
{% for namespace in interface.namespaces %}
    namespace {{ namespace }}
    { 
{% endfor %}{#interface.namespaces#}
        {{ interface.name }}::{{ interface.name }}(){}
        {{ interface.name }}::~{{ interface.name }}(){}
{% for namespace in interface.namespaces %}
    } //{{ namespace }}
{% endfor %}{#interface.namespaces#}
{% endfor %}{# stage.interfaces #}

class SuperTypeBase
{
public:
    virtual ~SuperTypeBase(){}
};

{% for stype in stage.supertypes %}
class {{ stype.name }} : public SuperTypeBase,
{% for interface in stype.interfaces %}
    public virtual {{ interface.name }}{% if not loop.is_last %}, 
{% endif %}
{% endfor %}

{
public:
    using DataVariant = std::variant
    < 
{% for interface in stype.interfaces %} 
        data::Ptr< data::{{ interface.part }} > {% if not loop.is_last %}, 
{% endif %}
{% endfor %} 

    >;
    DataVariant m_data;
{% for interface in stype.interfaces %}
    {{ stype.name }}( data::Ptr< data::{{ interface.part }} >& data )
        :   m_data( data )
    {
    }
    void reconstruct( data::Ptr< data::{{ interface.part }} >& data )
    {
        m_data = data;
    }
{% endfor %}{# stype.interfaces #}
    virtual ~{{ stype.name }}()
    {
    }
{% for interface in stype.interfaces %}
    // {{ interface.name }}
{% for function in interface.functions %}
    virtual {{ function.returntype }} {{ function.name }}({{function.params }})
    {
        data::Ptr< data::{{ function.objectpart }} > part = 
            data::convert< data::{{ function.objectpart }} >( m_data );
{% for line in function.body %}
        {{ line }}
{% endfor %}{# function.body #}
    }
{% endfor %}{# interface.functions #}
{% endfor %}{# stype.interfaces #}
};

{% endfor %}{# stage.supertypes #}

struct Database::Pimpl : public data::ObjectPartLoader
{
    using SuperTypePtr = std::unique_ptr< SuperTypeBase >;
    struct ObjectInfoHash
    {
        std::size_t operator()( const mega::io::ObjectInfo& objectInfo ) const
        {
            static auto hashgenerator =  std::hash<std::int32_t>{};
            return common::hash_combine( {
                hashgenerator(objectInfo.getType()),
                hashgenerator(objectInfo.getFileID()),
                hashgenerator(objectInfo.getIndex()) } );
        }
    };
    struct ObjectInfoEquality
    {
        std::size_t operator()( const mega::io::ObjectInfo& left, const mega::io::ObjectInfo& right ) const
        {
            return  left.getType()      == right.getType() &&
                    left.getFileID()    == right.getFileID() &&
                    left.getIndex()     == right.getIndex() ;
        }
    };
    using InterfaceMap = std::unordered_map< mega::io::ObjectInfo, SuperTypePtr, ObjectInfoHash, ObjectInfoEquality >;
    using FileMap = std::map< mega::io::ObjectInfo::FileID, mega::io::File::Ptr >;
    using FileMapCst = std::map< mega::io::ObjectInfo::FileID, mega::io::File::PtrCst >;
{% if stage.perobject %}
    Pimpl( const mega::io::Environment& environment, const boost::filesystem::path& objectFile )
        :   m_environment( environment ),
            m_objectFile( objectFile ),
            m_manifest( m_environment.project_manifest() )
    {
        create();
    }
{% endif %}
{% if not stage.perobject %}
    Pimpl( const mega::io::Environment& environment )
        :   m_environment( environment ),
            m_manifest( m_environment.project_manifest() )
    {
        create();
    }
{% endif %}

{% for many_accessor in stage.many_accessors %}
    std::vector< {{ many_accessor.type }}* > many_{{ many_accessor.longname }}() const
    {
        std::vector< {{ many_accessor.type }}* > result;
        {
            std::vector< mega::io::FileInfo > fileInfos;
            m_manifest.getCompilationFileInfos( 
                mega::io::FileInfo::FILE_{{ many_accessor.stage }}_{{ many_accessor.file }}{% if stage.perobject %}, m_objectFile{% endif %}, fileInfos );
            for( const mega::io::FileInfo& fileInfo : fileInfos )
            {
                mega::io::File::PtrCst pFile;
                {
                    FileMap::const_iterator iFind = m_readwriteFiles.find( fileInfo.getFileID() );
                    if( iFind == m_readwriteFiles.end() )
                    {
                        pFile = iFind->second;
                    }
                    else
                    {
                        FileMapCst::const_iterator iFind = m_readonlyFiles.find( fileInfo.getFileID() );
                        if( iFind == m_readonlyFiles.end() )
                        {
                            pFile = iFind->second;
                        }
                        else
                        {
                            pFile = std::make_shared< mega::io::File >( fileInfo, const_cast< Database::Pimpl&>(*this) );
                            m_readonlyFiles.insert( std::make_pair( fileInfo.getFileID(), pFile ) );
                        }
                    }
                }
                for( mega::io::Object* pObject : pFile->range() )
                {
                    if( data::{{ many_accessor.file }}::{{ many_accessor.object }}* pFound = 
                        dynamic_cast< data::{{ many_accessor.file }}::{{ many_accessor.object }}* >( pObject ) )
                    {
                        InterfaceMap::const_iterator iFind = m_interfaceHash.find( pFound->getObjectInfo() );
                        if( iFind != m_interfaceHash.end() )
                        {
                            {{ many_accessor.type }}* pResult = dynamic_cast< {{ many_accessor.type }}* >( iFind->second.get() );
                            VERIFY_RTE( pResult );
                            result.push_back( pResult );
                        }
                        else
                        {
                            using SuperType = {{ many_accessor.supertype }};
                            data::Ptr< data::{{ many_accessor.file }}::{{ many_accessor.object }} > pDataPtr( const_cast< Database::Pimpl&>(*this), pFound );
                            SuperType* pSuper = new SuperType( pDataPtr );
                            m_interfaceHash[ pFound->getObjectInfo() ] = SuperTypePtr( pSuper );
                            result.push_back( pSuper );
                        }
                    }
                }
            }
        }
        return result;
    }
{% endfor %}{# stage.accessors #}
{% for one_accessor in stage.one_accessors %}
    {{ one_accessor.type }}* one_{{ one_accessor.longname }}() const
    {
        std::vector< {{ one_accessor.type }}* > result = many_{{ one_accessor.longname }}();
        VERIFY_RTE_MSG( result.empty(), "Singular accessor for {{ one_accessor.type }} found none" );
        VERIFY_RTE_MSG( result.size() == 1U, "Singular accessor for {{ one_accessor.type }} found many" );
        return result.back();
    }
{% endfor %}{# stage.accessors #}
{% for one_opt_accessor in stage.one_opt_accessors %}
    {{ one_opt_accessor.type }}* > oneOpt_{{ one_opt_accessor.longname }}() const
    {
        std::vector< {{ one_opt_accessor.type }}* > result = many_{{ one_opt_accessor.longname }}();
        VERIFY_RTE_MSG( result.size() > 1U, "Singular accessor for {{ one_accessor.type }} found many" );
        if( !result.empty() )
            return result.back();
        else
            return nullptr;
    }
{% endfor %}{# stage.accessors #}

{% for constructor in stage.constructors %}
    {{ constructor.return_type }}* {{ constructor.function_name }}( const {{ constructor.return_type }}::Args& arguments )
    {
        using SuperType = {{ constructor.super_type_name }};
        SuperType* pSuper = nullptr;
        Database::Pimpl& database = *this;

{% for base in constructor.bases %}
{% if not loop.is_first %}
        struct Visitor
        {
            Database::Pimpl& database;
            SuperType*& pSuper;
            Visitor( Database::Pimpl& database, SuperType*& pSuper )
                :   database( database ),
                    pSuper( pSuper )
            {}

            data::Ptr< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} > operator()( {{ base.typename }}* pExisting ) const
            {
                pSuper = dynamic_cast< SuperType* >( pExisting );
                VERIFY_RTE( pSuper );
                return data::convert< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} >( pSuper->m_data );
            }
{% if base.owns_primary_part %}
            data::Ptr< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} > operator()( const {{ base.typename }}::Args& arguments ) const
            {
{% endif %}{# base.owns_primary_part #}
{% endif %}
{% if base.owns_primary_part %}
        // primary part: {{ base.typename }}
        data::Ptr< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} > pPrimaryObjectPart =
            database.m_pFile_{{ base.primary_part.file }}->construct< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} >
                ({% for arg in base.primary_part.args %}arguments.{{ arg.name }}.value(){% if not loop.is_last %}, {% endif %}{% endfor %});

{% for secondary_part in base.parts %}
        // secondary part: {{ secondary_part.file }} :: {{ secondary_part.object }}
        pPrimaryObjectPart->p_{{ secondary_part.file }}_{{ secondary_part.object }} =
            database.m_pFile_{{ secondary_part.file }}->construct< data::{{ secondary_part.file }}::{{ secondary_part.object }} >
                ({% for arg in secondary_part.args %}arguments.{{ arg.name }}.value(){% if not loop.is_last %}, {% endif %}{% endfor %});

{% endfor %}{# base.parts #}
{% endif %}{# base.owns_primary_part #}
{% endfor %}{# constructor.bases #}
{% for base in constructor.bases_reverse%}
{% if not loop.is_last %}
{% if base.owns_primary_part %}
                return pPrimaryObjectPart;
            }
{% endif %}{# base.owns_primary_part #}
        } visitor( database, pSuper );

        pPrimaryObjectPart->p_{{ base.primary_part.file }}_{{ base.primary_part.object }} =
            std::visit( visitor, arguments.base.value() );
{% endif %}
{% endfor %}{# constructor.bases #}
        if( pSuper == nullptr )
        {
            pSuper = new SuperType( pPrimaryObjectPart );
            m_interfaceHash[ pPrimaryObjectPart.getObjectInfo() ] = SuperTypePtr( pSuper );
        }
        else
        {
            pSuper->reconstruct( pPrimaryObjectPart );
        }
        return dynamic_cast< {{ constructor.return_type }}* >( pSuper );
    }
{% endfor %}{# stage.constructors#}

    void create()
    {
        // create read-write files
{% for file in stage.readwrite_files %}
        {
            std::vector< mega::io::FileInfo > fileInfos;
            m_manifest.getCompilationFileInfos( mega::io::FileInfo::FILE_{{ stage.name }}_{{ file.name }}{% if stage.perobject %}, m_objectFile{% endif %}, fileInfos );
            VERIFY_RTE( fileInfos.size() == 1U );
            const mega::io::FileInfo& fileInfo = fileInfos.front();
            m_pFile_{{ file.name }} = std::make_shared< mega::io::File >( fileInfo, *this ) ;
            m_readwriteFiles.insert( std::make_pair( fileInfo.getFileID(), m_pFile_{{ file.name }} ) ); 
        }
{% endfor %}{# stage.readwrite_files #}
    }

    void store()
    {
        for ( FileMap::const_iterator 
                i = m_readwriteFiles.begin(), 
                iEnd = m_readwriteFiles.end();
              i != iEnd; ++i )
        {
            i->second->store( m_manifest );
        }
    }

    virtual mega::io::Object* load( const mega::io::ObjectInfo& objectInfo )
    {
        FileMapCst::const_iterator iFind = m_readonlyFiles.find( objectInfo.getFileID() );
        if( iFind != m_readonlyFiles.end() )
        {
            return iFind->second->getObject( objectInfo.getIndex() );
        }

        // load the file
        const mega::io::FileInfo fileInfo =
            m_manifest.getCompilationFilePath( objectInfo.getFileID() );

        mega::io::File::Ptr pFile = 
            std::make_shared< mega::io::File >( fileInfo, *this );
        
        m_readonlyFiles.insert( std::make_pair( objectInfo.getFileID(), pFile ) );

        return pFile->getObject( objectInfo.getIndex() );
    }

    const mega::io::Environment& m_environment;
{% if stage.perobject %}
    boost::filesystem::path m_objectFile;
{% endif %}
    const mega::io::Manifest m_manifest;

    FileMap m_readwriteFiles;
    mutable FileMapCst m_readonlyFiles;
    mutable InterfaceMap m_interfaceHash;

{% for file in stage.readwrite_files %}
    std::shared_ptr< mega::io::File > m_pFile_{{ file.name }};
{% endfor %}
};


{% if not stage.perobject %}
Database::Database( const mega::io::Environment& environment )
:   m_pimpl( new Pimpl( environment ) )
{
}
{% endif %}
{% if stage.perobject %}
Database::Database( const mega::io::Environment& environment, const boost::filesystem::path& objectFile )
:   m_pimpl( new Pimpl( environment, objectFile ) )
{
}
{% endif %}

void Database::store()
{
    m_pimpl->store();
}

{% for many_accessor in stage.many_accessors %}
std::vector< {{ many_accessor.type }}* > Database::many_{{ many_accessor.longname }}() const
{
    return m_pimpl->many_{{ many_accessor.longname }}();
}
{% endfor %}{# stage.accessors #}
{% for one_accessor in stage.one_accessors %}
{{ one_accessor.type }}* Database::one_{{ one_accessor.longname }}() const
{
    return m_pimpl->one_{{ one_accessor.longname }}();
}
{% endfor %}{# stage.accessors #}
{% for one_opt_accessor in stage.one_opt_accessors %}
{{ one_opt_accessor.type }}* > Database::oneOpt_{{ one_opt_accessor.longname }}() const
{
    return m_pimpl->oneOpt_{{ one_opt_accessor.longname }}();
}
{% endfor %}{# stage.accessors #}
{% for constructor in stage.constructors %}
{{ constructor.return_type }}* Database::{{ constructor.function_name }}( const {{ constructor.return_type }}::Args& arguments )
{
    return m_pimpl->{{ constructor.function_name }}( arguments );
}
{% endfor %}{# stage.constructors #}

}