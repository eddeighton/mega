
#include "database/model/{{ stage.name }}.hxx"

#include "database/io/object_info.hpp"
#include "database/io/file_info.hpp"
#include "database/io/file.hpp"
#include "database/io/manifest.hpp"
#include "database/io/data_pointer.hpp"

#include "database/model/data.hxx"

#include "common/hash.hpp"

#include <variant>
#include <memory>
#include <unordered_map>

namespace {{ stage.name }}
{
{% for interface in stage.interfaces %}
{% for namespace in interface.namespaces %}
    namespace {{ namespace }}
    { 
{% endfor %}{#interface.namespaces#}
        {{ interface.name }}::{{ interface.name }}(){}
        {{ interface.name }}::~{{ interface.name }}(){}
{% for namespace in interface.namespaces %}
    } //{{ namespace }}
{% endfor %}{#interface.namespaces#}
{% endfor %}{# stage.interfaces #}

class SuperTypeBase
{
public:
    virtual ~SuperTypeBase(){}
};
{% for stype in stage.supertypes %}
class {{ stype.name }};
{% endfor %}

struct PointerConverter
{
{% for object_part in stage.super_conversions %}
    virtual {{ object_part.supertype }}* toSuper( const data::Ptr< data::{{ object_part.file }}::{{ object_part.object }} >& pData ) const = 0;
    virtual data::Ptr< data::{{ object_part.file }}::{{ object_part.object }} > toData_{{ object_part.file }}_{{ object_part.object }}( {{ object_part.supertype }}* pSuper ) const = 0;
{% endfor %}{# stage.super_conversions #}
{% for interface_conversion in stage.interface_conversions %}
    virtual {{ interface_conversion.type }}* toInterface( const data::Ptr< data::{{ interface_conversion.file }}::{{ interface_conversion.object }} >& pData ) const = 0;
    virtual data::Ptr< data::{{ interface_conversion.file }}::{{ interface_conversion.object }} > toData( {{ interface_conversion.type }}* pInterface ) const = 0;
{% endfor %}{# stage.interface_conversions #}
};

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Super type declarations
{% for stype in stage.supertypes %}
class {{ stype.name }} : public SuperTypeBase,
{% for interface in stype.interfaces %}
    public virtual {{ interface.name }}{% if not loop.is_last %}, 
{% endif %}
{% endfor %}

{
    PointerConverter& m_converter;
public:
    using DataVariant = std::variant
    < 
{% for interface in stype.interfaces %} 
        data::Ptr< data::{{ interface.part }} > {% if not loop.is_last %}, 
{% endif %}
{% endfor %} 

    >;
    DataVariant m_data;
{% for interface in stype.interfaces %}
    {{ stype.name }}( PointerConverter& converter, const data::Ptr< data::{{ interface.part }} >& data );
    void reconstruct( const data::Ptr< data::{{ interface.part }} >& data );
{% endfor %}{# stype.interfaces #}
    virtual ~{{ stype.name }}();
{% for interface in stype.interfaces %}
    // {{ interface.name }}
{% for function in interface.functions %}
    virtual {{ function.returntype }} {{ function.name }}({{function.params }});
{% endfor %}{# interface.functions #}
{% endfor %}{# stype.interfaces #}
};

{% endfor %}{# stage.supertypes #}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Super type definitions
{% for stype in stage.supertypes %}
{% for interface in stype.interfaces %}
{{ stype.name }}::{{ stype.name }}( PointerConverter& converter, const data::Ptr< data::{{ interface.part }} >& data )
    :   m_converter( converter ),
        m_data( data )
{
}
void {{ stype.name }}::reconstruct( const data::Ptr< data::{{ interface.part }} >& data )
{
    m_data = data;
}
{% endfor %}{# stype.interfaces #}
{{ stype.name }}::~{{ stype.name }}()
{
}
{% for interface in stype.interfaces %}
// {{ interface.name }}
{% for function in interface.functions %}
{{ function.returntype }} {{ stype.name }}::{{ function.name }}({{function.params }})
{
    data::Ptr< data::{{ function.objectpart }} > part = 
        data::convert< data::{{ function.objectpart }} >( m_data );
{% for line in function.body %}
    {{ line }}
{% endfor %}{# function.body #}
}
{% endfor %}{# interface.functions #}
{% endfor %}{# stype.interfaces #}
{% endfor %}{# stage.supertypes #}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Database implementation
struct Database::Pimpl : public data::ObjectPartLoader, public PointerConverter
{
    using SuperTypePtr = std::unique_ptr< SuperTypeBase >;
    struct ObjectInfoHash
    {
        std::size_t operator()( const mega::io::ObjectInfo& objectInfo ) const
        {
            static auto hashgenerator =  std::hash<std::int32_t>{};
            return common::hash_combine( {
                hashgenerator(objectInfo.getType()),
                hashgenerator(objectInfo.getFileID()),
                hashgenerator(objectInfo.getIndex()) } );
        }
    };
    struct ObjectInfoEquality
    {
        std::size_t operator()( const mega::io::ObjectInfo& left, const mega::io::ObjectInfo& right ) const
        {
            return  left.getType()      == right.getType() &&
                    left.getFileID()    == right.getFileID() &&
                    left.getIndex()     == right.getIndex() ;
        }
    };
    using InterfaceMap = std::unordered_map< mega::io::ObjectInfo, SuperTypePtr, ObjectInfoHash, ObjectInfoEquality >;
    using FileMap = std::map< mega::io::ObjectInfo::FileID, mega::io::File::Ptr >;
    using FileMapCst = std::map< mega::io::ObjectInfo::FileID, mega::io::File::PtrCst >;
{% if stage.perobject %}
    Pimpl( const mega::io::Environment& environment, const boost::filesystem::path& objectFile )
        :   m_environment( environment ),
            m_objectFile( objectFile ),
            m_manifest( m_environment.project_manifest() )
    {
        create();
    }
{% endif %}
{% if not stage.perobject %}
    Pimpl( const mega::io::Environment& environment )
        :   m_environment( environment ),
            m_manifest( m_environment.project_manifest() )
    {
        create();
    }
{% endif %}

{% for many_accessor in stage.many_accessors %}
    std::vector< {{ many_accessor.type }}* > many_{{ many_accessor.longname }}() const
    {
        std::vector< {{ many_accessor.type }}* > result;
        {
            std::vector< mega::io::FileInfo > fileInfos;
            m_manifest.getCompilationFileInfos( 
                mega::io::FileInfo::FILE_{{ many_accessor.stage }}_{{ many_accessor.file }}{% if stage.perobject %}, m_objectFile{% endif %}, fileInfos );
            for( const mega::io::FileInfo& fileInfo : fileInfos )
            {
                mega::io::File::PtrCst pFile = getFile( fileInfo );
                for( mega::io::Object* pObject : pFile->range() )
                {
                    if( data::{{ many_accessor.file }}::{{ many_accessor.object }}* pFound = 
                        dynamic_cast< data::{{ many_accessor.file }}::{{ many_accessor.object }}* >( pObject ) )
                    {
                        data::Ptr< data::{{ many_accessor.file }}::{{ many_accessor.object }} > pData( const_cast<Database::Pimpl&>(*this), pFound );
                        result.push_back( toSuper( pData ) );
                    }
                }
            }
        }
        return result;
    }
{% endfor %}{# stage.accessors #}
{% for one_accessor in stage.one_accessors %}
    {{ one_accessor.type }}* one_{{ one_accessor.longname }}() const
    {
        std::vector< {{ one_accessor.type }}* > result = many_{{ one_accessor.longname }}();
        VERIFY_RTE_MSG( !result.empty(), "Singular accessor for {{ one_accessor.type }} found none" );
        VERIFY_RTE_MSG( result.size() == 1U, "Singular accessor for {{ one_accessor.type }} found many" );
        return result.back();
    }
{% endfor %}{# stage.accessors #}
{% for one_opt_accessor in stage.one_opt_accessors %}
    {{ one_opt_accessor.type }}* > oneOpt_{{ one_opt_accessor.longname }}() const
    {
        std::vector< {{ one_opt_accessor.type }}* > result = many_{{ one_opt_accessor.longname }}();
        VERIFY_RTE_MSG( result.size() > 1U, "Singular accessor for {{ one_accessor.type }} found many" );
        if( !result.empty() )
            return result.back();
        else
            return nullptr;
    }
{% endfor %}{# stage.accessors #}

{% for constructor in stage.constructors %}
    {{ constructor.return_type }}* {{ constructor.function_name }}( const {{ constructor.return_type }}::Args& arguments )
    {
        using SuperType = {{ constructor.super_type_name }};
        SuperType* pSuper = nullptr;
        Database::Pimpl& database = *this;

{% for base in constructor.bases %}
{% if not loop.is_first %}
        struct Visitor
        {
            Database::Pimpl& database;
            SuperType*& pSuper;
            Visitor( Database::Pimpl& database, SuperType*& pSuper )
                :   database( database ),
                    pSuper( pSuper )
            {}

            data::Ptr< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} > operator()( {{ base.typename }}* pExisting ) const
            {
                pSuper = dynamic_cast< SuperType* >( pExisting );
                VERIFY_RTE( pSuper );
                return data::convert< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} >( pSuper->m_data );
            }
{% if base.owns_primary_part %}
            data::Ptr< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} > operator()( const {{ base.typename }}::Args& arguments ) const
            {
{% endif %}{# base.owns_primary_part #}
{% endif %}
{% if base.owns_primary_part %}
        // primary part: {{ base.typename }}
        data::Ptr< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} > pPrimaryObjectPart =
            database.m_pFile_{{ base.primary_part.file }}->construct< data::{{ base.primary_part.file }}::{{ base.primary_part.object }} >
                ({% for arg in base.primary_part.args %}{{ arg.expression }}{% if not loop.is_last %}, {% endif %}{% endfor %});

{% for secondary_part in base.parts %}
        // secondary part: {{ secondary_part.file }} :: {{ secondary_part.object }}
        pPrimaryObjectPart->p_{{ secondary_part.file }}_{{ secondary_part.object }} =
            database.m_pFile_{{ secondary_part.file }}->construct< data::{{ secondary_part.file }}::{{ secondary_part.object }} >
                ({% for arg in secondary_part.args %}{{ arg.expression }}{% if not loop.is_last %}, {% endif %}{% endfor %});

{% endfor %}{# base.parts #}
{% endif %}{# base.owns_primary_part #}
{% endfor %}{# constructor.bases #}
{% for base in constructor.bases_reverse%}
{% if not loop.is_last %}
{% if base.owns_primary_part %}
                return pPrimaryObjectPart;
            }
{% endif %}{# base.owns_primary_part #}
        } visitor( database, pSuper );

        pPrimaryObjectPart->p_{{ base.primary_part.file }}_{{ base.primary_part.object }} =
            std::visit( visitor, arguments.base.value() );
{% endif %}
{% endfor %}{# constructor.bases #}
        if( pSuper == nullptr )
        {
            pSuper = new SuperType( *this, pPrimaryObjectPart );
            m_interfaceHash[ pPrimaryObjectPart.getObjectInfo() ] = SuperTypePtr( pSuper );
        }
        else
        {
            pSuper->reconstruct( pPrimaryObjectPart );
        }
        return dynamic_cast< {{ constructor.return_type }}* >( pSuper );
    }
{% endfor %}{# stage.constructors#}

    void create()
    {
        // create read-write files
{% for file in stage.readwrite_files %}
        {
            std::vector< mega::io::FileInfo > fileInfos;
            m_manifest.getCompilationFileInfos( mega::io::FileInfo::FILE_{{ stage.name }}_{{ file.name }}{% if stage.perobject %}, m_objectFile{% endif %}, fileInfos );
            VERIFY_RTE( fileInfos.size() == 1U );
            const mega::io::FileInfo& fileInfo = fileInfos.front();
            m_pFile_{{ file.name }} = std::make_shared< mega::io::File >( fileInfo, *this ) ;
            m_readwriteFiles.insert( std::make_pair( fileInfo.getFileID(), m_pFile_{{ file.name }} ) ); 
        }
{% endfor %}{# stage.readwrite_files #}
    }

    void store()
    {
        for ( FileMap::const_iterator 
                i = m_readwriteFiles.begin(), 
                iEnd = m_readwriteFiles.end();
              i != iEnd; ++i )
        {
            i->second->store( m_manifest );
        }
    }

    mega::io::File::PtrCst getFile( const mega::io::FileInfo& fileInfo ) const
    {
        FileMap::const_iterator iFind = m_readwriteFiles.find( fileInfo.getFileID() );
        if( iFind != m_readwriteFiles.end() )
        {
            return iFind->second;
        }
        else
        {
            FileMapCst::const_iterator iFind = m_readonlyFiles.find( fileInfo.getFileID() );
            if( iFind != m_readonlyFiles.end() )
            {
                return iFind->second;
            }
            else
            {
                mega::io::File::Ptr pNewFile = 
                    std::make_shared< mega::io::File >( fileInfo, 
                        const_cast< Database::Pimpl&>(*this) );
                pNewFile->load( m_manifest );
                m_readonlyFiles.insert( std::make_pair( fileInfo.getFileID(), pNewFile ) );
                return pNewFile;
            }
        }
    }

    virtual mega::io::Object* load( const mega::io::ObjectInfo& objectInfo )
    {
        mega::io::File::PtrCst pFile = 
            getFile( m_manifest.getCompilationFilePath( objectInfo.getFileID() ) );
        return pFile->getObject( objectInfo.getIndex() );
    }

{% for super_conversion in stage.super_conversions %}
    virtual {{ super_conversion.supertype }}* toSuper( const data::Ptr< data::{{ super_conversion.file }}::{{ super_conversion.object }} >& pData ) const
    {
        InterfaceMap::const_iterator iFind = m_interfaceHash.find( pData->getObjectInfo() );
        if( iFind != m_interfaceHash.end() )
        {
            {{ super_conversion.supertype }}* pSuper = dynamic_cast< {{ super_conversion.supertype }}* >( iFind->second.get() );
            VERIFY_RTE( pSuper );
            return pSuper;
        }
        else
        {
            using SuperType = {{ super_conversion.supertype }};
            SuperType* pSuper = new SuperType( const_cast<Database::Pimpl&>(*this), pData );
            m_interfaceHash[ pData->getObjectInfo() ] = SuperTypePtr( pSuper );
            return pSuper;
        }
    }
    virtual data::Ptr< data::{{ super_conversion.file }}::{{ super_conversion.object }} > 
        toData_{{ super_conversion.file }}_{{ super_conversion.object }}( {{ super_conversion.supertype }}* pSuper ) const
    {
        return data::convert< data::{{ super_conversion.file }}::{{ super_conversion.object }} >( pSuper->m_data );
    }
{% endfor %}{# stage.super_conversions #}

{% for interface_conversion in stage.interface_conversions %}
    virtual {{ interface_conversion.type }}* toInterface( const data::Ptr< data::{{ interface_conversion.file }}::{{ interface_conversion.object }} >& pData ) const
    {
        InterfaceMap::const_iterator iFind = m_interfaceHash.find( pData->getObjectInfo() );
        if( iFind != m_interfaceHash.end() )
        {
            {{ interface_conversion.type }}* pSuper = dynamic_cast< {{ interface_conversion.type }}* >( iFind->second.get() );
            VERIFY_RTE( pSuper );
            return pSuper;
        }
        else
        {
            using SuperType = {{ interface_conversion.supertype }};
            SuperType* pSuper = new SuperType( const_cast<Database::Pimpl&>(*this), pData );
            m_interfaceHash[ pData->getObjectInfo() ] = SuperTypePtr( pSuper );
            return pSuper;
        }
    }
    virtual data::Ptr< data::{{ interface_conversion.file }}::{{ interface_conversion.object }} > toData( {{ interface_conversion.type }}* pInterface ) const
    {
        using SuperType = {{ interface_conversion.supertype }};
        SuperType* pSuper = dynamic_cast< SuperType* >( pInterface );
        return data::convert< data::{{ interface_conversion.file }}::{{ interface_conversion.object }} >( pSuper->m_data );
    }
{% endfor %}{# stage.interface_conversions #}

    const mega::io::Environment& m_environment;
{% if stage.perobject %}
    boost::filesystem::path m_objectFile;
{% endif %}
    const mega::io::Manifest m_manifest;

    FileMap m_readwriteFiles;
    mutable FileMapCst m_readonlyFiles;
    mutable InterfaceMap m_interfaceHash;

{% for file in stage.readwrite_files %}
    std::shared_ptr< mega::io::File > m_pFile_{{ file.name }};
{% endfor %}
};


{% if not stage.perobject %}
Database::Database( const mega::io::Environment& environment )
:   m_pimpl( new Pimpl( environment ) )
{
}
{% endif %}
{% if stage.perobject %}
Database::Database( const mega::io::Environment& environment, const boost::filesystem::path& objectFile )
:   m_pimpl( new Pimpl( environment, objectFile ) )
{
}
{% endif %}

void Database::store()
{
    m_pimpl->store();
}

{% for many_accessor in stage.many_accessors %}
std::vector< {{ many_accessor.type }}* > Database::many_{{ many_accessor.longname }}() const
{
    return m_pimpl->many_{{ many_accessor.longname }}();
}
{% endfor %}{# stage.accessors #}
{% for one_accessor in stage.one_accessors %}
{{ one_accessor.type }}* Database::one_{{ one_accessor.longname }}() const
{
    return m_pimpl->one_{{ one_accessor.longname }}();
}
{% endfor %}{# stage.accessors #}
{% for one_opt_accessor in stage.one_opt_accessors %}
{{ one_opt_accessor.type }}* > Database::oneOpt_{{ one_opt_accessor.longname }}() const
{
    return m_pimpl->oneOpt_{{ one_opt_accessor.longname }}();
}
{% endfor %}{# stage.accessors #}
{% for constructor in stage.constructors %}
{{ constructor.return_type }}* Database::{{ constructor.function_name }}( const {{ constructor.return_type }}::Args& arguments )
{
    return m_pimpl->{{ constructor.function_name }}( arguments );
}
{% endfor %}{# stage.constructors #}

}