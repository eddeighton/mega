struct {{ name }} : public mega::reference
{
    enum : mega::TypeID::ValueType { ID = {{ typeid }} };
    inline {{ name }}() = default;
    inline {{ name }}( mega::reference reference ) : mega::reference( reference ) {}
    template< typename T >
    inline bool operator==( const T& cmp ) const
    {
        return mega::reference::operator==( cmp );
    }
    template< typename T >
    inline bool operator!=( const T& cmp ) const
    {
        return !this->operator==( cmp );
    }
    inline operator const void*() const
    {
        return is_valid() ? this : nullptr;
    }
    
{% if has_operation %}
    {{operation_return_type}} operator()({{operation_params_string}}) const;
{% endif %}

{% for invocation in invocations %}
    template < std::size_t InvocationUUID, typename... Args >
    typename _result_type< InvocationUUID >::Type {{ invocation.name }}( Args... args ) const;
{% endfor %}

    // traits
{% for trait_struct in trait_structs %}
    struct {{ trait_struct.name }};
{% endfor %}

    // subtree
    {{ nested }}
};
