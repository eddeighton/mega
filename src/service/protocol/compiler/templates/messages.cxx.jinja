//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.




#include "service/protocol/model/messages.hxx"

#include <variant>

namespace mega
{
namespace network
{

{%for message in messages%}
{%for namespace in message.namespaces%}
{%if loop.is_first %}namespace {{namespace}}{%else%}::{{namespace}}{%endif%}
{%endfor%}{# for namespace in message.namespaces #}
{%if message.has_namespace%} { {%endif%}

Message {{ message.name }}::make( const ConversationID& sender, const ConversationID& receiver, const {{ message.name }}& msg )
{
    return Message{ ID, sender, receiver, msg };
}

const {{ message.name }}& {{ message.name }}::get( const Message& msg )
{
    VERIFY_RTE_MSG( getMsgID( msg ) == ID, "Expected message type: " << getMsgNameFromID( ID ) << " but got: " << getMsgNameFromID( getMsgID( msg ) ) );
    return *std::any_cast< {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }} >( &msg.msg );
}

{%if message.has_namespace%} } {%endif%} 
{%endfor%}

Message make_error_msg( const ConversationID& receiver, const std::string& strErrorMsg )
{
    return Message{ MSG_Error_Response::ID, receiver, receiver, MSG_Error_Response{ strErrorMsg } };
}

bool isRequest( const Message& message )
{
    switch( message.index )
    {
{%for message in messages%}
        case {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}::ID: 
{%if message.is_request %}
            return true;
{% else %}
            return false;
{% endif %}
{% endfor %} 
        default:
        {
            THROW_RTE( "Unknown message: " << getMsgName( message ) );
        }
    }
}

Message decode( boost::archive::binary_iarchive& archive )
{
    Message header;
    archive& header.index;
    archive& header.sender;
    archive& header.receiver;
    switch ( header.index )
    {
{%for message in messages%}
        case {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}::ID:
        {
            {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }} msg;
{%for member in message.members%}
            archive& msg.{{ member.name }}; 
{%endfor%}
            return {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}::make( header.sender, header.receiver, msg );
        }
        break;
{%endfor%}
        default:
        {
            THROW_RTE( "Error decoding message: " << getMsgName( header ) );
        }
    }
}

void encode( boost::archive::binary_oarchive& archive, const Message& message )
{
    archive& message.index;
    archive& message.sender;
    archive& message.receiver;
    switch( message.index )
    {
{%for message in messages%}
        case {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}::ID:
        {
            const {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}& msg = 
                {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}::get( message );
{%for member in message.members%}
            archive& msg.{{ member.name }}; 
{%endfor%}
        }
        break;
{% endfor %}
        default:
        {
            THROW_RTE( "Error decoding message: " << getMsgName( message ) );
        }
    }
}

std::ostream& operator<<( std::ostream& os, const Message& msg )
{
    return os << getMsgName( msg );
}

MessageID getMsgID( const Message& msg )
{
    return msg.index;
}

const char* getMsgNameFromID( MessageID id )
{
    switch( id )
    {
{%for message in messages%}
        case {{ message.id }}: return "{%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}";
{% endfor %}
        default: 
        {
            THROW_RTE( "Unknown message type: " << id );
        }
    }
}

const char* getMsgName( const Message& msg )
{
    return getMsgNameFromID( getMsgID( msg ) );
}

void aggregate( Message& request, const std::vector< Message >& responses )
{
    switch( request.index )
    {
{%for message in messages%}
{% if message.is_broadcast %}
        case {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}::ID:
        {
            {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }}& msg = 
                *std::any_cast< {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.name }} >( &request.msg );
{%for member in message.members%}
{% if loop.is_last %}
            for( const Message& response : responses )
            {
                const {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.response_name }}& responseMsg =
                    *std::any_cast< {%for namespace in message.namespaces%}{{namespace}}::{%endfor%}{{ message.response_name }} >( &response.msg );
                msg.{{ member.name }}.push_back( responseMsg.{{ message.response_member }} );
            }
{% endif %}
{%endfor%}
        }
        break;
{% endif %}
{% endfor %}
        default:
        {
            THROW_RTE( "Error decoding message: " << getMsgName( request ) );
        }
    }
}

}
}