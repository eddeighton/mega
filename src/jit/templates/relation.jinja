//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.


#include "mega/native_types.hpp"
#include "mega/reference.hpp"

#include "service/protocol/common/mpo_context_interface.hpp" 

#include "jit/object_functions.hxx"
#include "jit/jit_exception.hpp"

namespace mega::mangle
{
    void structure_make( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_make_source( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_make_target( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break_source( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break_target( const mega::reference& source, const mega::reference& target, mega::U64 relationID );

    bool ref_vector_empty( void* pData );
    U64 ref_vector_get_size( void* pData );
    U64 ref_vector_find( void* pData, const mega::reference& ref );
    mega::reference& ref_vector_back( void* pData );
    mega::reference& ref_vector_get_at( void* pData, mega::U64 index );

    void ref_vector_remove( void* pData, const mega::reference& ref );
    void ref_vector_remove_at( void* pData, mega::U64 index );
    void ref_vector_pop( void* pData );
    void ref_vector_add( void* pData, const mega::reference& ref );;

    void log( const char* );
}

void prepare( mega::reference& ref )
{
    if( ref.valid() )
    {
        if( ref.getMPO() != mega::runtime::getThisMPO() )
        {
            mega::runtime::writeLock( ref );
        }
        else if( ref.isNetworkAddress() )
        {
            mega::runtime::networkToHeap( ref );
        }
    }
}

bool isSource( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for source in sources %}
        case {{ source.type }} : return true;
{% endfor %}
    }
    return false;
}

bool isTarget( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for target in targets %}
        case {{ target.type }} : return true;
{% endfor %}
    }
    return false;
}

struct Link
{
    mega::reference source;
    mega::reference target;
};

Link link_load_{{ relationID }}( mega::reference& context, mega::reference& parameter)
{
    // test pointers
    if( ( !context.valid() ) || ( !parameter.valid() ) )
    {
        throw mega::runtime::JITException{ "Invalid parameters to link_load_{{ relationID }}" };
    }

    // load into memory
    prepare( context );
    prepare( parameter );

    // determine source and target
    mega::reference source = isSource( context ) ? context : parameter;
    mega::reference target = isSource( context ) ? parameter : context;
    
    // check correct types
    if( !isSource( source ) )
    {
        throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid source" };
    }

{% if owning %}
    switch( target.getType() )
    {
{% for target in targets %}
        case {{ target.object_type }} : 
        {
            target = mega::reference::make( target, mega::TypeInstance{ {{ target.type }}, 0U } );
        }
        break;
{% endfor %}
    }
{% endif %}

    if( !isTarget( target ) )
    {
        throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid target" };
    }

    return Link{ source, target };
}

void* get_data( const mega::reference& ref, mega::U64 offset )
{
    return reinterpret_cast< char* >( ref.getHeap() ) + offset;
}
mega::reference& get_data_singular( const mega::reference& ref, mega::U64 offset )
{
    return *reinterpret_cast< mega::reference* >( get_data( ref, offset ) );
}

void link_make_{{ relationID }}( mega::reference context, mega::reference parameter )
{
    const Link link = link_load_{{ relationID }}( context, parameter );

    // unlink singular from any existing
    switch( link.source.getType() )
    {
{% for source in sources %}
{% if source.singular %}
        case {{ source.type }} :
        {
            mega::reference& sourceRef = get_data_singular( link.source, {{ source.part_offset }} + ( {{ source.part_size }} * link.source.getInstance() ) + {{ source.dimension_offset }} );
            if( sourceRef.valid() )
            {
                prepare( sourceRef );

                switch( sourceRef.getType() )
                {
{% for target in targets %}
                    case {{ target.type }} :
                    {
{% if target.singular %}
                        mega::reference& targetRef = get_data_singular( sourceRef, {{ target.part_offset }} + ( {{ target.part_size }} * sourceRef.getInstance() ) + {{ target.dimension_offset }} );
                        targetRef = mega::reference{};

{% else %}
                        void* pTargetRef = get_data( sourceRef, {{ target.part_offset }} + ( {{ target.part_size }} * sourceRef.getInstance() ) + {{ target.dimension_offset }} );
                        mega::mangle::ref_vector_remove( pTargetRef, link.source );
{% endif %}
                    }
                    break;
{% endfor %}
                }
                mega::mangle::structure_break( link.source, sourceRef, {{ relationID }} );
                sourceRef = mega::reference{};
            }
        }
        break;
{% endif %}
{% endfor %}
    }
    switch( link.target.getType() )
    {
{% for target in targets %}
{% if target.singular %}
        case {{ target.type }} :
        {
            mega::reference& targetRef = get_data_singular( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );

            if( targetRef.valid() )
            {
                prepare( targetRef );

                switch( targetRef.getType() )
                {
{% for source in sources %}
                    case {{ source.type }} :
                    {
{% if source.singular %}
                        mega::reference& sourceRef = get_data_singular( targetRef, {{ source.part_offset }} + ( {{ source.part_size }} * targetRef.getInstance() ) + {{ source.dimension_offset }} );
                        sourceRef = mega::reference{};
{% else %}
                        void* pSourceRef = get_data( targetRef, {{ source.part_offset }} + ( {{ source.part_size }} * targetRef.getInstance() ) + {{ source.dimension_offset }} );
                        mega::mangle::ref_vector_remove( pSourceRef, link.target );
{% endif %}
                    }
                    break;
{% endfor %}
                }
                mega::mangle::structure_break( link.target, targetRef, {{ relationID }} );
                targetRef = mega::reference{};
            }
        }
        break;
{% endif %}
{% endfor %}
    }

    // make new link
    switch( link.source.getType() )
    {
{% for source in sources %}
        case {{ source.type }} :
        {
{% if source.singular %}
            mega::reference& sourceRef = get_data_singular( link.source, {{ source.part_offset }} + ( {{ source.part_size }} * link.source.getInstance() ) + {{ source.dimension_offset }} );
            sourceRef = link.target;
{% else %}
            void* pSourceRef = get_data( link.source, {{ source.part_offset }} + ( {{ source.part_size }} * link.source.getInstance() ) + {{ source.dimension_offset }} );
            mega::mangle::ref_vector_add( pSourceRef, link.target );
{% endif %}
        }
        break;
{% endfor %}
    }
    switch( link.target.getType() )
    {
{% for target in targets %}
        case {{ target.type }} :
        {
{% if target.singular %}
            mega::reference& targetRef = get_data_singular( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );
            targetRef = link.source;
{% else %}
            void* ptargetRef = get_data( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );
            mega::mangle::ref_vector_add( ptargetRef, link.source );
{% endif %}
        }
        break;
{% endfor %}
    }

    mega::mangle::structure_make( link.source, link.target, {{ relationID }} );
}


void link_break_{{ relationID }}( mega::reference context, mega::reference parameter )
{
    const Link link = link_load_{{ relationID }}( context, parameter );

    // remove existing link
    switch( link.source.getType() )
    {
{%  for source in sources %}
        case {{ source.type }} :
        {
{%      if source.singular %}
            mega::reference& sourceRef = get_data_singular( link.source, {{ source.part_offset }} + ( {{ source.part_size }} * link.source.getInstance() ) + {{ source.dimension_offset }} );
            if( sourceRef == link.target )
            {
                switch( link.target.getType() )
                {
{%          for target in targets %}
                    case {{ target.type }} :
                    {
{%              if target.singular %}
                        mega::reference& targetRef = get_data_singular( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );

                        if( targetRef == link.source )
                        {
                            // break the link
                            mega::mangle::structure_break( link.source, link.target, {{ relationID }} );
                            sourceRef = mega::reference{};
                            targetRef = mega::reference{};
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              else %}
                        void* pTargetRef = get_data( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );
                        const auto sourceIndex = mega::mangle::ref_vector_find( pTargetRef, link.source );
                        if( sourceIndex < mega::mangle::ref_vector_get_size( pTargetRef ) )
                        {
                            // break the link
                            mega::mangle::structure_break( link.source, link.target, {{ relationID }} );
                            sourceRef = mega::reference{};
                            mega::mangle::ref_vector_remove_at( pTargetRef, sourceIndex );
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              endif %}
                    }
                    break;
{%          endfor %}
                }
            }
            else
            {
                throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
            }
{%      else %}
            void* pSourceRef = get_data( link.source, {{ source.part_offset }} + ( {{ source.part_size }} * link.source.getInstance() ) + {{ source.dimension_offset }} );
            const auto targetIndex = mega::mangle::ref_vector_find( pSourceRef, link.target );
            if( targetIndex < mega::mangle::ref_vector_get_size( pSourceRef ) )
            {
                switch( link.target.getType() )
                {
{%          for target in targets %}
                    case {{ target.type }} :
                    {
{%              if target.singular %}
                        mega::reference& targetRef = get_data_singular( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );
                        if( targetRef == link.source )
                        {
                            // break the link
                            mega::mangle::structure_break( link.source, link.target, {{ relationID }} );
                            mega::mangle::ref_vector_remove_at( pSourceRef, targetIndex );
                            targetRef = mega::reference{};
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              else %}
                        void* pTargetRef = get_data( link.target, {{ target.part_offset }} + ( {{ target.part_size }} * link.target.getInstance() ) + {{ target.dimension_offset }} );
                        const auto sourceIndex = mega::mangle::ref_vector_find( pTargetRef, link.source );
                        if( sourceIndex < mega::mangle::ref_vector_get_size( pTargetRef ) )
                        {
                            // break the link
                            mega::mangle::structure_break( link.source, link.target, {{ relationID }} );
                            mega::mangle::ref_vector_remove_at( pSourceRef, targetIndex );
                            mega::mangle::ref_vector_remove_at( pTargetRef, sourceIndex );
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              endif %}
                    }
                    break;
{%          endfor %}
                }
            }
            else
            {
                throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
            }
{%      endif %}
        }
        break;
{%  endfor %}
    }
}

void link_reset_{{ relationID }}( mega::reference context )
{
    // test pointer

    // load pointer to heap

    // determine source and target

    // unlink ALL existing links
}


mega::U64 link_size_{{ relationID }}( mega::reference context )
{
    // test pointer

    // load pointer to heap

    // determine size
    return 0;
}


mega::reference link_get_{{ relationID }}( mega::reference context, mega::U64 index )
{
    // test pointer

    // load pointer to heap

    // read existing link
    return mega::reference{};
        
}
