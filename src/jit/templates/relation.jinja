//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.


#include "mega/native_types.hpp"
#include "mega/reference.hpp"

#include "service/protocol/common/mpo_context_interface.hpp" 

#include "jit/object_functions.hxx"
#include "jit/jit_exception.hpp"

namespace mega::mangle
{
    void structure_make( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_make_source( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_make_target( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break_source( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break_target( const mega::reference& source, const mega::reference& target, mega::U64 relationID );

    bool ref_vector_contains( void* pData, const mega::reference& ref );
    void ref_vector_remove( void* pData, const mega::reference& ref );
    void ref_vector_add( void* pData, const mega::reference& ref );
    bool ref_vector_empty( void* pData );
    mega::reference ref_vector_back( void* pData );
    void ref_vector_pop( void* pData );

    void log( const char* );
}

void prepare( mega::reference& ref )
{
    if( ref.is_valid() )
    {
        if( ref.getMPO() != mega::runtime::getThisMPO() )
        {
            mega::runtime::writeLock( ref );
        }
        else if( ref.isNetworkAddress() )
        {
            mega::runtime::networkToHeap( ref );
        }
    }
}

bool isSource( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for source in sources %}
        case {{ source.type }} : return true;
{% endfor %}
    }
    return false;
}

bool isTarget( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for target in targets %}
        case {{ target.type }} : return true;
{% endfor %}
    }
    return false;
}

void* getSourceData( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for source in sources %}
        case {{ source.type }} : 
        {
            return reinterpret_cast< char* >( ref.getHeap() )
                + {{ source.part_offset }} + ( {{ source.part_size }} * ref.getInstance() ) 
                + {{ source.dimension_offset }};
        }
        break;
{% endfor %}
        default:
            throw mega::runtime::JITException{ "Invalid source type for link" };
    }
    return nullptr;
}

void* getTargetData( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for target in targets %}
        case {{ target.type }} : 
        {
            return reinterpret_cast< char* >( ref.getHeap() )
                + {{ target.part_offset }} + ( {{ target.part_size }} * ref.getInstance() ) 
                + {{ target.dimension_offset }};
        }
        break;
{% endfor %}
        default:
            throw mega::runtime::JITException{ "Invalid target type for link" };
    }
    return nullptr;
}

{% if source_singular %}
{%      if target_singular %}
void unlinkSource( const mega::reference& source )
{
    // source AND target are singular
    mega::reference& sourceRef = *reinterpret_cast< mega::reference* >( getSourceData( source ) );
    prepare( sourceRef );
    if( sourceRef.is_valid() )
    {
        mega::reference& sourceTarget = *reinterpret_cast< mega::reference* >( getTargetData( sourceRef ) );
        if( source != sourceTarget )
        {
            throw mega::runtime::JITException{ "Hypergraph error source not equal to target ref" };
        }

        // generate edge delete record
{%          if source_owned %}
        mega::mangle::structure_break_source( source, sourceRef, {{ relationID }} );
{%          else if target_owned %}
        mega::mangle::structure_break_target( source, sourceRef, {{ relationID }} );
{%          else %}
        mega::mangle::structure_break( source, sourceRef, {{ relationID }} );
{%          endif %}
        sourceRef = mega::reference{};
        sourceTarget = mega::reference{};
    }
}
{%      else %}
void unlinkSource( const mega::reference& source )
{
    // source is singular, target is non-singular
    mega::reference& sourceRef = *reinterpret_cast< mega::reference* >( getSourceData( source ) );
    prepare( sourceRef );
    if( sourceRef.is_valid() )
    {
        void* pTargetData = getTargetData( sourceRef );
        if( !mega::mangle::ref_vector_contains( pTargetData, source ) )
        {
            throw mega::runtime::JITException{ "Hypergraph error source not contained in target" };
        }

        // generate edge delete record
{%          if source_owned %}
        mega::mangle::structure_break_source( source, sourceRef, {{ relationID }} );
{%          else if target_owned %}
        mega::mangle::structure_break_target( source, sourceRef, {{ relationID }} );
{%          else %}
        mega::mangle::structure_break( source, sourceRef, {{ relationID }} );
{%          endif %}
        mega::mangle::ref_vector_remove( pTargetData, source );
        sourceRef = mega::reference{};
    }
}
{%      endif %}
{% endif %}

{% if target_singular %}
{%      if source_singular %}
void unlinkTarget( const mega::reference& target )
{
    // source AND target are singular
    mega::reference& targetRef = *reinterpret_cast< mega::reference* >( getTargetData( target ) );
    prepare( targetRef );
    if( targetRef.is_valid() )
    {
        mega::reference& sourceRef = *reinterpret_cast< mega::reference* >( getSourceData( targetRef ) );
        if( target != sourceRef )
        {
            throw mega::runtime::JITException{ "Hypergraph error target not equal to source ref" };
        }

        // generate edge delete record
{%          if source_owned %}
        mega::mangle::structure_break_source( targetRef, target, {{ relationID }} );
{%          else if target_owned %}
        mega::mangle::structure_break_target( targetRef, target, {{ relationID }} );
{%          else %}
        mega::mangle::structure_break( targetRef, target, {{ relationID }} );
{%          endif %}

        sourceRef = mega::reference{};
        targetRef = mega::reference{};
    }
}
{%      else %}
void unlinkTarget( const mega::reference& target )
{
    // source is singular, target is non-singular
    mega::reference& targetRef = *reinterpret_cast< mega::reference* >( getTargetData( target ) );
    prepare( targetRef );
    if( targetRef.is_valid() )
    {
        void* pSourceData = getTargetData( targetRef );
        if( !mega::mangle::ref_vector_contains( pSourceData, target ) )
        {
            throw mega::runtime::JITException{ "Hypergraph error target not contained in source" };
        }

        // generate edge delete record
{%          if source_owned %}
        mega::mangle::structure_break_source( targetRef, target, {{ relationID }} );
{%          else if target_owned %}
        mega::mangle::structure_break_target( targetRef, target, {{ relationID }} );
{%          else %}
        mega::mangle::structure_break( targetRef, target, {{ relationID }} );
{%          endif %}

        mega::mangle::ref_vector_remove( pSourceData, target );
        targetRef = mega::reference{};
    }
}
{%      endif %}
{% endif %}


{% if source_singular %}
void linkSource( const mega::reference& source, const mega::reference& target )
{
    *reinterpret_cast< mega::reference* >( getSourceData( source ) ) = target;
}
{% else %}
void linkSource( const mega::reference& source, const mega::reference& target )
{
    mega::mangle::ref_vector_add( getSourceData( source ), target );
}
{% endif %}

{% if target_singular %}
void linkTarget( const mega::reference& target, const mega::reference& source )
{
    *reinterpret_cast< mega::reference* >( getTargetData( target ) ) = source;
}
{% else %}
void linkTarget( const mega::reference& target, const mega::reference& source )
{
    mega::mangle::ref_vector_add( getTargetData( target ), source );
}
{% endif %}

void link_make_{{ relationID }}( mega::reference context, mega::reference parameter )
{
    // mega::mangle::log( "link_make_{{ relationID }}" );
    if( ( !context.is_valid() ) || ( !parameter.is_valid() ) )
    {
        throw mega::runtime::JITException{ "Invalid parameters to link_make_{{ relationID }}" };
    }
    prepare( context );
    prepare( parameter );

    mega::reference& source = isSource( context ) ? context : parameter;
    mega::reference& target = isTarget( parameter ) ? parameter : context;

    if( !isSource( source ) )
    {
        throw mega::runtime::JITException{ "link_make_{{ relationID }} given invalid source" };
    }
    if( !isTarget( target ) )
    {
        throw mega::runtime::JITException{ "link_make_{{ relationID }} given invalid target" };
    }

{% if source_singular %}
    unlinkSource( source );
{% endif %}
{% if target_singular %}
    unlinkTarget( target );
{% endif %}

    linkSource( source, target );
    linkTarget( target, source );

{%      if source_owned %}
    mega::mangle::structure_make_source( source, target, {{ relationID }} );
{%      else if target_owned %}
    mega::mangle::structure_make_target( source, target, {{ relationID }} );
{%      else %}
    mega::mangle::structure_make( source, target, {{ relationID }} );
{%      endif %}
}

void link_break_{{ relationID }}( mega::reference context, mega::reference parameter )
{
    if( ( !context.is_valid() ) || ( !parameter.is_valid() ) )
    {
        throw mega::runtime::JITException{ "Invalid parameters to link_break_{{ relationID }}" };
    }

    prepare( context );
    prepare( parameter );

    mega::reference& source = isSource( context ) ? context : parameter;
    mega::reference& target = isTarget( parameter ) ? parameter : context;
    
    if( !isSource( source ) )
    {
        throw mega::runtime::JITException{ "link_break_{{ relationID }} given invalid source" };
    }
    if( !isTarget( target ) )
    {
        throw mega::runtime::JITException{ "link_break_{{ relationID }} given invalid target" };
    }

{% if source_singular %}
{%      if target_singular %}
    mega::reference& sourceRef = *reinterpret_cast< mega::reference* >( getSourceData( source ) );
    mega::reference& targetRef = *reinterpret_cast< mega::reference* >( getTargetData( target ) );

    if( ( sourceRef != target ) || ( targetRef != source ) )
    {
        throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
    }
            
{%          if source_owned %}
    mega::mangle::structure_break_source( source, target, {{ relationID }} );
{%          else if target_owned %}
    mega::mangle::structure_break_target( source, target, {{ relationID }} );
{%          else %}
    mega::mangle::structure_break( source, target, {{ relationID }} );
{%          endif %}

    sourceRef = mega::reference{};
    targetRef = mega::reference{};
        
{%      else %}
    mega::reference& sourceRef = *reinterpret_cast< mega::reference* >( getSourceData( source ) );
    void* pTargetData = getTargetData( target );

    if( ( sourceRef != target ) || ( !mega::mangle::ref_vector_contains( pTargetData, source ) ) )
    {
        throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
    }

{%          if source_owned %}
    mega::mangle::structure_break_source( source, target, {{ relationID }} );
{%          else if target_owned %}
    mega::mangle::structure_break_target( source, target, {{ relationID }} );
{%          else %}
    mega::mangle::structure_break( source, target, {{ relationID }} );
{%          endif %}
    sourceRef = mega::reference{};
    mega::mangle::ref_vector_remove( pTargetData, source );
    
{%      endif %}
{% else %}
{%      if target_singular %}
    void* pSourceData = getSourceData( source );
    mega::reference& targetRef = *reinterpret_cast< mega::reference* >( getTargetData( target ) );

    if( ( targetRef != source ) || ( !mega::mangle::ref_vector_contains( pSourceData, target ) ) )
    {
        throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
    }

{%          if source_owned %}
    mega::mangle::structure_break_source( source, target, {{ relationID }} );
{%          else if target_owned %}
    mega::mangle::structure_break_target( source, target, {{ relationID }} );
{%          else %}
    mega::mangle::structure_break( source, target, {{ relationID }} );
{%          endif %}
    mega::mangle::ref_vector_remove( pSourceData, target );
    targetRef = mega::reference{};
    
{%      else %}
    void* pSourceData = getSourceData( source );
    void* pTargetData = getTargetData( target );
    if( !mega::mangle::ref_vector_contains( pSourceData, target ) ||
        !mega::mangle::ref_vector_contains( pTargetData, source ) )
    {
        throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
    }
    
{%          if source_owned %}
    mega::mangle::structure_break_source( source, target, {{ relationID }} );
{%          else if target_owned %}
    mega::mangle::structure_break_target( source, target, {{ relationID }} );
{%          else %}
    mega::mangle::structure_break( source, target, {{ relationID }} );
{%          endif %}
    mega::mangle::ref_vector_remove( pSourceData, target );
    mega::mangle::ref_vector_remove( pTargetData, source );
    
{%      endif %}
{% endif %}
}

void link_reset_{{ relationID }}( mega::reference context )
{
    prepare( context );

    if( isSource( context ) )
    {
{% if source_singular %}
        unlinkSource( context );
{% else %}

    void* pSourceData = getSourceData( context );
    while( !mega::mangle::ref_vector_empty( pSourceData ) )
    {
        mega::reference target = mega::mangle::ref_vector_back( pSourceData );
        prepare( target );

{%      if target_singular %}
        mega::reference& targetRef = *reinterpret_cast< mega::reference* >( getTargetData( target ) );
        if( targetRef != context )
        {
            throw mega::runtime::JITException{ "link_reset_{{ relationID }} source target combination does not match link" };
        }
        
        targetRef = mega::reference{};

{%      else %}

        void* pTargetData = getTargetData( target );
        if( !mega::mangle::ref_vector_contains( pTargetData, context ) )
        {
            throw mega::runtime::JITException{ "link_reset_{{ relationID }} source target combination does not match link" };
        }
        mega::mangle::ref_vector_remove( pTargetData, context );

{%      endif %}

        mega::mangle::ref_vector_pop( pSourceData );

{%      if source_owned %}
        mega::mangle::structure_break_source( context, target, {{ relationID }} );
{%      else if target_owned %}
        mega::mangle::structure_break_target( context, target, {{ relationID }} );
{%      else %}
        mega::mangle::structure_break( context, target, {{ relationID }} );
{%      endif %}
    }

{% endif %}
    }
    else if( isTarget( context ) )
    {
{% if target_singular %}
        unlinkTarget( context );
{% else %}

    void* pTargetData = getTargetData( context );
    while( !mega::mangle::ref_vector_empty( pTargetData ) )
    {
        mega::reference source = mega::mangle::ref_vector_back( pTargetData );
        prepare( source );

{%      if source_singular %}
        mega::reference& sourceRef = *reinterpret_cast< mega::reference* >( getSourceData( source ) );
        if( sourceRef != context )
        {
            throw mega::runtime::JITException{ "link_reset_{{ relationID }} source target combination does not match link" };
        }
        
        targetRef = mega::reference{};

{%      else %}

        void* pSourceData = getSourceData( source );
        if( !mega::mangle::ref_vector_contains( pSourceData, context ) )
        {
            throw mega::runtime::JITException{ "link_reset_{{ relationID }} source target combination does not match link" };
        }
        mega::mangle::ref_vector_remove( pSourceData, context );

{%      endif %}

        mega::mangle::ref_vector_pop( pTargetData );

{%      if source_owned %}
        mega::mangle::structure_break_source( source, context, {{ relationID }} );
{%      else if target_owned %}
        mega::mangle::structure_break_target( source, context, {{ relationID }} );
{%      else %}
        mega::mangle::structure_break( source, context, {{ relationID }} );
{%      endif %}
    }

{% endif %}
    }
    else
    {
        throw mega::runtime::JITException{ "link_reset_{{ relationID }} invalid reference" };
    }
}