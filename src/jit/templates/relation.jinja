//  Copyright (c) Deighton Systems Limited. 2022. All Rights Reserved.
//  Author: Edward Deighton
//  License: Please see license.txt in the project root folder.

//  Use and copying of this software and preparation of derivative works
//  based upon this software are permitted. Any copy of this software or
//  of any derivative work must include the above copyright notice, this
//  paragraph and the one after it.  Any distribution of this software or
//  derivative works must comply with all applicable laws.

//  This software is made available AS IS, and COPYRIGHT OWNERS DISCLAIMS
//  ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE, AND NOTWITHSTANDING ANY OTHER PROVISION CONTAINED HEREIN, ANY
//  LIABILITY FOR DAMAGES RESULTING FROM THE SOFTWARE OR ITS USE IS
//  EXPRESSLY DISCLAIMED, WHETHER ARISING IN CONTRACT, TORT (INCLUDING
//  NEGLIGENCE) OR STRICT LIABILITY, EVEN IF COPYRIGHT OWNERS ARE ADVISED
//  OF THE POSSIBILITY OF SUCH DAMAGES.


#include "mega/native_types.hpp"
#include "mega/reference.hpp"

#include "service/protocol/common/mpo_context_interface.hpp" 

#include "jit/object_functions.hxx"
#include "jit/jit_exception.hpp"

namespace mega::mangle
{
    void structure_make( const mega::reference& source, const mega::reference& target, mega::U64 relationID );
    void structure_break( const mega::reference& source, const mega::reference& target, mega::U64 relationID );

    U64 ref_vector_get_size( void* pData );
    U64 ref_vector_find( void* pData, const mega::reference& ref );
    mega::reference& ref_vector_get_at( void* pData, mega::U64 index );

    void ref_vectors_remove( void* pData1, void* pData2, const mega::reference& ref );
    void ref_vectors_add( void* pData1, void* pData2, const mega::reference& ref, const mega::TypeID& type );
    void ref_vectors_remove_at( void* pData1, void* pData2, mega::U64 index );

    void log( const char* );
}

void prepare( mega::reference& ref )
{
    if( ref.valid() )
    {
        if( ref.getMPO() != mega::runtime::getThisMPO() )
        {
            mega::runtime::writeLock( ref );
        }
        else if( ref.isNetworkAddress() )
        {
            mega::runtime::networkToHeap( ref );
        }
    }
}

bool isSource( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for source in sources %}
        case {{ source.type }} : return true;
{% endfor %}
    }
    return false;
}

bool isTarget( const mega::reference& ref )
{
    switch( ref.getType() )
    {
{% for target in targets %}
        case {{ target.type }} : return true;
{% endfor %}
    }
    return false;
}

struct Link
{
    mega::reference source_ref;
    mega::reference target_ref;
    mega::TypeID    source_type;
    mega::TypeID    target_type;
};

// context is ALWAYS actual link type
// parameter can be link type or link parent context
Link link_load_{{ relationID }}( mega::reference& context, mega::reference& parameter)
{
    // test pointers
    if( ( !context.valid() ) || ( !parameter.valid() ) )
    {
        throw mega::runtime::JITException{ "Invalid parameters to link_load_{{ relationID }}" };
    }

    // load into memory
    prepare( context );
    prepare( parameter );

    Link link;

    if( isSource( context ) )
    {
        link.source_type = context.getType();
        switch( link.source_type )
        {
{% for source in sources %}
            case {{ source.type }} : 
            {
                link.source_ref = mega::reference::make( context, mega::TypeInstance{ {{ source.parent_type }}, context.getInstance() } );

                switch( parameter.getType() )
                {
{% for parameter_type in source.parameter_types %}
{% if parameter_type.unique_parent_context %}
                    case {{ parameter_type.parent_type }}:
                    {
                        link.target_type = mega::TypeID{ {{ parameter_type.type }} };
                        link.target_ref = mega::reference::make( parameter, mega::TypeInstance{ {{ parameter_type.parent_type }}, parameter.getInstance() } );
                    }
                    break;
{% endif %}
                    case {{ parameter_type.type }}:
                    {
                        link.target_type = mega::TypeID{ {{ parameter_type.type }} };
                        link.target_ref = mega::reference::make( parameter, mega::TypeInstance{ {{ parameter_type.parent_type }}, parameter.getInstance() } );
                    }
                    break;
{% endfor %}
                    default:
                    {
                        throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid target parameter" };
                    }
                }
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid source context" };
            }
        }
    }
    else if( isTarget( context ) )
    {
        link.target_type = context.getType();
        switch( link.target_type )
        {
{% for target in targets %}
            case {{ target.type }} : 
            {
                link.target_ref = mega::reference::make( context, mega::TypeInstance{ {{ target.parent_type }}, context.getInstance() } );

                switch( parameter.getType() )
                {
{% for parameter_type in target.parameter_types %}
{% if parameter_type.unique_parent_context %}
                    case {{ parameter_type.parent_type }}:
                    {
                        link.source_type = mega::TypeID{ {{ parameter_type.type }} };
                        link.source_ref = mega::reference::make( parameter, mega::TypeInstance{ {{ parameter_type.parent_type }}, parameter.getInstance() } );
                    }
                    break;
{% endif %}
                    case {{ parameter_type.type }}:
                    {
                        link.source_type = mega::TypeID{ {{ parameter_type.type }} };
                        link.source_ref = mega::reference::make( parameter, mega::TypeInstance{ {{ parameter_type.parent_type }}, parameter.getInstance() } );
                    }
                    break;
{% endfor %}
                    default:
                    {
                        throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid source parameter" };
                    }
                }

            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid target context" };
            }
        }
    }
    else
    {
        throw mega::runtime::JITException{ "Could not match context type in link_load_{{ relationID }}" };
    }

    return link;
}

struct LinkDataSingular
{
    mega::reference& ref;
    mega::TypeID& type;
};
LinkDataSingular get_data_singular( mega::HeapAddress pHeap, mega::U64 refOffset, mega::U64 typeOffset )
{
    char* p = reinterpret_cast< char* >( pHeap );
    return 
    {
        *reinterpret_cast< mega::reference* >( p + refOffset ),
        *reinterpret_cast< mega::TypeID* >( p + typeOffset )
    };
}

struct LinkDataNonSingular
{
    void* pRef;
    void* pType;
};
LinkDataNonSingular get_data_non_singular( mega::HeapAddress pHeap, mega::U64 refOffset, mega::U64 typeOffset )
{
    char* p = reinterpret_cast< char* >( pHeap );
    return 
    {
        p + refOffset,
        p + typeOffset
    };
}

void link_make_{{ relationID }}( mega::reference context, mega::reference parameter )
{
    const Link link = link_load_{{ relationID }}( context, parameter );

    // unlink singular from any existing
    switch( link.source_type )
    {
{% for source in sources %}
{% if source.singular %}
        case {{ source.type }} :
        {
            LinkDataSingular source = get_data_singular( link.source_ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.dimension_offset }}, 
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            if( source.ref.valid() )
            {
                prepare( source.ref );

                switch( source.type )
                {
{% for target in targets %}
                    case {{ target.type }} :
                    {
{% if target.singular %}
                        LinkDataSingular targetRef = get_data_singular( source.ref.getHeap(), 
                            {{ target.part_offset }} + ( {{ target.part_size }} * source.ref.getInstance() ) + {{ target.dimension_offset }}, 
                            {{ target.part_offset }} + ( {{ target.part_size }} * source.ref.getInstance() ) + {{ target.link_type_offset }} 
                        );
                        targetRef.ref   = mega::reference{};
                        targetRef.type  = mega::TypeID{};
{% else %}
                        LinkDataNonSingular target = get_data_non_singular( source.ref.getHeap(), 
                            {{ target.part_offset }} + ( {{ target.part_size }} * source.ref.getInstance() ) + {{ target.dimension_offset }}, 
                            {{ target.part_offset }} + ( {{ target.part_size }} * source.ref.getInstance() ) + {{ target.link_type_offset }} 
                        );
                        mega::mangle::ref_vectors_remove( target.pRef, target.pType, link.source_ref );
{% endif %}
                    }
                    break;
{% endfor %}
                }
                mega::mangle::structure_break( 
                    mega::reference::make( link.source_ref, mega::TypeInstance( link.source_type, link.source_ref.getInstance() ) ), 
                    mega::reference::make( source.ref, mega::TypeInstance( source.type, source.ref.getInstance() ) ), 
                    {{ relationID }} );
{% if owning %}
                source.ref.decRefCount();
{% endif %}

                source.ref   = mega::reference{};
                source.type  = mega::TypeID{};
            }
        }
        break;
{% endif %}
{% endfor %}
    }
    switch( link.target_type )
    {
{% for target in targets %}
{% if target.singular %}
        case {{ target.type }} :
        {
            LinkDataSingular target = get_data_singular( 
                link.target_ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }} 
            );

            if( target.ref.valid() )
            {
                prepare( target.ref );

                switch( target.type )
                {
{% for source in sources %}
                    case {{ source.type }} :
                    {
{% if source.singular %}
                        LinkDataSingular sourceRef = get_data_singular( 
                            target.ref.getHeap(), 
                            {{ source.part_offset }} + ( {{ source.part_size }} * target.ref.getInstance() ) + {{ source.dimension_offset }},
                            {{ source.part_offset }} + ( {{ source.part_size }} * target.ref.getInstance() ) + {{ source.link_type_offset }} 
                        );
                        sourceRef.ref = mega::reference{};
                        sourceRef.type = mega::TypeID{};
{% else %}
                        LinkDataNonSingular sourceRef = get_data_non_singular( 
                            target.ref.getHeap(), 
                            {{ source.part_offset }} + ( {{ source.part_size }} * target.ref.getInstance() ) + {{ source.dimension_offset }},
                            {{ source.part_offset }} + ( {{ source.part_size }} * target.ref.getInstance() ) + {{ source.link_type_offset }} 
                        );
                        mega::mangle::ref_vectors_remove( sourceRef.pRef, sourceRef.pType, link.target_ref );
{% endif %}
                    }
                    break;
{% endfor %}
                }
                
                mega::mangle::structure_break( 
                    mega::reference::make( link.target_ref, mega::TypeInstance( link.target_type, link.target_ref.getInstance() ) ), 
                    mega::reference::make( target.ref, mega::TypeInstance( target.type, target.ref.getInstance() ) ), 
                    {{ relationID }} );
{% if owning %}
                target.ref.decRefCount();
{% endif %}

                target.ref   = mega::reference{};
                target.type  = mega::TypeID{};
            }
        }
        break;
{% endif %}
{% endfor %}
    }

    // make new link
    switch( link.source_type )
    {
{% for source in sources %}
        case {{ source.type }} :
        {
{% if source.singular %}
            LinkDataSingular source = get_data_singular( link.source_ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            source.ref   = link.target_ref;
            source.type  = link.target_type;
{% else %}
            LinkDataNonSingular source = get_data_non_singular( link.source_ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            mega::mangle::ref_vectors_add( source.pRef, source.pType, link.target_ref, link.target_type );
{% endif %}
        }
        break;
{% endfor %}
    }
    switch( link.target_type )
    {
{% for target in targets %}
        case {{ target.type }} :
        {
{% if target.singular %}
            LinkDataSingular target = get_data_singular( link.target_ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }}
            );
            target.ref   = link.source_ref;
            target.type  = link.source_type;
{% else %}
            LinkDataNonSingular target = get_data_non_singular( link.target_ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }}
            );
            mega::mangle::ref_vectors_add( target.pRef, target.pType, link.source_ref, link.source_type );
{% endif %}
        }
        break;
{% endfor %}
    }

    mega::mangle::structure_make( 
        mega::reference::make( link.source_ref, mega::TypeInstance( link.source_type, link.source_ref.getInstance() ) ), 
        mega::reference::make( link.target_ref, mega::TypeInstance( link.target_type, link.target_ref.getInstance() ) ), 
        {{ relationID }} );

{% if owning %}
    link.target_ref.incRefCount();
{% endif %}
}


void link_break_{{ relationID }}( mega::reference context, mega::reference parameter )
{
    const Link link = link_load_{{ relationID }}( context, parameter );

    // remove existing link
    switch( link.source_type )
    {
{%  for source in sources %}
        case {{ source.type }} :
        {
{%      if source.singular %}
            LinkDataSingular source = get_data_singular( link.source_ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            if( source.ref == link.target_ref )
            {
                switch( link.target_type )
                {
{%          for target in targets %}
                    case {{ target.type }} :
                    {
{%              if target.singular %}
                        LinkDataSingular target = get_data_singular( link.target_ref.getHeap(), 
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }} 
                        );

                        if( target.ref == link.source_ref )
                        {
                            // break the link
                            source.ref   = mega::reference{};
                            source.type  = mega::TypeID{};
                            target.ref   = mega::reference{};
                            target.type  = mega::TypeID{};
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              else %}
                        LinkDataNonSingular target = get_data_non_singular( link.target_ref.getHeap(), 
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }}
                        );
                        const auto sourceIndex = mega::mangle::ref_vector_find( target.pRef, link.source_ref );
                        if( sourceIndex < mega::mangle::ref_vector_get_size( target.pRef ) )
                        {
                            // break the link
                            source.ref   = mega::reference{};
                            source.type  = mega::TypeID{};
                            mega::mangle::ref_vectors_remove_at( target.pRef, target.pType, sourceIndex );
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              endif %}
                    }
                    break;
{%          endfor %}
                }
            }
            else
            {
                throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
            }
{%      else %}
            LinkDataNonSingular source = get_data_non_singular( link.source_ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * link.source_ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            const auto targetIndex = mega::mangle::ref_vector_find( source.pRef, link.target_ref );
            if( targetIndex != mega::mangle::ref_vector_get_size( source.pRef ) )
            {
                switch( link.target_type )
                {
{%          for target in targets %}
                    case {{ target.type }} :
                    {
{%              if target.singular %}
                        LinkDataSingular target = get_data_singular( link.target_ref.getHeap(), 
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }}
                        );
                        if( target.ref == link.source_ref )
                        {
                            // break the link
                            mega::mangle::ref_vectors_remove_at( source.pRef, source.pType, targetIndex );
                            target.ref   = mega::reference{};
                            target.type  = mega::TypeID{};
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              else %}
                        LinkDataNonSingular target = get_data( link.target_ref.getHeap(), 
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.dimension_offset }},
                            {{ target.part_offset }} + ( {{ target.part_size }} * link.target_ref.getInstance() ) + {{ target.link_type_offset }} 
                        );
                        const auto sourceIndex = mega::mangle::ref_vector_find( target.pRef, link.source_ref );
                        if( sourceIndex != mega::mangle::ref_vector_get_size( target.pRef ) )
                        {
                            // break the link
                            mega::mangle::ref_vectors_remove_at( source.pRef, source.pType, targetIndex );
                            mega::mangle::ref_vectors_remove_at( target.pRef, target.pType, sourceIndex );
                        }
                        else
                        {
                            throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
                        }
{%              endif %}
                    }
                    break;
{%          endfor %}
                }
            }
            else
            {
                throw mega::runtime::JITException{ "link_break_{{ relationID }} source target combination does not match link" };
            }
{%      endif %}
        }
        break;
{%  endfor %}
    }
    mega::mangle::structure_break( 
        mega::reference::make( link.source_ref, mega::TypeInstance( link.source_type, link.source_ref.getInstance() ) ), 
        mega::reference::make( link.target_ref, mega::TypeInstance( link.target_type, link.target_ref.getInstance() ) ), 
        {{ relationID }} );
{% if owning %}
    link.target_ref.decRefCount();
{% endif %}
}

struct Context
{
    mega::reference& ref;
    bool             bIsSource;
};

// context is ALWAYS actual link type
// parameter can be link type or link parent context
Context context_load_{{ relationID }}( mega::reference& ref )
{
    // test pointers
    if( ( !ref.valid() ) )
    {
        throw mega::runtime::JITException{ "Invalid ref to link_load_{{ relationID }}" };
    }

    // load into memory
    prepare( ref );

    if( isSource( ref ) )
    {
        switch( ref.getType() )
        {
{% for source in sources %}
            case {{ source.type }} : 
            {
                return Context{ ref, true };
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid source ref" };
            }
        }
    }
    else if( isTarget( ref ) )
    {
        switch( ref.getType() )
        {
{% for target in targets %}
            case {{ target.type }} : 
            {
                return Context{ ref, false };
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_load_{{ relationID }} given invalid target ref" };
            }
        }
    }
    
    throw mega::runtime::JITException{ "Could not match ref type to link_load_{{ relationID }}" };
    return { ref, false };
}

void link_reset_{{ relationID }}( mega::reference ref )
{
    Context context = context_load_{{ relationID }}( ref );

    if( context.bIsSource )
    {
        switch( ref.getType() )
        {
{% for source in sources %}
            case {{ source.type }} : 
            {
{% if source.singular %}
            LinkDataSingular source = get_data_singular( context.ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            if( source.ref.valid() )
            {
                link_break_{{ relationID }}( context.ref, 
                    mega::reference::make( source.ref, mega::TypeInstance( source.type, source.ref.getInstance() ) ) );
            }
{% else %}
            LinkDataNonSingular source = get_data_non_singular( context.ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            while( 0 != mega::mangle::ref_vector_get_size( source.pRef ) )
            {
                auto temp = mega::mangle::ref_vector_get_at( source.pRef, 0U );
                link_break_{{ relationID }}( context.ref, 
                    mega::reference::make( temp.ref, mega::TypeInstance( source.type, temp.ref.getInstance() ) ) );
            }
{% endif %}
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_reset_{{ relationID }} given invalid source ref" };
            }
        }
    }
    else
    {
        switch( ref.getType() )
        {
{% for target in targets %}
            case {{ target.type }} : 
            {
{% if target.singular %}
            LinkDataSingular target = get_data_singular( context.ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.link_type_offset }} 
            );
            if( target.ref.valid() )
            {
                link_break_{{ relationID }}( context.ref, 
                    mega::reference::make( target.ref, mega::TypeInstance( target.type, target.ref.getInstance() ) ) );
            }
{% else %}
            LinkDataNonSingular target = get_data_non_singular( context.ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.link_type_offset }} 
            );
            while( 0 != mega::mangle::ref_vector_get_size( target.pRef ) )
            {
                auto temp = mega::mangle::ref_vector_get_at( target.pRef, 0U );
                link_break_{{ relationID }}( context.ref, 
                    mega::reference::make( temp.ref, mega::TypeInstance( target.type, temp.ref.getInstance() ) ) );
            }
{% endif %}
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_reset_{{ relationID }} given invalid source ref" };
            }
        }
    }
}

mega::U64 link_size_{{ relationID }}( mega::reference ref )
{
    Context context = context_load_{{ relationID }}( ref );

    if( context.bIsSource )
    {
        switch( ref.getType() )
        {
{% for source in sources %}
            case {{ source.type }} : 
            {
{% if source.singular %}
            LinkDataSingular source = get_data_singular( context.ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            return source.ref.valid() ? 1U : 0U;
{% else %}
            LinkDataNonSingular source = get_data_non_singular( context.ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            return mega::mangle::ref_vector_get_size( source.pRef );
{% endif %}
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_size_{{ relationID }} given invalid source ref" };
            }
        }
    }
    else
    {
        switch( ref.getType() )
        {
{% for target in targets %}
            case {{ target.type }} : 
            {
{% if target.singular %}
            LinkDataSingular target = get_data_singular( context.ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.link_type_offset }} 
            );
            return target.ref.valid() ? 1U : 0U;
{% else %}
            LinkDataNonSingular target = get_data_non_singular( context.ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.link_type_offset }} 
            );
            return mega::mangle::ref_vector_get_size( target.pRef );
{% endif %}
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_size_{{ relationID }} given invalid source ref" };
            }
        }
    }
    return 0;
}

mega::reference link_get_{{ relationID }}( mega::reference ref, mega::U64 index )
{
    Context context = context_load_{{ relationID }}( ref );

    if( context.bIsSource )
    {
        switch( ref.getType() )
        {
{% for source in sources %}
            case {{ source.type }} : 
            {
{% if source.singular %}
            LinkDataSingular source = get_data_singular( context.ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            return source.ref;
{% else %}
            LinkDataNonSingular source = get_data_non_singular( context.ref.getHeap(), 
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.dimension_offset }},
                {{ source.part_offset }} + ( {{ source.part_size }} * context.ref.getInstance() ) + {{ source.link_type_offset }} 
            );
            return mega::mangle::ref_vector_get_at( source.pRef, index );
{% endif %}
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_get_{{ relationID }} given invalid source ref" };
            }
        }
    }
    else
    {
        switch( ref.getType() )
        {
{% for target in targets %}
            case {{ target.type }} : 
            {
{% if target.singular %}
            LinkDataSingular target = get_data_singular( context.ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.link_type_offset }} 
            );
            return target.ref;
{% else %}
            LinkDataNonSingular target = get_data_non_singular( context.ref.getHeap(), 
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.dimension_offset }},
                {{ target.part_offset }} + ( {{ target.part_size }} * context.ref.getInstance() ) + {{ target.link_type_offset }} 
            );
            return mega::mangle::ref_vector_get_at( target.pRef, index  );
{% endif %}
            }
            break;
{% endfor %}
            default:
            {
                throw mega::runtime::JITException{ "link_get_{{ relationID }} given invalid source ref" };
            }
        }
    }
    return {};
}
